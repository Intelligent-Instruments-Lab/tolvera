{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"T\u00f6lvera","text":""},{"location":"#tolvera","title":"T\u00f6lvera","text":"<p>T\u00f6lvera is a library for exploring musical performance with artificial life (ALife) and self-organising systems. The word is an Icelandic kenning:</p> <ul> <li>T\u00f6lva = computer, from tala (number) + v\u00f6lva (prophetess)</li> <li>Vera = being</li> <li>T\u00f6lvera = number being</li> </ul> <p>T\u00f6lvera is written in Taichi, a domain-specific language embedded in Python.</p> <p>This is experimental software and everything is currently subject to change.</p> <p>Join us on the T\u00f6lvera Discord.</p>"},{"location":"#showcase","title":"Showcase","text":"<p>Visit the YouTube Playlist (if you'd like to add a video, please get in touch).</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li><code>tv.v</code>: a collection of \"vera\" (beings) including Move, Flock, Slime and Swarm, with more being continuously added. Vera can be combined and composed in various ways.</li> <li><code>tv.p</code>: extensible particle system.</li> <li><code>tv.s</code>: multi-species system where each species has a unique relationship with every other species, including itself.</li> <li><code>tv.px</code>: drawing library including various shapes and blend modes.</li> <li><code>tv.osc</code>: Open Sound Control (OSC) via iipyper, including automated export of OSC schemas to JSON, XML, Pure Data (Pd), Max/MSP (SuperCollider TBC).</li> <li><code>tv.iml</code>: Interactive Machine Learning via iml.</li> <li><code>tv.ti</code>: Taichi-based simulation and rendering engine. Can be run \"headless\" (without graphics).</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Taichi supports numerous operating systems and backends. If you plan on using Vulkan for graphics (recommended for macOS), you may need to install the Vulkan SDK first and restart your machine.</p> <p>T\u00f6lvera is registered on PyPI and can be installed via a Python package manager such as <code>pip</code>:</p> <pre><code>pip install tolvera\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Fork/clone this repository and install the package in editable mode:</p> <pre><code>git clone https://github.com/Intelligent-Instruments-Lab/tolvera # (or clone your own fork)\ncd tolvera\npip install -e tolvera\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome Pull Requests across all areas of the project:</p> <ul> <li>Addressing Issues</li> <li>Adding features (see Issues and Discussion)</li> <li>Examples</li> <li>Tests</li> <li>Documentation</li> </ul>"},{"location":"#community","title":"Community","text":"<p>To discuss T\u00f6lvera with developers and other users:</p> <ul> <li>Use GitHub Issues to report bugs and make specific feature requests.</li> <li>Use GitHub Discussions to share ideas and ask questions.</li> <li>Use Discord for further support, sharing your work, and general chat.</li> </ul> <p>Across the project, we follow the Algorave Code of Conduct. Please get in touch if you experience or witness any conduct issues.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>See Discussion.</p>"},{"location":"#citing","title":"Citing","text":"<p>T\u00f6lvera is being written about and used in a number of contexts (see references.bib), here are a few recent examples:</p> <pre><code>@inproceedings{armitageAgentialScoresExploring2023,\n  Address = {Boston, Massachusetts, USA},\n  Author = { Jack Armitage and Thor Magnusson },\n  Title = {Agential Scores: Artificial Life for Emergent, Self-Organising and Entangled Music Notation},\n  Booktitle = {Proceedings of the International Conference on Technologies for Music Notation and Representation -- TENOR'2023},\n  Pages = {51 - 61},\n  Year = {2023},\n  Editor = {Anthony Paul De Ritis and Victor Zappi and Jeremy Van Buskirk and John Mallia},\n  Publisher = {Northeastern University},\n  ISBN = {978-0-6481592-7-8}\n}\n\n@inproceedings{armitageStrengjavera2023,\n  title = {Strengjavera},\n  booktitle = {{{AI Music Creativity}} 2023},\n  author = {Armitage, Jack},\n  year = {2023},\n  address = {{University of Sussex, Brighton, UK}},\n  doi = {10.5281/zenodo.8329855},\n  ISBN = {978-0-9957862-9-5},\n  url = {https://zenodo.org/records/8329855}\n}\n</code></pre>"},{"location":"#inspiration","title":"Inspiration","text":"<ul> <li>SwissGL</li> <li>Lenia</li> <li>Particle Life (attributed to various, see for example Clusters)</li> <li>Journey to the Microcosmos</li> <li>Complexity Explorables</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p><code>tolvera</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>The full collection of examples can be found in iil-examples. Here are some simple examples:</p>"},{"location":"examples/#rendering-motionless-particles","title":"Rendering motionless particles","text":"<p>This is the most basic syntax for creating a T\u00f6lvera scene. When run, this scene will render a window using default options, and display some motionless particles:</p> <pre><code>from tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @tv.render\n    def _():\n        pass\n</code></pre>"},{"location":"examples/#making-particles-behave","title":"Making particles behave","text":"<p>We can make the particles behave by passing them to a \"vera\", moving or flocking them based on their properties:</p> <pre><code>from tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @tv.render\n    def _():\n        tv.v.move(tv.p) # Moving\n        # tv.v.flock(tv.p) # Flocking\n</code></pre>"},{"location":"examples/#controlling-vera-via-osc-input","title":"Controlling \"vera\" via OSC input","text":"<p>T\u00f6lvera will create an OSC server and client when <code>osc=True</code> is passed: </p> <pre><code>from tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(osc=True, **kwargs)\n\n    @tv.render\n    def _():\n        tv.v.flock(tv.p)\n</code></pre> <p><code>tv.v.flock</code> can now be controlled via OSC in a number of different ways.</p> <p>The full OSC options and their defaults are:</p> <pre><code>{\n    'osc': False,\n    'host': '127.0.0.1',\n    'client': '127.0.0.1',\n    'client_name': 'tolvera',\n    'receive_port': 5001,\n    'send_port': 5000,\n    'osc_debug': False,\n}\n</code></pre>"},{"location":"examples/#osc-output-api","title":"OSC output API","text":"<p>TBC.</p>"},{"location":"examples/#adding-custom-behaviour-with-tiachi-kernels","title":"Adding custom behaviour with Tiachi kernels","text":"<p>We can use Taichi kernels and functions in T\u00f6lvera to add custom behaviours. In this example we add an attractor kernel, and draw it with <code>tv.px.circle</code>:</p> <pre><code>from tolvera import Tolvera\nimport taichi as ti\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @ti.kernel\n    def attract(tv: ti.template(), pos: ti.math.vec2, mass: ti.f32, radius: ti.f32):\n        for i in range(tv.p.n):\n            p = tv.p.field[i]\n            if p.active == 0: continue\n            target_distance = (pos-p.pos).norm()\n            if target_distance &lt; radius:\n                factor = (radius-target_distance)/radius\n                tv.p.field[i].vel += (pos-p.pos).normalized() * mass * factor\n        tv.px.circle(pos[0], pos[1], radius, [1.,1.,1.,1.])\n\n    @tv.render\n    def _():\n        tv.v.move(tv.p)\n        attract(tv, [tv.x/2, tv.y/2], 10., 300.)\n</code></pre>"},{"location":"examples/#live-coding-with-sardine","title":"Live Coding with Sardine","text":"<p>Sardine is a Python-based live coding environment which can be used to live code T\u00f6lvera (currently tested in Visual Studio Code only):</p> <pre><code>from sardine_core.run import *\nfrom tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @ti.kernel\n    def attract(tv: ti.template(), pos: ti.math.vec2, mass: ti.f32, radius: ti.f32):\n        for i in range(tv.p.n):\n            p = tv.p.field[i]\n            if p.active == 0: continue\n            target_distance = (pos-p.pos).norm()\n            if target_distance &lt; radius:\n                factor = (radius-target_distance)/radius\n                tv.p.field[i].vel += (pos-p.pos).normalized() * mass * factor\n        tv.px.circle(pos[0], pos[1], radius, [1.,1.,1.,1.])\n    attract_kernel = attract # workaround for redefining kernels\n\n    # State that can be used inside Taichi scope\n    attract_state = tv.State({\n        'mass':   (0.,10.), #\u00a0name: (min, max)\n        'radius': (0.,1000.),\n    }, tv.o.species) # field shape is int -&gt; (int, int)\n\n    # Sardine @swim function running at control rate\n    @swim\n    def control(p=4, i=0):\n        attract_state.field[0,0].mass = P('1 1.2', i)\n        attract_state.field[0,0].radius = P('1900 100', i)\n        again(control, p=1/2, i=i+1)\n\n    # Sardine @swim function running at render rate\n    @swim\n    def render(p=0.5, i=0):\n        tv.v.move(tv.p)\n        attract_kernel(tv, \n            [tv.x/2, tv.y/2], \n            attract_state.field[0,0].mass, \n            attract_state.field[0,0].radius)\n        tv.show(tv.p) #\u00a0used instead of @tv.render\n        again(render, p=1/64, i=i+1)\n</code></pre> <p>Note that Sardine is not installed by T\u00f6lvera, and needs to be installed separately.</p>"},{"location":"examples/#interactive-machine-learning","title":"Interactive machine learning","text":""},{"location":"reference/tolvera/__init__/","title":"init","text":""},{"location":"reference/tolvera/__init__/#tolvera.Tolvera","title":"<code>Tolvera</code>","text":"<p>T\u00f6lvera class which contains all T\u00f6lvera components; Particles, Species, Vera, and Pixels. Multiple T\u00f6lvera instances share the same T\u00f6lveraContext.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>class Tolvera:\n    \"\"\"\n    T\u00f6lvera class which contains all T\u00f6lvera components;\n    Particles, Species, Vera, and Pixels.\n    Multiple T\u00f6lvera instances share the same T\u00f6lveraContext.\n    \"\"\"\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initialize and setup T\u00f6lvera with given keyword arguments.\n\n        Args:\n            **kwargs: Keyword arguments for setup and initialization.\n        \"\"\"\n        self.kwargs = kwargs\n        self.name = kwargs.get('name', 'T\u00f6lvera')\n        self.name_clean = clean_name(self.name)\n        if 'context' not in kwargs:\n            self.init_context(**kwargs)\n        else:\n            self.share_context(kwargs['context'])\n        self.setup(**kwargs)\n        print(f\"[{self.name}] Initialization and setup complete.\")\n    def init_context(self, **kwargs):\n        context = TolveraContext(**kwargs)\n        self.share_context(context)\n    def share_context(self, context):\n        names = context.get_tolvera_names()\n        if len(names) == 0:\n            print(f\"[{self.name}] Sharing context '{context.name}'.\")\n        else:\n            print(f\"[{self.name}] Sharing context '{context.name}' with {context.get_tolvera_names()}.\")\n        self.ctx = context\n        self.x       = context.x\n        self.y       = context.y\n        self.ti      = context.ti\n        self.canvas  = context.canvas\n        self.osc     = context.osc\n        self.iml     = context.iml\n        self.render  = context.render\n        self.cleanup = context.cleanup\n        self.cv      = context.cv\n    def setup(self, **kwargs):\n        \"\"\"\n        Setup T\u00f6lvera with given keyword arguments.\n        This can be called multiple throughout the lifetime of T\u00f6lvera.\n\n        Args:\n            **kwargs: Keyword arguments for setup.\n        \"\"\"\n        self.particles = kwargs.get('particles', 1024)\n        self.species   = kwargs.get('species', 4)\n        self.pn = self.particles\n        self.sn = self.species\n        self.p_per_s   = self.particles // self.species\n        self.substep   = kwargs.get('substep', 1)\n        self.evaporate = kwargs.get('evaporate', 0.95)\n        self.s = StateDict(self)\n        self.px = Pixels(self, **kwargs)\n        self._species = Species(self, **kwargs)\n        # self.p = Particles(self, self.s, **kwargs)\n        self.p = Particles(self, **kwargs)\n        self.v = Vera(self, **kwargs)\n        # TODO: Useful?\n        # self.v = dotdict({\n        #     'move':  Move(self),\n        #     'flock': Flock(self),\n        #     'slime': Slime(self),\n        #     'rd':    ReactionDiffusion(self),\n        # })\n        if self.osc is not False: self.add_to_osc_map()\n        self.ctx.add_tolvera(self)\n        print(f\"[{self.name}] Setup complete.\")\n    def randomise(self):\n        \"\"\"\n        Randomize particles, species, and Vera.\n        \"\"\"\n        self.p.randomise()\n        self.s.species.randomise()\n        self.v.randomise()\n    def reset(self, **kwargs):\n        \"\"\"\n        Reset T\u00f6lvera with given keyword arguments.\n        This will call setup() with given keyword arguments, but not init().\n\n        Args:\n            **kwargs: Keyword arguments for reset.\n        \"\"\"\n        print(f\"[{self.name}] Resetting self with kwargs={kwargs}...\")\n        if kwargs is not None:\n            self.kwargs = kwargs\n        self.setup()\n    def add_to_osc_map(self):\n        \"\"\"\n        Add top-level T\u00f6lvera functions to OSC map.\n        \"\"\"\n        setter_name = f\"{self.name_clean}_set\"\n        getter_name = f\"{self.name_clean}_get\"\n        self.osc.map.receive_args_inline(setter_name+'_randomise', self.randomise)\n        # self.osc.map.receive_args_inline(setter_name+'_reset', self.reset) # TODO: kwargs?\n        self.osc.map.receive_args_inline(setter_name+'_particles_randomise', self.p._randomise) # TODO: move inside Particles\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialize and setup T\u00f6lvera with given keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for setup and initialization.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    Initialize and setup T\u00f6lvera with given keyword arguments.\n\n    Args:\n        **kwargs: Keyword arguments for setup and initialization.\n    \"\"\"\n    self.kwargs = kwargs\n    self.name = kwargs.get('name', 'T\u00f6lvera')\n    self.name_clean = clean_name(self.name)\n    if 'context' not in kwargs:\n        self.init_context(**kwargs)\n    else:\n        self.share_context(kwargs['context'])\n    self.setup(**kwargs)\n    print(f\"[{self.name}] Initialization and setup complete.\")\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.add_to_osc_map","title":"<code>add_to_osc_map()</code>","text":"<p>Add top-level T\u00f6lvera functions to OSC map.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def add_to_osc_map(self):\n    \"\"\"\n    Add top-level T\u00f6lvera functions to OSC map.\n    \"\"\"\n    setter_name = f\"{self.name_clean}_set\"\n    getter_name = f\"{self.name_clean}_get\"\n    self.osc.map.receive_args_inline(setter_name+'_randomise', self.randomise)\n    # self.osc.map.receive_args_inline(setter_name+'_reset', self.reset) # TODO: kwargs?\n    self.osc.map.receive_args_inline(setter_name+'_particles_randomise', self.p._randomise) # TODO: move inside Particles\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.randomise","title":"<code>randomise()</code>","text":"<p>Randomize particles, species, and Vera.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def randomise(self):\n    \"\"\"\n    Randomize particles, species, and Vera.\n    \"\"\"\n    self.p.randomise()\n    self.s.species.randomise()\n    self.v.randomise()\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.reset","title":"<code>reset(**kwargs)</code>","text":"<p>Reset T\u00f6lvera with given keyword arguments. This will call setup() with given keyword arguments, but not init().</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for reset.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def reset(self, **kwargs):\n    \"\"\"\n    Reset T\u00f6lvera with given keyword arguments.\n    This will call setup() with given keyword arguments, but not init().\n\n    Args:\n        **kwargs: Keyword arguments for reset.\n    \"\"\"\n    print(f\"[{self.name}] Resetting self with kwargs={kwargs}...\")\n    if kwargs is not None:\n        self.kwargs = kwargs\n    self.setup()\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.setup","title":"<code>setup(**kwargs)</code>","text":"<p>Setup T\u00f6lvera with given keyword arguments. This can be called multiple throughout the lifetime of T\u00f6lvera.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for setup.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def setup(self, **kwargs):\n    \"\"\"\n    Setup T\u00f6lvera with given keyword arguments.\n    This can be called multiple throughout the lifetime of T\u00f6lvera.\n\n    Args:\n        **kwargs: Keyword arguments for setup.\n    \"\"\"\n    self.particles = kwargs.get('particles', 1024)\n    self.species   = kwargs.get('species', 4)\n    self.pn = self.particles\n    self.sn = self.species\n    self.p_per_s   = self.particles // self.species\n    self.substep   = kwargs.get('substep', 1)\n    self.evaporate = kwargs.get('evaporate', 0.95)\n    self.s = StateDict(self)\n    self.px = Pixels(self, **kwargs)\n    self._species = Species(self, **kwargs)\n    # self.p = Particles(self, self.s, **kwargs)\n    self.p = Particles(self, **kwargs)\n    self.v = Vera(self, **kwargs)\n    # TODO: Useful?\n    # self.v = dotdict({\n    #     'move':  Move(self),\n    #     'flock': Flock(self),\n    #     'slime': Slime(self),\n    #     'rd':    ReactionDiffusion(self),\n    # })\n    if self.osc is not False: self.add_to_osc_map()\n    self.ctx.add_tolvera(self)\n    print(f\"[{self.name}] Setup complete.\")\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext","title":"<code>TolveraContext</code>","text":"<p>Context for sharing between multiple T\u00f6lvera instances. Context includes Taichi, OSC, IML and CV. All T\u00f6lvera instances share the same context and are added to a dict.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>class TolveraContext:\n    \"\"\"\n    Context for sharing between multiple T\u00f6lvera instances.\n    Context includes Taichi, OSC, IML and CV.\n    All T\u00f6lvera instances share the same context and are added to a dict.\n    \"\"\"\n    def __init__(self, **kwargs) -&gt; None:\n        self.kwargs = kwargs\n        self.init(**kwargs)\n    def init(self, **kwargs):\n        \"\"\"\n        Initialize wrapped external packages with given keyword arguments.\n        This only happens once when T\u00f6lvera is first initialized.\n\n        Args:\n            **kwargs: Keyword arguments for component initialization.\n        \"\"\"\n        self.name = 'T\u00f6lvera Context'\n        self.name_clean = clean_name(self.name)\n        print(f\"[{self.name}] Initializing context...\")\n        self.i = 0\n        self.x = kwargs.get('x', 1920)\n        self.y = kwargs.get('y', 1080)\n        self.ti = Taichi(self, **kwargs)\n        self.canvas = Pixels(self, **kwargs)\n        self.osc = kwargs.get('osc', False)\n        self.iml = kwargs.get('iml', False)\n        self.cv  = kwargs.get('cv', False)\n        if self.osc:\n            self.osc = OSC(self, **kwargs)\n        if self.iml:\n            self.iml = IML(self, **kwargs)\n        if self.cv:\n            self.cv = CV(self, **kwargs)\n        self._cleanup_fns = []\n        self.tolveras = {}\n        print(f\"[{self.name}] Context initialization complete.\")\n    def run(self, f=None, **kwargs):\n        \"\"\"\n        Run T\u00f6lvera with given render function and keyword arguments.\n        This function will run inside a locked thread until KeyboardInterrupt/exit.\n        It runs the render function, updates the OSC map (if enabled), and shows the pixels.\n\n        Args:\n            f: Function to run.\n            **kwargs: Keyword arguments for function.\n        \"\"\"\n        print(f\"[{self.name}] Running with render function {f.__name__}...\")\n        while self.ti.window.running:\n            with _lock:\n                if f is not None: \n                    self.canvas = f(**kwargs)\n                if self.osc is not False: \n                    self.osc.map()\n                self.ti.show(self.canvas)\n                self.i += 1\n    def stop(self):\n        \"\"\"\n        Run cleanup functions and exit.\n        \"\"\"\n        print(f\"\\n[{self.name}] Stopping {self.name}...\")\n        for f in self._cleanup_fns: \n            print(f\"\\n[{self.name}] Running cleanup function {f.__name__}...\")\n            f()\n        print(f\"\\n[{self.name}] Exiting {self.name}...\")\n        exit(0)\n    def render(self, f=None, **kwargs):\n        \"\"\"Render T\u00f6lvera with given function and keyword arguments.\n\n        Args:\n            f (function, optional): Function to run. Defaults to None.\n        \"\"\"\n        try: self.run(f, **kwargs)\n        except KeyboardInterrupt: self.stop()\n    def cleanup(self, f=None):\n        \"\"\"\n        Decorator for cleanup functions based on iipyper.\n        Make functions run on KeyBoardInterrupt (before exit).\n        Cleanup functions must be defined before render is called!\n\n        Args:\n            f: Function to cleanup.\n\n        Returns:\n            Decorator function if f is None, else decorated function.\n        \"\"\"\n        print(f\"\\n[{self.name}] Adding cleanup function {f.__name__}...\")\n        def decorator(f):\n            self._cleanup_fns.append(f)\n            return f\n        if f is None: # return a decorator\n            return decorator\n        else: #bare decorator case; return decorated function\n            return decorator(f)\n    def add_tolvera(self, tolvera):\n        \"\"\"\n        Add T\u00f6lvera to context.\n\n        Args:\n            tolvera (Tolvera): T\u00f6lvera to add.\n        \"\"\"\n        assert isinstance(tolvera, Tolvera), f\"tolvera must be of type Tolvera, not {type(tolvera)}.\"\n        print(f\"[{self.name}] Adding tolvera='{tolvera.name}' to context.\")\n        self.tolveras[tolvera.name] = tolvera\n    def get_tolvera_by_name(self, name):\n        \"\"\"\n        Get T\u00f6lvera by name.\n\n        Args:\n            name (str): Name of T\u00f6lvera to get.\n\n        Returns:\n            T\u00f6lvera: T\u00f6lvera with given name.\n        \"\"\"\n        return self.tolveras[name]\n    def get_tolvera_names(self):\n        \"\"\"\n        Get names of all T\u00f6lveras in context.\n\n        Returns:\n            list: List of T\u00f6lvera names.\n        \"\"\"\n        return list(self.tolveras.keys())\n    def delete_tolvera(self, name):\n        \"\"\"\n        Delete T\u00f6lvera by name.\n\n        Args:\n            name (str): Name of T\u00f6lvera to delete.\n        \"\"\"\n        print(f\"[{self.name}] Deleting tolvera='{name}' from context.\")\n        del self.tolveras[name]\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.add_tolvera","title":"<code>add_tolvera(tolvera)</code>","text":"<p>Add T\u00f6lvera to context.</p> <p>Parameters:</p> Name Type Description Default <code>tolvera</code> <code>Tolvera</code> <p>T\u00f6lvera to add.</p> required Source code in <code>src/tolvera/__init__.py</code> <pre><code>def add_tolvera(self, tolvera):\n    \"\"\"\n    Add T\u00f6lvera to context.\n\n    Args:\n        tolvera (Tolvera): T\u00f6lvera to add.\n    \"\"\"\n    assert isinstance(tolvera, Tolvera), f\"tolvera must be of type Tolvera, not {type(tolvera)}.\"\n    print(f\"[{self.name}] Adding tolvera='{tolvera.name}' to context.\")\n    self.tolveras[tolvera.name] = tolvera\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.cleanup","title":"<code>cleanup(f=None)</code>","text":"<p>Decorator for cleanup functions based on iipyper. Make functions run on KeyBoardInterrupt (before exit). Cleanup functions must be defined before render is called!</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>Function to cleanup.</p> <code>None</code> <p>Returns:</p> Type Description <p>Decorator function if f is None, else decorated function.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def cleanup(self, f=None):\n    \"\"\"\n    Decorator for cleanup functions based on iipyper.\n    Make functions run on KeyBoardInterrupt (before exit).\n    Cleanup functions must be defined before render is called!\n\n    Args:\n        f: Function to cleanup.\n\n    Returns:\n        Decorator function if f is None, else decorated function.\n    \"\"\"\n    print(f\"\\n[{self.name}] Adding cleanup function {f.__name__}...\")\n    def decorator(f):\n        self._cleanup_fns.append(f)\n        return f\n    if f is None: # return a decorator\n        return decorator\n    else: #bare decorator case; return decorated function\n        return decorator(f)\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.delete_tolvera","title":"<code>delete_tolvera(name)</code>","text":"<p>Delete T\u00f6lvera by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of T\u00f6lvera to delete.</p> required Source code in <code>src/tolvera/__init__.py</code> <pre><code>def delete_tolvera(self, name):\n    \"\"\"\n    Delete T\u00f6lvera by name.\n\n    Args:\n        name (str): Name of T\u00f6lvera to delete.\n    \"\"\"\n    print(f\"[{self.name}] Deleting tolvera='{name}' from context.\")\n    del self.tolveras[name]\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.get_tolvera_by_name","title":"<code>get_tolvera_by_name(name)</code>","text":"<p>Get T\u00f6lvera by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of T\u00f6lvera to get.</p> required <p>Returns:</p> Name Type Description <code>T\u00f6lvera</code> <p>T\u00f6lvera with given name.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def get_tolvera_by_name(self, name):\n    \"\"\"\n    Get T\u00f6lvera by name.\n\n    Args:\n        name (str): Name of T\u00f6lvera to get.\n\n    Returns:\n        T\u00f6lvera: T\u00f6lvera with given name.\n    \"\"\"\n    return self.tolveras[name]\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.get_tolvera_names","title":"<code>get_tolvera_names()</code>","text":"<p>Get names of all T\u00f6lveras in context.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of T\u00f6lvera names.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def get_tolvera_names(self):\n    \"\"\"\n    Get names of all T\u00f6lveras in context.\n\n    Returns:\n        list: List of T\u00f6lvera names.\n    \"\"\"\n    return list(self.tolveras.keys())\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.init","title":"<code>init(**kwargs)</code>","text":"<p>Initialize wrapped external packages with given keyword arguments. This only happens once when T\u00f6lvera is first initialized.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for component initialization.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def init(self, **kwargs):\n    \"\"\"\n    Initialize wrapped external packages with given keyword arguments.\n    This only happens once when T\u00f6lvera is first initialized.\n\n    Args:\n        **kwargs: Keyword arguments for component initialization.\n    \"\"\"\n    self.name = 'T\u00f6lvera Context'\n    self.name_clean = clean_name(self.name)\n    print(f\"[{self.name}] Initializing context...\")\n    self.i = 0\n    self.x = kwargs.get('x', 1920)\n    self.y = kwargs.get('y', 1080)\n    self.ti = Taichi(self, **kwargs)\n    self.canvas = Pixels(self, **kwargs)\n    self.osc = kwargs.get('osc', False)\n    self.iml = kwargs.get('iml', False)\n    self.cv  = kwargs.get('cv', False)\n    if self.osc:\n        self.osc = OSC(self, **kwargs)\n    if self.iml:\n        self.iml = IML(self, **kwargs)\n    if self.cv:\n        self.cv = CV(self, **kwargs)\n    self._cleanup_fns = []\n    self.tolveras = {}\n    print(f\"[{self.name}] Context initialization complete.\")\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.render","title":"<code>render(f=None, **kwargs)</code>","text":"<p>Render T\u00f6lvera with given function and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>function</code> <p>Function to run. Defaults to None.</p> <code>None</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def render(self, f=None, **kwargs):\n    \"\"\"Render T\u00f6lvera with given function and keyword arguments.\n\n    Args:\n        f (function, optional): Function to run. Defaults to None.\n    \"\"\"\n    try: self.run(f, **kwargs)\n    except KeyboardInterrupt: self.stop()\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.run","title":"<code>run(f=None, **kwargs)</code>","text":"<p>Run T\u00f6lvera with given render function and keyword arguments. This function will run inside a locked thread until KeyboardInterrupt/exit. It runs the render function, updates the OSC map (if enabled), and shows the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>Function to run.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments for function.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def run(self, f=None, **kwargs):\n    \"\"\"\n    Run T\u00f6lvera with given render function and keyword arguments.\n    This function will run inside a locked thread until KeyboardInterrupt/exit.\n    It runs the render function, updates the OSC map (if enabled), and shows the pixels.\n\n    Args:\n        f: Function to run.\n        **kwargs: Keyword arguments for function.\n    \"\"\"\n    print(f\"[{self.name}] Running with render function {f.__name__}...\")\n    while self.ti.window.running:\n        with _lock:\n            if f is not None: \n                self.canvas = f(**kwargs)\n            if self.osc is not False: \n                self.osc.map()\n            self.ti.show(self.canvas)\n            self.i += 1\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.TolveraContext.stop","title":"<code>stop()</code>","text":"<p>Run cleanup functions and exit.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Run cleanup functions and exit.\n    \"\"\"\n    print(f\"\\n[{self.name}] Stopping {self.name}...\")\n    for f in self._cleanup_fns: \n        print(f\"\\n[{self.name}] Running cleanup function {f.__name__}...\")\n        f()\n    print(f\"\\n[{self.name}] Exiting {self.name}...\")\n    exit(0)\n</code></pre>"},{"location":"reference/tolvera/_iml/","title":"iml","text":""},{"location":"reference/tolvera/_iml/#tolvera._iml.IMLFuncToFunc","title":"<code>IMLFuncToFunc</code>","text":"<p>             Bases: <code>IML</code></p> <p>IML function to function mapping</p> Source code in <code>src/tolvera/_iml.py</code> <pre><code>class IMLFuncToFunc(iiIML):\n    \"\"\"IML function to function mapping\"\"\"\n    def __init__(self, context, **kwargs):\n        super().__init__(**kwargs)\n        self.ctx = context\n</code></pre>"},{"location":"reference/tolvera/_iml/#tolvera._iml.IMLFuncToOSC","title":"<code>IMLFuncToOSC</code>","text":"<p>             Bases: <code>IML</code></p> <p>IML function to OSC mapping</p> Source code in <code>src/tolvera/_iml.py</code> <pre><code>class IMLFuncToOSC(iiIML):\n    \"\"\"IML function to OSC mapping\"\"\"\n    def __init__(self, context, **kwargs):\n        super().__init__(**kwargs)\n        self.ctx = context\n</code></pre>"},{"location":"reference/tolvera/_iml/#tolvera._iml.IMLOSCToFunc","title":"<code>IMLOSCToFunc</code>","text":"<p>             Bases: <code>IML</code></p> <p>IML OSC to function mapping</p> Source code in <code>src/tolvera/_iml.py</code> <pre><code>class IMLOSCToFunc(iiIML):\n    \"\"\"IML OSC to function mapping\"\"\"\n    def __init__(self, context, **kwargs):\n        super().__init__(**kwargs)\n        self.ctx = context\n</code></pre>"},{"location":"reference/tolvera/_iml/#tolvera._iml.IMLOSCToOSC","title":"<code>IMLOSCToOSC</code>","text":"<p>             Bases: <code>IML</code></p> <p>IML OSC to OSC mapping</p> Source code in <code>src/tolvera/_iml.py</code> <pre><code>class IMLOSCToOSC(iiIML):\n    \"\"\"IML OSC to OSC mapping\"\"\"\n    def __init__(self, context, **kwargs):\n        super().__init__(**kwargs)\n        self.ctx = context\n</code></pre>"},{"location":"reference/tolvera/_osc/","title":"osc","text":"<p>TODO: subclass OSC? or wrap common funcs? TODO: allow passing in external iipyper.osc instance?</p>"},{"location":"reference/tolvera/_state/","title":"state","text":"<p>Current implementation: - State is ti.f32 only - Shape is int -&gt; (int, int)     - 1D: use 1st col (i,0)     - 2D: use (i,j)</p> state <p><code>state: dict[str, tuple[DataType, Any, Any]]</code>     Any, Any only needed if state will be controlled by user (species, not particles) 1 DataType per State, or multiple? DataType support?     ti.i32     ti.f32     ti.math.vec2     ti.math.vec3     ti.math.vec4 save/load? serialise/deserialise</p> <p>TODO: shape     1D, 2D, ND versions of state?     update shape when Tolvera is re-initialised?     <code>shape: int | tuple[int]</code> TODO: randomise     randomise_state_idx|row|col|all     randomise_attr_idx|row|col|all     how to randomise arbitrary shapes with ti.ndrange(*shape), field[...]? TODO: setters:     indexing with variable shape?     self.len with variable shape?     finish writing test TODO: OSCMap getters     state analysers -&gt; OSC senders     iipyper osc returns? TODO: tidy up <code>osc_receive_randomise</code>, move into iipyper.map.py? TODO: IML: add default mapping? TODO: Sardine: pattern utils? TODO: @ti.func struct methods - can these be monkey patched?     if not add to constructor as a dict     use case would be Particles.Particle</p>"},{"location":"reference/tolvera/_state/#tolvera._state.State","title":"<code>State</code>","text":"<p>Args     tolvera: tolvera instance     state: a dictionary of attributes in <code>'attr': (min, max)</code> format     shape: the shape of the state field (currently only <code>int-&gt;(int,int)</code> supported)     osc: one/both of <code>('get', 'set')</code> to create OSC getters and/or setters     name: becomes the OSC path prefix for the state     randomise: randomise the state on initialisation</p> Source code in <code>src/tolvera/_state.py</code> <pre><code>@ti.data_oriented\nclass State:\n    '''\n    Args\n        tolvera: tolvera instance\n        state: a dictionary of attributes in `'attr': (min, max)` format\n        shape: the shape of the state field (currently only `int-&gt;(int,int)` supported)\n        osc: one/both of `('get', 'set')` to create OSC getters and/or setters\n        name: becomes the OSC path prefix for the state\n        randomise: randomise the state on initialisation\n    '''\n    def __init__(self, \n                 tolvera,\n                 state: dict[str, tuple[ti.f32, ti.f32]], # tuple[DataType, Any, Any]\n                 shape: int,# | tuple[int], \n                 osc: tuple = None,\n                 name: str = 'state',\n                 randomise: bool = True):\n        self.tv = tolvera\n        self.dict = state\n        self.shape = shape\n        # self.struct = ti.types.struct(**{k: v[0] for k,v in self.dict.items()})\n        # self.field = self.struct.field(shape=self.shape)\n        self.struct = ti.types.struct(**{k: ti.f32 for k,v in self.dict.items()})\n        self.field = self.struct.field(shape=(self.shape, self.shape))\n        self.len_state_idx = len(state)\n        self.len_state_row = self.len_state_idx * self.shape#[0]\n        self.len_state_col = self.len_state_idx * self.shape#[1]\n        self.len_state_all = self.len_state_row * self.shape#[1] self.len_state_col\n        self.len_attr_row = self.shape#[0]\n        self.len_attr_col = self.shape#[1]\n        self.len_attr_all = self.shape * self.shape\n        self.osc = True if osc is not None else False\n        self.osc_get = 'get' in osc if osc is not None else False\n        self.osc_set = 'set' in osc if osc is not None else False\n        self.name = name\n        self.init(randomise)\n\n    def init(self, randomise: bool = False):\n        if randomise: self.randomise()\n        if self.tv.osc is not False and self.osc:\n            self.osc = self.tv.osc\n            self.add_to_osc_map()\n\n    def get(self, index: tuple, attribute: str):\n        try:\n            return self.field[index][attribute]\n        except:\n            print(f\"[tolvera.state] {self.name} has no {attribute} in {self.dict}\")\n\n    def osc_getter(self, i: int, j: int, attribute: str):\n        ret = self.get((i,j), attribute)\n        if ret is not None:\n            route = self.osc.map.pascal_to_path(self.getter_name)#+'/'+attribute\n            self.osc.host.return_to_sender_by_name((route, attribute,ret), self.osc.client_name)\n        return ret\n\n    @ti.kernel\n    def randomise(self):\n        for i, j in ti.ndrange(self.shape, self.shape):\n            # TODO: if DataType = ...\n            state = {k: v[0] + (v[1] - v[0]) * ti.random(ti.f32)\n                     for k, v in self.dict.items()}\n            self.field[i,j] = self.struct(**state)\n        # for i in ti.ndrange(**self.shape):\n        #     state = ti.random()\n        #     self.field[i] = self.struct()\n\n    def _randomise(self):\n        '''Python scope wrapper for OSCMap'''\n        self.randomise()\n\n    def set_state_idx_from_args(self, index: tuple, *state: Any):\n        self.field[index] = self.struct(*state)\n\n    def set_state_idx_from_kwargs(self, index: tuple, **state: Any):\n        for k, v in self.dict.items():\n            if k not in state:\n                state[k] = self.field[index][k]\n        self.field[index] = self.struct(**state)\n\n    def set_state_idx_from_list(self, index: tuple, state: list):\n        self.set_state_idx_from_args(index, *state)\n\n    # def set_state_idx_from_ndarray(self, index: tuple, state: np.ndarray):\n    #     self.set_state_idx_from_args(index, *state.tolist())\n\n    def set_state_row_from_list(self, i: int|tuple[int], state: list):\n        '''\n        Args:\n            state = [i0r0-i0rN, i1r0-i1rN, ...]\n        '''\n        # assert len(state) == self.len_state_row, f\"len(state) != len_ndarr_shape ({len(state)} != {self.len_state_row})\"\n        i = i[0] if isinstance(i, tuple) else i\n        idx_len = self.len_state_idx\n        for j in range(self.shape):\n            s = [state[j*idx_len+r] for r in range(idx_len)]\n            struct = self.struct(*s)\n            self.field[i,j] = self.struct(*s)\n\n    def set_state_col_from_list(self, j: int|tuple[int], state: list):\n        '''\n        Args:\n            state = [i0r0-i0rN, i1r0-i1rN, ...]\n        '''\n        # assert len(state) == self.len_ndarr_shape, f\"len(state) != len_ndarr_shape ({len(state)} != {self.len_ndarr_shape})\"\n        j = j[0] if isinstance(j, tuple) else j\n        idx_len = self.len_state_idx\n        for i in range(self.shape):\n            s = [state[i*idx_len+r] for r in range(idx_len)]\n            self.field[i,j] = self.struct(*s)\n\n    def set_state_all_from_list(self, state: list):\n        '''\n        Flat list of state for each shape pair\n\n        Args:\n            state = [i0j0r0-i0j0rN, i0j1r0-i0j1rN, i1j1r0-i1jrN, ...]\n        '''\n        # assert len(state) == self.len_ndarr_all, f\"len(state) != len_ndarr_all ({len(state)} != {self.len_ndarr_all})\"\n        idx_len = self.len_state_idx\n        for i, j in ti.ndrange(self.shape, self.shape):\n            s = [state[i*idx_len+j+r] for r in range(idx_len)]\n            self.field[i,j] = self.struct(*s)\n\n    def set_state_row_from_ndarray(self, i: ti.i32, state: ti.types.ndarray(dtype=ti.f32, ndim=2)):\n        '''\n        Args:\n            state: np.array((shape, state), dtype=np.float32)\n        '''\n        for j in range(self.shape):\n            self.field[i,j] = self.struct(*state[j])\n\n    def set_state_col_from_ndarray(self, j: ti.i32, state: ti.types.ndarray(dtype=ti.f32, ndim=2)):\n        '''\n        Args:\n            state: np.array((shape, state), dtype=np.float32)\n        '''\n        for i in range(self.shape):\n            self.field[i,j] = self.struct(*state[i])\n\n    def set_state_all_from_ndarray(self, state: ti.types.ndarray(dtype=ti.f32, ndim=3)):\n        '''\n        Should be @ti.kernel, but can't do `*state[i,j]`\n\n        Args:\n            state: np.array((shape, shape, state), dtype=np.float32)\n        '''\n        for i, j in ti.ndrange(state.shape[0], state.shape[0]):\n            self.field[i,j] = self.struct(*state[i,j])\n\n    def set_dim_from_ndarray(self, dim: ti.i32, state: ti.types.ndarray(dtype=ti.f32, ndim=2)):\n        raise NotImplementedError(\"set_dim_from_ndarray() not implemented\")\n\n    def set_dim_from_list(self, dim: ti.i32, state: list):\n        raise NotImplementedError(\"set_dim_from_list() not implemented\")\n\n    def set_attr_idx(self, index: tuple, attr: str, value: Any):\n        value = value[0] if isinstance(value, list) else value\n        self.field[index][attr] = value\n\n    def set_attr_row(self, i: int|tuple[int], attr: str, values: list):\n        i = i[0] if isinstance(i, tuple) else i\n        for j in range(self.shape):\n            self.field[i,j][attr] = values[i]\n\n    def set_attr_col(self, j: int|tuple[int], attr: str, values: list):\n        j = j[0] if isinstance(j, tuple) else j\n        for i in range(self.shape):\n            self.field[i,j][attr] = values[j]\n\n    def set_attr_all(self, attr: str, values: list):\n        for i, j in ti.ndrange(self.shape, self.shape):\n            self.field[i,j][attr] = values[i*self.shape+j]\n\n    def add_to_osc_map(self):\n        if self.osc_set:\n            self.setter_name = f\"{self.tv.name_clean}_set_{self.name}\"\n            self.add_osc_setters(self.setter_name)\n        if self.osc_get:\n            self.getter_name = f\"{self.tv.name_clean}_get_{self.name}\"\n            self.add_osc_getters(self.getter_name)\n\n    def add_osc_setters(self, name):\n        # randomise\n        self.osc.map.receive_args_inline(name+'_randomise', self._randomise)\n        # state\n        f = self.osc.map.receive_list_with_idx\n        f(f\"{name}_idx\", self.set_state_idx_from_list, 2, getattr(self,'len_state_idx'))\n        f(f\"{name}_row\", self.set_state_row_from_list, 1, getattr(self,'len_state_row'))\n        f(f\"{name}_col\", self.set_state_col_from_list, 1, getattr(self,'len_state_col'))\n        f(f\"{name}_all\", self.set_state_all_from_list, 0, getattr(self,'len_state_all'))\n        # state attributes\n        for k,v in self.dict.items():\n            f(f\"{name}_{k}_idx\", self.set_attr_idx, 2, 1, k)\n            f(f\"{name}_{k}_row\", self.set_attr_row, 1, getattr(self,'len_attr_row'), k)\n            f(f\"{name}_{k}_col\", self.set_attr_col, 1, getattr(self,'len_attr_col'), k)\n            f(f\"{name}_{k}_all\", self.set_attr_all, 0, getattr(self,'len_attr_all'), k)\n\n    def add_osc_getters(self, name):\n        for k,v in self.dict.items():\n            ranges = (int(v[0]), int(v[0]), int(v[1]))\n            kwargs = {'i': ranges, 'j': ranges, 'attr': (k,k,k)}\n            self.osc.map.receive_args_inline(f\"{name}\", self.osc_getter, **kwargs)\n\n    '''\n    def add_osc_streams(self, name):\n        add in broadcast mode\n        pass\n    '''\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n        if isinstance(args[0], tuple) and isinstance(args[1], str):\n            return self.get(*args)\n</code></pre>"},{"location":"reference/tolvera/_state/#tolvera._state.State.set_state_all_from_list","title":"<code>set_state_all_from_list(state)</code>","text":"<p>Flat list of state for each shape pair</p> Source code in <code>src/tolvera/_state.py</code> <pre><code>def set_state_all_from_list(self, state: list):\n    '''\n    Flat list of state for each shape pair\n\n    Args:\n        state = [i0j0r0-i0j0rN, i0j1r0-i0j1rN, i1j1r0-i1jrN, ...]\n    '''\n    # assert len(state) == self.len_ndarr_all, f\"len(state) != len_ndarr_all ({len(state)} != {self.len_ndarr_all})\"\n    idx_len = self.len_state_idx\n    for i, j in ti.ndrange(self.shape, self.shape):\n        s = [state[i*idx_len+j+r] for r in range(idx_len)]\n        self.field[i,j] = self.struct(*s)\n</code></pre>"},{"location":"reference/tolvera/_state/#tolvera._state.State.set_state_all_from_ndarray","title":"<code>set_state_all_from_ndarray(state)</code>","text":"<p>Should be @ti.kernel, but can't do <code>*state[i,j]</code></p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray(dtype=f32, ndim=3)</code> <p>np.array((shape, shape, state), dtype=np.float32)</p> required Source code in <code>src/tolvera/_state.py</code> <pre><code>def set_state_all_from_ndarray(self, state: ti.types.ndarray(dtype=ti.f32, ndim=3)):\n    '''\n    Should be @ti.kernel, but can't do `*state[i,j]`\n\n    Args:\n        state: np.array((shape, shape, state), dtype=np.float32)\n    '''\n    for i, j in ti.ndrange(state.shape[0], state.shape[0]):\n        self.field[i,j] = self.struct(*state[i,j])\n</code></pre>"},{"location":"reference/tolvera/_state/#tolvera._state.State.set_state_col_from_list","title":"<code>set_state_col_from_list(j, state)</code>","text":"Source code in <code>src/tolvera/_state.py</code> <pre><code>def set_state_col_from_list(self, j: int|tuple[int], state: list):\n    '''\n    Args:\n        state = [i0r0-i0rN, i1r0-i1rN, ...]\n    '''\n    # assert len(state) == self.len_ndarr_shape, f\"len(state) != len_ndarr_shape ({len(state)} != {self.len_ndarr_shape})\"\n    j = j[0] if isinstance(j, tuple) else j\n    idx_len = self.len_state_idx\n    for i in range(self.shape):\n        s = [state[i*idx_len+r] for r in range(idx_len)]\n        self.field[i,j] = self.struct(*s)\n</code></pre>"},{"location":"reference/tolvera/_state/#tolvera._state.State.set_state_col_from_ndarray","title":"<code>set_state_col_from_ndarray(j, state)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray(dtype=f32, ndim=2)</code> <p>np.array((shape, state), dtype=np.float32)</p> required Source code in <code>src/tolvera/_state.py</code> <pre><code>def set_state_col_from_ndarray(self, j: ti.i32, state: ti.types.ndarray(dtype=ti.f32, ndim=2)):\n    '''\n    Args:\n        state: np.array((shape, state), dtype=np.float32)\n    '''\n    for i in range(self.shape):\n        self.field[i,j] = self.struct(*state[i])\n</code></pre>"},{"location":"reference/tolvera/_state/#tolvera._state.State.set_state_row_from_list","title":"<code>set_state_row_from_list(i, state)</code>","text":"Source code in <code>src/tolvera/_state.py</code> <pre><code>def set_state_row_from_list(self, i: int|tuple[int], state: list):\n    '''\n    Args:\n        state = [i0r0-i0rN, i1r0-i1rN, ...]\n    '''\n    # assert len(state) == self.len_state_row, f\"len(state) != len_ndarr_shape ({len(state)} != {self.len_state_row})\"\n    i = i[0] if isinstance(i, tuple) else i\n    idx_len = self.len_state_idx\n    for j in range(self.shape):\n        s = [state[j*idx_len+r] for r in range(idx_len)]\n        struct = self.struct(*s)\n        self.field[i,j] = self.struct(*s)\n</code></pre>"},{"location":"reference/tolvera/_state/#tolvera._state.State.set_state_row_from_ndarray","title":"<code>set_state_row_from_ndarray(i, state)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>state</code> <code>ndarray(dtype=f32, ndim=2)</code> <p>np.array((shape, state), dtype=np.float32)</p> required Source code in <code>src/tolvera/_state.py</code> <pre><code>def set_state_row_from_ndarray(self, i: ti.i32, state: ti.types.ndarray(dtype=ti.f32, ndim=2)):\n    '''\n    Args:\n        state: np.array((shape, state), dtype=np.float32)\n    '''\n    for j in range(self.shape):\n        self.field[i,j] = self.struct(*state[j])\n</code></pre>"},{"location":"reference/tolvera/_taichi/","title":"taichi","text":""},{"location":"reference/tolvera/npndarray_dict/","title":"Npndarray dict","text":""},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict","title":"<code>NpNdarrayDict</code>","text":"<p>A class that encapsulates a dictionary of NumPy ndarrays, each associated with a specific data type and a defined min-max range.  It provides a structured and efficient way to manage and manipulate multidimensional arrays with constraints on their values. </p> <p>The class offers various methods to set and get values, rows, and columns for individual arrays or across the entire dictionary.  It also includes functionalities for randomizing array elements within their defined ranges and validating the integrity of the data structure. </p> <p>This class is particularly useful in scenarios where multiple related datasets need to be maintained and manipulated in a synchronized manner,  such as in scientific computing, data analysis, and machine learning applications where data consistency and integrity are crucial.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, Dict[str, Union[ndarray, Any]]]</code> <p>A dictionary where each key represents an attribute, </p> <code>shape</code> <code>Tuple[int, int]</code> <p>The shape of the ndarrays, which is consistent across all attributes.</p> Example <p>state = NpNdarrayDict({         'i':  (np.int32, 2, 10),         'f':  (np.float32, 0., 1.),         'v2': (np_vec2, 0., 1.),         'v3': (np_vec3, 0., 1.),         'v4': (np_vec4, 0., 1.),     }, (2,2)) state.set_value('i', (0, 0), 5) print(state.get_value('i', (0, 0))) 5</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>class NpNdarrayDict:\n    \"\"\"\n    A class that encapsulates a dictionary of NumPy ndarrays, each associated with a specific data type and a defined min-max range. \n    It provides a structured and efficient way to manage and manipulate multidimensional arrays with constraints on their values. \n\n    The class offers various methods to set and get values, rows, and columns for individual arrays or across the entire dictionary. \n    It also includes functionalities for randomizing array elements within their defined ranges and validating the integrity of the data structure. \n\n    This class is particularly useful in scenarios where multiple related datasets need to be maintained and manipulated in a synchronized manner, \n    such as in scientific computing, data analysis, and machine learning applications where data consistency and integrity are crucial.\n\n    Attributes:\n        data (Dict[str, Dict[str, Union[np.ndarray, Any]]]): A dictionary where each key represents an attribute, \n        and the value is another dictionary with keys 'array', 'min', and 'max', representing the ndarray, \n        its minimum value, and its maximum value, respectively.\n        shape (Tuple[int, int]): The shape of the ndarrays, which is consistent across all attributes.\n\n    Example:\n        &gt;&gt;&gt; state = NpNdarrayDict({\n                'i':  (np.int32, 2, 10),\n                'f':  (np.float32, 0., 1.),\n                'v2': (np_vec2, 0., 1.),\n                'v3': (np_vec3, 0., 1.),\n                'v4': (np_vec4, 0., 1.),\n            }, (2,2))\n        &gt;&gt;&gt; state.set_value('i', (0, 0), 5)\n        &gt;&gt;&gt; print(state.get_value('i', (0, 0)))\n        5\n    \"\"\"\n    def __init__(self, data_dict: dict[str, tuple[Any, Any, Any]], shape: tuple[int]):\n        \"\"\"\n        Initialize the State class.\n\n        Args:\n            data_dict: A dictionary where keys are attribute names and values are tuples\n                       of (dtype, min_value, max_value).\n            shape: The shape of the numpy arrays for each attribute.\n\n        \"\"\"\n        self.shape = shape\n        self.init(data_dict, shape)\n\n    def init(self, data_dict: dict[str, tuple[Any, Any, Any]], shape: tuple[int]) -&gt; None:\n        self.dict = {}\n        self.data = {}\n        for key, (dtype, min_val, max_val) in data_dict.items():\n            dshape = self.shape\n            length = 1\n            if isinstance(dtype, np.ndarray):\n                dshape = dshape + dtype.shape\n                length = dtype.shape[0]\n                dtype = np.float32\n            self.dict[key] = {\n                'dtype': dtype, \n                'min': min_val, \n                'max': max_val, \n                'length': length,\n                'shape': dshape\n            }\n            self.data[key] = np.zeros(dshape, dtype=dtype)\n\n    def set_value(self, key: str, index: tuple[int], value: Any) -&gt; None:\n        \"\"\"\n        Set a value at a specific index for a given attribute.\n\n        Args:\n            key: The attribute key.\n            index: The index at which to set the value.\n            value: The value to set.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n            ValueError: If the value is out of the specified range for the key.\n\n        \"\"\"\n        if key in self.data:\n            if self.dict[key]['min'] &lt;= value &lt;= self.dict[key]['max']:\n                self.data[key][index] = value\n            else:\n                raise ValueError(f\"Value {value} is out of range for key {key}\")\n        else:\n            raise KeyError(f\"Key {key} not found in state\")\n\n    def get_value(self, key: str, index: tuple[int]) -&gt; Any:\n        \"\"\"\n        Get a value at a specific index for a given attribute.\n\n        Args:\n            key: The attribute key.\n            index: The index from which to get the value.\n\n        Returns:\n            The value at the specified index for the given key.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n\n        \"\"\"\n        if key in self.data:\n            return self.data[key][index]\n        else:\n            raise KeyError(f\"Key {key} not found in state\")\n\n    def set_row(self, key: str, row_index: int, row_values: np.ndarray) -&gt; None:\n        \"\"\"\n        Set an entire row for the specified attribute.\n\n        Args:\n            key: The attribute key in the state dictionary.\n            row_index: The index of the row to be set.\n            row_values: A numpy array of values to set in the row.\n\n        Raises:\n            ValueError: If the row length is invalid or the key is not found.\n        \"\"\"\n        if key in self.data and len(row_values) == self.shape[1]:\n            self.data[key][row_index, :] = row_values\n        else:\n            raise ValueError(\"Invalid row length or key\")\n\n    def get_row(self, key: str, row_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get an entire row for the specified attribute.\n\n        Args:\n            key: The attribute key in the state dictionary.\n            row_index: The index of the row to be retrieved.\n\n        Returns:\n            A numpy array representing the row for the specified attribute.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n        \"\"\"\n        if key in self.data:\n            return self.data[key][row_index, :]\n        else:\n            raise KeyError(\"Key not found\")\n\n    def set_col(self, key: str, col_index: int, col_values: np.ndarray) -&gt; None:\n        \"\"\"\n        Set an entire column for the specified attribute.\n\n        Args:\n            key: The attribute key in the state dictionary.\n            col_index: The index of the column to be set.\n            col_values: A numpy array of values to set in the column.\n\n        Raises:\n            ValueError: If the column length is invalid or the key is not found.\n        \"\"\"\n        if key in self.data and len(col_values) == self.shape[0]:\n            self.data[key][:, col_index] = col_values\n        else:\n            raise ValueError(\"Invalid column length or key\")\n\n    def get_col(self, key: str, col_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get an entire column for the specified attribute.\n\n        Args:\n            key: The attribute key in the state dictionary.\n            col_index: The index of the column to be retrieved.\n\n        Returns:\n            A numpy array representing the column for the specified attribute.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n        \"\"\"\n        if key in self.data:\n            return self.data[key][:, col_index]\n        else:\n            raise KeyError(\"Key not found\")\n\n    def set_data(self, new_data: dict[str, np.ndarray]) -&gt; None:\n        \"\"\"\n        Set the data with a new data dictionary.\n\n        Args:\n            new_data: A dictionary representing the new data, where each key is an\n                    attribute and the value is a numpy array.\n\n        Raises:\n            ValueError: If the new data is invalid (e.g., wrong shape, type, or value range).\n        \"\"\"\n        if self.validate_new_state(new_data):\n            self.data = new_data\n        else:\n            raise ValueError(\"Invalid data\")\n\n    def get_data(self) -&gt; dict[str, np.ndarray]:\n        \"\"\"\n        Get the entire current data as a dictionary.\n\n        Returns:\n            A dictionary where each key is an attribute and the value is a numpy array.\n        \"\"\"\n        return self.data\n\n    def validate_new_state(self, new_state: dict[str, np.ndarray]) -&gt; bool:\n        \"\"\"\n        Validate a new state dictionary to ensure it conforms to the expected structure and constraints.\n\n        Args:\n            new_state: A dictionary representing the new state to be validated.\n\n        Returns:\n            True if the new state is valid, False otherwise.\n        \"\"\"\n        for key, array in new_state.items():\n            # Check if the key exists in the current state\n            if key not in self.data:\n                print(f\"Key {key} not found in current state\")\n                return False\n\n            # Check if the shape of the array matches\n            if array.shape != self.data[key].shape:\n                print(f\"Shape {array.shape} does not match expected shape {self.data[key].shape}\")\n                return False\n\n            # # Check if the data type of the array matches\n            # if array.dtype != self.data[key].dtype:\n            #     return False\n\n            # # Check if all values are within the specified range\n            # if not (self.data[key]['min'] &lt;= array).all() or not (array &lt;= self.data[key]['max']).all():\n            #     return False\n\n        return True\n\n    def set_row_for_attribute(self, key: str, row_index: int, row_values: np.ndarray) -&gt; None:\n        \"\"\"\n        Set an entire row for a specific attribute.\n\n        Args:\n            key: The attribute key.\n            row_index: The index of the row to set.\n            row_values: An array of values to set in the row.\n\n        Raises:\n            ValueError: If the row length is invalid or the key is not found.\n\n        \"\"\"\n        if key in self.data and len(row_values) == self.shape[1]:\n            self.data[key][row_index, :] = row_values\n        else:\n            raise ValueError(\"Invalid row length or key\")\n\n    def get_row_for_attribute(self, key: str, row_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get an entire row for a specific attribute.\n\n        Args:\n            key: The attribute key.\n            row_index: The index of the row to get.\n\n        Returns:\n            An array representing the row for the given key.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n\n        \"\"\"\n        if key in self.data:\n            return self.data[key][row_index, :]\n        else:\n            raise KeyError(\"Key not found\")\n\n    def set_col_for_attribute(self, key: str, col_index: int, col_values: np.ndarray) -&gt; None:\n        \"\"\"\n        Set an entire column for a specific attribute.\n\n        Args:\n            key: The attribute key.\n            col_index: The index of the column to set.\n            col_values: An array of values to set in the column.\n\n        Raises:\n            ValueError: If the column length is invalid or the key is not found.\n\n        \"\"\"\n        if key in self.data and len(col_values) == self.shape[0]:\n            self.data[key][:, col_index] = col_values\n        else:\n            raise ValueError(\"Invalid column length or key\")\n\n    def get_col_for_attribute(self, key: str, col_index: int) -&gt; np.ndarray:\n        \"\"\"\n        Get an entire column for a specific attribute.\n\n        Args:\n            key: The attribute key.\n            col_index: The index of the column to get.\n\n        Returns:\n            An array representing the column for the given key.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n\n        \"\"\"\n        if key in self.data:\n            return self.data[key][:, col_index]\n        else:\n            raise KeyError(\"Key not found\")\n\n    def randomise(self) -&gt; None:\n        \"\"\"\n        Randomize the entire state dictionary based on the datatype, minimum,\n        and maximum values for each attribute.\n        \"\"\"\n        for key in self.data:\n            data_type = self.dict[key]['dtype']\n            min_val   = self.dict[key]['min']\n            max_val   = self.dict[key]['max']\n            shape     = self.dict[key]['shape']\n\n            if np.issubdtype(data_type, np.integer):\n                self.data[key] = np.random.randint(min_val, max_val + 1, size=shape, dtype=data_type)\n            elif np.issubdtype(data_type, np.floating):\n                self.data[key] = np.random.uniform(min_val, max_val, size=shape).astype(data_type)\n            # Add more conditions here if you have other data types\n\n    def randomise_index(self, index: tuple[int, int]) -&gt; None:\n        \"\"\"\n        Randomize the values at a specific index for all attributes.\n\n        Args:\n            index: The index to randomize (row_index, column_index).\n        \"\"\"\n        for key in self.data:\n            data_type = self.dict[key]['dtype']\n            min_val = self.dict[key]['min']\n            max_val = self.dict[key]['max']\n\n            if np.issubdtype(data_type, np.integer):\n                self.data[key][index] = np.random.randint(min_val, max_val + 1, dtype=data_type)\n            elif np.issubdtype(data_type, np.floating):\n                self.data[key][index] = np.random.uniform(min_val, max_val).astype(data_type)\n\n    def randomise_row(self, row_index: int) -&gt; None:\n        \"\"\"\n        Randomize the values in a specific row for all attributes.\n\n        Args:\n            row_index: The index of the row to randomize.\n        \"\"\"\n        for key in self.data:\n            data_type = self.dict[key]['dtype']\n            min_val = self.dict[key]['min']\n            max_val = self.dict[key]['max']\n\n            if np.issubdtype(data_type, np.integer):\n                self.data[key][row_index, :] = np.random.randint(min_val, max_val + 1, size=self.shape[1], dtype=data_type)\n            elif np.issubdtype(data_type, np.floating):\n                self.data[key][row_index, :] = np.random.uniform(min_val, max_val, size=self.shape[1]).astype(data_type)\n\n    def randomise_col(self, col_index: int) -&gt; None:\n        \"\"\"\n        Randomize the values in a specific column for all attributes.\n\n        Args:\n            col_index: The index of the column to randomize.\n        \"\"\"\n        for key in self.data:\n            data_type = self.dict[key]['dtype']\n            min_val = self.dict[key]['min']\n            max_val = self.dict[key]['max']\n\n            if np.issubdtype(data_type, np.integer):\n                self.data[key][:, col_index] = np.random.randint(min_val, max_val + 1, size=self.shape[0], dtype=data_type)\n            elif np.issubdtype(data_type, np.floating):\n                self.data[key][:, col_index] = np.random.uniform(min_val, max_val, size=self.shape[0]).astype(data_type)\n\n    def randomise_attribute_index(self, key: str, index: tuple[int, int]) -&gt; None:\n        \"\"\"\n        Randomize the value at a specific index for a given attribute.\n\n        Args:\n            key: The attribute key.\n            index: The index to randomize (row_index, column_index).\n\n        Raises:\n            KeyError: If the key is not found in the state.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found in state\")\n\n        data_type = self.dict[key]['dtype']\n        min_val = self.dict[key]['min']\n        max_val = self.dict[key]['max']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key][index] = np.random.randint(min_val, max_val + 1, dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key][index] = np.random.uniform(min_val, max_val).astype(data_type)\n\n    def randomise_attribute_row(self, key: str, row_index: int) -&gt; None:\n        \"\"\"\n        Randomize the values in a specific row for a given attribute.\n\n        Args:\n            key: The attribute key.\n            row_index: The index of the row to randomize.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found in state\")\n\n        data_type = self.dict[key]['dtype']\n        min_val = self.dict[key]['min']\n        max_val = self.dict[key]['max']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key][row_index, :] = np.random.randint(min_val, max_val + 1, size=self.shape[1], dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key][row_index, :] = np.random.uniform(min_val, max_val, size=self.shape[1]).astype(data_type)\n\n    def randomise_attribute_col(self, key: str, col_index: int) -&gt; None:\n        \"\"\"\n        Randomize the values in a specific column for a given attribute.\n\n        Args:\n            key: The attribute key.\n            col_index: The index of the column to randomize.\n\n        Raises:\n            KeyError: If the key is not found in the state.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found in state\")\n\n        data_type = self.dict[key]['dtype']\n        min_val = self.dict[key]['min']\n        max_val = self.dict[key]['max']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key][:, col_index] = np.random.randint(min_val, max_val + 1, size=self.shape[0], dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key][:, col_index] = np.random.uniform(min_val, max_val, size=self.shape[0]).astype(data_type)\n\n    def apply_function(self, key: str, func: Callable[[np.ndarray], np.ndarray]) -&gt; None:\n        \"\"\"\n        Apply a user-defined function to the array of a specified key.\n\n        Args:\n            key: The attribute key.\n            func: A function that takes a numpy array and returns a numpy array.\n\n        Raises:\n            KeyError: If the key is not found.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found\")\n\n        self.data[key] = func(self.data[key])\n\n    def elementwise_operation(self, key1: str, key2: str, op: Callable[[np.ndarray, np.ndarray], np.ndarray]) -&gt; None:\n        \"\"\"\n        Perform an element-wise operation between two arrays in the dictionary.\n\n        Args:\n            key1: The first attribute key.\n            key2: The second attribute key.\n            op: A function to perform element-wise operation.\n\n        Raises:\n            KeyError: If either key is not found.\n        \"\"\"\n        if key1 not in self.data or key2 not in self.data:\n            raise KeyError(f\"One of the keys {key1}, {key2} not found\")\n\n        array1 = self.data[key1]\n        array2 = self.data[key2]\n        self.data[key1] = op(array1, array2)\n\n    def broadcast_operation(self, key: str, other: Union[np.ndarray, 'NpNdarrayDict'], op: Callable[[np.ndarray, np.ndarray], np.ndarray]) -&gt; None:\n        \"\"\"\n        Perform a broadcasting operation between the array of the specified key and another array or NpNdarrayDict.\n\n        Args:\n            key: The key of the array in the dictionary to operate on.\n            other: The other array or NpNdarrayDict to use in the operation.\n            op: A function to perform the operation. This should be a NumPy ufunc (like np.add, np.multiply).\n\n        Raises:\n            KeyError: If the key is not found in the dictionary.\n            ValueError: If the operation cannot be broadcasted or if it violates the min-max constraints.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found\")\n\n        if isinstance(other, NpNdarrayDict):\n            if other.shape != self.shape:\n                raise ValueError(\"Shapes of NpNdarrayDict objects do not match\")\n            other_array = other.data[key]  # Assuming we want to operate on the same key\n        elif isinstance(other, np.ndarray):\n            other_array = other\n        else:\n            raise ValueError(\"The 'other' parameter must be either a NumPy ndarray or NpNdarrayDict\")\n\n        result = op(self.data[key], other_array)\n\n        # Check if the result is within the allowed min-max range\n        if np.any(result &lt; self.dict[key]['min']) or np.any(result &gt; self.dict[key]['max']):\n            raise ValueError(\"Operation result violates min-max constraints\")\n\n        self.data[key] = result\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.__init__","title":"<code>__init__(data_dict, shape)</code>","text":"<p>Initialize the State class.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict[str, tuple[Any, Any, Any]]</code> <p>A dictionary where keys are attribute names and values are tuples        of (dtype, min_value, max_value).</p> required <code>shape</code> <code>tuple[int]</code> <p>The shape of the numpy arrays for each attribute.</p> required Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def __init__(self, data_dict: dict[str, tuple[Any, Any, Any]], shape: tuple[int]):\n    \"\"\"\n    Initialize the State class.\n\n    Args:\n        data_dict: A dictionary where keys are attribute names and values are tuples\n                   of (dtype, min_value, max_value).\n        shape: The shape of the numpy arrays for each attribute.\n\n    \"\"\"\n    self.shape = shape\n    self.init(data_dict, shape)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.apply_function","title":"<code>apply_function(key, func)</code>","text":"<p>Apply a user-defined function to the array of a specified key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>func</code> <code>Callable[[ndarray], ndarray]</code> <p>A function that takes a numpy array and returns a numpy array.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def apply_function(self, key: str, func: Callable[[np.ndarray], np.ndarray]) -&gt; None:\n    \"\"\"\n    Apply a user-defined function to the array of a specified key.\n\n    Args:\n        key: The attribute key.\n        func: A function that takes a numpy array and returns a numpy array.\n\n    Raises:\n        KeyError: If the key is not found.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found\")\n\n    self.data[key] = func(self.data[key])\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.broadcast_operation","title":"<code>broadcast_operation(key, other, op)</code>","text":"<p>Perform a broadcasting operation between the array of the specified key and another array or NpNdarrayDict.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the array in the dictionary to operate on.</p> required <code>other</code> <code>Union[ndarray, NpNdarrayDict]</code> <p>The other array or NpNdarrayDict to use in the operation.</p> required <code>op</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>A function to perform the operation. This should be a NumPy ufunc (like np.add, np.multiply).</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the dictionary.</p> <code>ValueError</code> <p>If the operation cannot be broadcasted or if it violates the min-max constraints.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def broadcast_operation(self, key: str, other: Union[np.ndarray, 'NpNdarrayDict'], op: Callable[[np.ndarray, np.ndarray], np.ndarray]) -&gt; None:\n    \"\"\"\n    Perform a broadcasting operation between the array of the specified key and another array or NpNdarrayDict.\n\n    Args:\n        key: The key of the array in the dictionary to operate on.\n        other: The other array or NpNdarrayDict to use in the operation.\n        op: A function to perform the operation. This should be a NumPy ufunc (like np.add, np.multiply).\n\n    Raises:\n        KeyError: If the key is not found in the dictionary.\n        ValueError: If the operation cannot be broadcasted or if it violates the min-max constraints.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found\")\n\n    if isinstance(other, NpNdarrayDict):\n        if other.shape != self.shape:\n            raise ValueError(\"Shapes of NpNdarrayDict objects do not match\")\n        other_array = other.data[key]  # Assuming we want to operate on the same key\n    elif isinstance(other, np.ndarray):\n        other_array = other\n    else:\n        raise ValueError(\"The 'other' parameter must be either a NumPy ndarray or NpNdarrayDict\")\n\n    result = op(self.data[key], other_array)\n\n    # Check if the result is within the allowed min-max range\n    if np.any(result &lt; self.dict[key]['min']) or np.any(result &gt; self.dict[key]['max']):\n        raise ValueError(\"Operation result violates min-max constraints\")\n\n    self.data[key] = result\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.elementwise_operation","title":"<code>elementwise_operation(key1, key2, op)</code>","text":"<p>Perform an element-wise operation between two arrays in the dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key1</code> <code>str</code> <p>The first attribute key.</p> required <code>key2</code> <code>str</code> <p>The second attribute key.</p> required <code>op</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>A function to perform element-wise operation.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If either key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def elementwise_operation(self, key1: str, key2: str, op: Callable[[np.ndarray, np.ndarray], np.ndarray]) -&gt; None:\n    \"\"\"\n    Perform an element-wise operation between two arrays in the dictionary.\n\n    Args:\n        key1: The first attribute key.\n        key2: The second attribute key.\n        op: A function to perform element-wise operation.\n\n    Raises:\n        KeyError: If either key is not found.\n    \"\"\"\n    if key1 not in self.data or key2 not in self.data:\n        raise KeyError(f\"One of the keys {key1}, {key2} not found\")\n\n    array1 = self.data[key1]\n    array2 = self.data[key2]\n    self.data[key1] = op(array1, array2)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_col","title":"<code>get_col(key, col_index)</code>","text":"<p>Get an entire column for the specified attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key in the state dictionary.</p> required <code>col_index</code> <code>int</code> <p>The index of the column to be retrieved.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array representing the column for the specified attribute.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_col(self, key: str, col_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get an entire column for the specified attribute.\n\n    Args:\n        key: The attribute key in the state dictionary.\n        col_index: The index of the column to be retrieved.\n\n    Returns:\n        A numpy array representing the column for the specified attribute.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n    \"\"\"\n    if key in self.data:\n        return self.data[key][:, col_index]\n    else:\n        raise KeyError(\"Key not found\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_col_for_attribute","title":"<code>get_col_for_attribute(key, col_index)</code>","text":"<p>Get an entire column for a specific attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>col_index</code> <code>int</code> <p>The index of the column to get.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing the column for the given key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_col_for_attribute(self, key: str, col_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get an entire column for a specific attribute.\n\n    Args:\n        key: The attribute key.\n        col_index: The index of the column to get.\n\n    Returns:\n        An array representing the column for the given key.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n\n    \"\"\"\n    if key in self.data:\n        return self.data[key][:, col_index]\n    else:\n        raise KeyError(\"Key not found\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_data","title":"<code>get_data()</code>","text":"<p>Get the entire current data as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>A dictionary where each key is an attribute and the value is a numpy array.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_data(self) -&gt; dict[str, np.ndarray]:\n    \"\"\"\n    Get the entire current data as a dictionary.\n\n    Returns:\n        A dictionary where each key is an attribute and the value is a numpy array.\n    \"\"\"\n    return self.data\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_row","title":"<code>get_row(key, row_index)</code>","text":"<p>Get an entire row for the specified attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key in the state dictionary.</p> required <code>row_index</code> <code>int</code> <p>The index of the row to be retrieved.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>A numpy array representing the row for the specified attribute.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_row(self, key: str, row_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get an entire row for the specified attribute.\n\n    Args:\n        key: The attribute key in the state dictionary.\n        row_index: The index of the row to be retrieved.\n\n    Returns:\n        A numpy array representing the row for the specified attribute.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n    \"\"\"\n    if key in self.data:\n        return self.data[key][row_index, :]\n    else:\n        raise KeyError(\"Key not found\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_row_for_attribute","title":"<code>get_row_for_attribute(key, row_index)</code>","text":"<p>Get an entire row for a specific attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>row_index</code> <code>int</code> <p>The index of the row to get.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>An array representing the row for the given key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_row_for_attribute(self, key: str, row_index: int) -&gt; np.ndarray:\n    \"\"\"\n    Get an entire row for a specific attribute.\n\n    Args:\n        key: The attribute key.\n        row_index: The index of the row to get.\n\n    Returns:\n        An array representing the row for the given key.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n\n    \"\"\"\n    if key in self.data:\n        return self.data[key][row_index, :]\n    else:\n        raise KeyError(\"Key not found\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_value","title":"<code>get_value(key, index)</code>","text":"<p>Get a value at a specific index for a given attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>index</code> <code>tuple[int]</code> <p>The index from which to get the value.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The value at the specified index for the given key.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_value(self, key: str, index: tuple[int]) -&gt; Any:\n    \"\"\"\n    Get a value at a specific index for a given attribute.\n\n    Args:\n        key: The attribute key.\n        index: The index from which to get the value.\n\n    Returns:\n        The value at the specified index for the given key.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n\n    \"\"\"\n    if key in self.data:\n        return self.data[key][index]\n    else:\n        raise KeyError(f\"Key {key} not found in state\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise","title":"<code>randomise()</code>","text":"<p>Randomize the entire state dictionary based on the datatype, minimum, and maximum values for each attribute.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise(self) -&gt; None:\n    \"\"\"\n    Randomize the entire state dictionary based on the datatype, minimum,\n    and maximum values for each attribute.\n    \"\"\"\n    for key in self.data:\n        data_type = self.dict[key]['dtype']\n        min_val   = self.dict[key]['min']\n        max_val   = self.dict[key]['max']\n        shape     = self.dict[key]['shape']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key] = np.random.randint(min_val, max_val + 1, size=shape, dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key] = np.random.uniform(min_val, max_val, size=shape).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise_attribute_col","title":"<code>randomise_attribute_col(key, col_index)</code>","text":"<p>Randomize the values in a specific column for a given attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>col_index</code> <code>int</code> <p>The index of the column to randomize.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise_attribute_col(self, key: str, col_index: int) -&gt; None:\n    \"\"\"\n    Randomize the values in a specific column for a given attribute.\n\n    Args:\n        key: The attribute key.\n        col_index: The index of the column to randomize.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found in state\")\n\n    data_type = self.dict[key]['dtype']\n    min_val = self.dict[key]['min']\n    max_val = self.dict[key]['max']\n\n    if np.issubdtype(data_type, np.integer):\n        self.data[key][:, col_index] = np.random.randint(min_val, max_val + 1, size=self.shape[0], dtype=data_type)\n    elif np.issubdtype(data_type, np.floating):\n        self.data[key][:, col_index] = np.random.uniform(min_val, max_val, size=self.shape[0]).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise_attribute_index","title":"<code>randomise_attribute_index(key, index)</code>","text":"<p>Randomize the value at a specific index for a given attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>index</code> <code>tuple[int, int]</code> <p>The index to randomize (row_index, column_index).</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise_attribute_index(self, key: str, index: tuple[int, int]) -&gt; None:\n    \"\"\"\n    Randomize the value at a specific index for a given attribute.\n\n    Args:\n        key: The attribute key.\n        index: The index to randomize (row_index, column_index).\n\n    Raises:\n        KeyError: If the key is not found in the state.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found in state\")\n\n    data_type = self.dict[key]['dtype']\n    min_val = self.dict[key]['min']\n    max_val = self.dict[key]['max']\n\n    if np.issubdtype(data_type, np.integer):\n        self.data[key][index] = np.random.randint(min_val, max_val + 1, dtype=data_type)\n    elif np.issubdtype(data_type, np.floating):\n        self.data[key][index] = np.random.uniform(min_val, max_val).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise_attribute_row","title":"<code>randomise_attribute_row(key, row_index)</code>","text":"<p>Randomize the values in a specific row for a given attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>row_index</code> <code>int</code> <p>The index of the row to randomize.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise_attribute_row(self, key: str, row_index: int) -&gt; None:\n    \"\"\"\n    Randomize the values in a specific row for a given attribute.\n\n    Args:\n        key: The attribute key.\n        row_index: The index of the row to randomize.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found in state\")\n\n    data_type = self.dict[key]['dtype']\n    min_val = self.dict[key]['min']\n    max_val = self.dict[key]['max']\n\n    if np.issubdtype(data_type, np.integer):\n        self.data[key][row_index, :] = np.random.randint(min_val, max_val + 1, size=self.shape[1], dtype=data_type)\n    elif np.issubdtype(data_type, np.floating):\n        self.data[key][row_index, :] = np.random.uniform(min_val, max_val, size=self.shape[1]).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise_col","title":"<code>randomise_col(col_index)</code>","text":"<p>Randomize the values in a specific column for all attributes.</p> <p>Parameters:</p> Name Type Description Default <code>col_index</code> <code>int</code> <p>The index of the column to randomize.</p> required Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise_col(self, col_index: int) -&gt; None:\n    \"\"\"\n    Randomize the values in a specific column for all attributes.\n\n    Args:\n        col_index: The index of the column to randomize.\n    \"\"\"\n    for key in self.data:\n        data_type = self.dict[key]['dtype']\n        min_val = self.dict[key]['min']\n        max_val = self.dict[key]['max']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key][:, col_index] = np.random.randint(min_val, max_val + 1, size=self.shape[0], dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key][:, col_index] = np.random.uniform(min_val, max_val, size=self.shape[0]).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise_index","title":"<code>randomise_index(index)</code>","text":"<p>Randomize the values at a specific index for all attributes.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>tuple[int, int]</code> <p>The index to randomize (row_index, column_index).</p> required Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise_index(self, index: tuple[int, int]) -&gt; None:\n    \"\"\"\n    Randomize the values at a specific index for all attributes.\n\n    Args:\n        index: The index to randomize (row_index, column_index).\n    \"\"\"\n    for key in self.data:\n        data_type = self.dict[key]['dtype']\n        min_val = self.dict[key]['min']\n        max_val = self.dict[key]['max']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key][index] = np.random.randint(min_val, max_val + 1, dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key][index] = np.random.uniform(min_val, max_val).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise_row","title":"<code>randomise_row(row_index)</code>","text":"<p>Randomize the values in a specific row for all attributes.</p> <p>Parameters:</p> Name Type Description Default <code>row_index</code> <code>int</code> <p>The index of the row to randomize.</p> required Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise_row(self, row_index: int) -&gt; None:\n    \"\"\"\n    Randomize the values in a specific row for all attributes.\n\n    Args:\n        row_index: The index of the row to randomize.\n    \"\"\"\n    for key in self.data:\n        data_type = self.dict[key]['dtype']\n        min_val = self.dict[key]['min']\n        max_val = self.dict[key]['max']\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key][row_index, :] = np.random.randint(min_val, max_val + 1, size=self.shape[1], dtype=data_type)\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key][row_index, :] = np.random.uniform(min_val, max_val, size=self.shape[1]).astype(data_type)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_col","title":"<code>set_col(key, col_index, col_values)</code>","text":"<p>Set an entire column for the specified attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key in the state dictionary.</p> required <code>col_index</code> <code>int</code> <p>The index of the column to be set.</p> required <code>col_values</code> <code>ndarray</code> <p>A numpy array of values to set in the column.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column length is invalid or the key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_col(self, key: str, col_index: int, col_values: np.ndarray) -&gt; None:\n    \"\"\"\n    Set an entire column for the specified attribute.\n\n    Args:\n        key: The attribute key in the state dictionary.\n        col_index: The index of the column to be set.\n        col_values: A numpy array of values to set in the column.\n\n    Raises:\n        ValueError: If the column length is invalid or the key is not found.\n    \"\"\"\n    if key in self.data and len(col_values) == self.shape[0]:\n        self.data[key][:, col_index] = col_values\n    else:\n        raise ValueError(\"Invalid column length or key\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_col_for_attribute","title":"<code>set_col_for_attribute(key, col_index, col_values)</code>","text":"<p>Set an entire column for a specific attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>col_index</code> <code>int</code> <p>The index of the column to set.</p> required <code>col_values</code> <code>ndarray</code> <p>An array of values to set in the column.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the column length is invalid or the key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_col_for_attribute(self, key: str, col_index: int, col_values: np.ndarray) -&gt; None:\n    \"\"\"\n    Set an entire column for a specific attribute.\n\n    Args:\n        key: The attribute key.\n        col_index: The index of the column to set.\n        col_values: An array of values to set in the column.\n\n    Raises:\n        ValueError: If the column length is invalid or the key is not found.\n\n    \"\"\"\n    if key in self.data and len(col_values) == self.shape[0]:\n        self.data[key][:, col_index] = col_values\n    else:\n        raise ValueError(\"Invalid column length or key\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_data","title":"<code>set_data(new_data)</code>","text":"<p>Set the data with a new data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>dict[str, ndarray]</code> <p>A dictionary representing the new data, where each key is an     attribute and the value is a numpy array.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the new data is invalid (e.g., wrong shape, type, or value range).</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_data(self, new_data: dict[str, np.ndarray]) -&gt; None:\n    \"\"\"\n    Set the data with a new data dictionary.\n\n    Args:\n        new_data: A dictionary representing the new data, where each key is an\n                attribute and the value is a numpy array.\n\n    Raises:\n        ValueError: If the new data is invalid (e.g., wrong shape, type, or value range).\n    \"\"\"\n    if self.validate_new_state(new_data):\n        self.data = new_data\n    else:\n        raise ValueError(\"Invalid data\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_row","title":"<code>set_row(key, row_index, row_values)</code>","text":"<p>Set an entire row for the specified attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key in the state dictionary.</p> required <code>row_index</code> <code>int</code> <p>The index of the row to be set.</p> required <code>row_values</code> <code>ndarray</code> <p>A numpy array of values to set in the row.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the row length is invalid or the key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_row(self, key: str, row_index: int, row_values: np.ndarray) -&gt; None:\n    \"\"\"\n    Set an entire row for the specified attribute.\n\n    Args:\n        key: The attribute key in the state dictionary.\n        row_index: The index of the row to be set.\n        row_values: A numpy array of values to set in the row.\n\n    Raises:\n        ValueError: If the row length is invalid or the key is not found.\n    \"\"\"\n    if key in self.data and len(row_values) == self.shape[1]:\n        self.data[key][row_index, :] = row_values\n    else:\n        raise ValueError(\"Invalid row length or key\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_row_for_attribute","title":"<code>set_row_for_attribute(key, row_index, row_values)</code>","text":"<p>Set an entire row for a specific attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>row_index</code> <code>int</code> <p>The index of the row to set.</p> required <code>row_values</code> <code>ndarray</code> <p>An array of values to set in the row.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the row length is invalid or the key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_row_for_attribute(self, key: str, row_index: int, row_values: np.ndarray) -&gt; None:\n    \"\"\"\n    Set an entire row for a specific attribute.\n\n    Args:\n        key: The attribute key.\n        row_index: The index of the row to set.\n        row_values: An array of values to set in the row.\n\n    Raises:\n        ValueError: If the row length is invalid or the key is not found.\n\n    \"\"\"\n    if key in self.data and len(row_values) == self.shape[1]:\n        self.data[key][row_index, :] = row_values\n    else:\n        raise ValueError(\"Invalid row length or key\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_value","title":"<code>set_value(key, index, value)</code>","text":"<p>Set a value at a specific index for a given attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>index</code> <code>tuple[int]</code> <p>The index at which to set the value.</p> required <code>value</code> <code>Any</code> <p>The value to set.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the state.</p> <code>ValueError</code> <p>If the value is out of the specified range for the key.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_value(self, key: str, index: tuple[int], value: Any) -&gt; None:\n    \"\"\"\n    Set a value at a specific index for a given attribute.\n\n    Args:\n        key: The attribute key.\n        index: The index at which to set the value.\n        value: The value to set.\n\n    Raises:\n        KeyError: If the key is not found in the state.\n        ValueError: If the value is out of the specified range for the key.\n\n    \"\"\"\n    if key in self.data:\n        if self.dict[key]['min'] &lt;= value &lt;= self.dict[key]['max']:\n            self.data[key][index] = value\n        else:\n            raise ValueError(f\"Value {value} is out of range for key {key}\")\n    else:\n        raise KeyError(f\"Key {key} not found in state\")\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.validate_new_state","title":"<code>validate_new_state(new_state)</code>","text":"<p>Validate a new state dictionary to ensure it conforms to the expected structure and constraints.</p> <p>Parameters:</p> Name Type Description Default <code>new_state</code> <code>dict[str, ndarray]</code> <p>A dictionary representing the new state to be validated.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the new state is valid, False otherwise.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def validate_new_state(self, new_state: dict[str, np.ndarray]) -&gt; bool:\n    \"\"\"\n    Validate a new state dictionary to ensure it conforms to the expected structure and constraints.\n\n    Args:\n        new_state: A dictionary representing the new state to be validated.\n\n    Returns:\n        True if the new state is valid, False otherwise.\n    \"\"\"\n    for key, array in new_state.items():\n        # Check if the key exists in the current state\n        if key not in self.data:\n            print(f\"Key {key} not found in current state\")\n            return False\n\n        # Check if the shape of the array matches\n        if array.shape != self.data[key].shape:\n            print(f\"Shape {array.shape} does not match expected shape {self.data[key].shape}\")\n            return False\n\n        # # Check if the data type of the array matches\n        # if array.dtype != self.data[key].dtype:\n        #     return False\n\n        # # Check if all values are within the specified range\n        # if not (self.data[key]['min'] &lt;= array).all() or not (array &lt;= self.data[key]['max']).all():\n        #     return False\n\n    return True\n</code></pre>"},{"location":"reference/tolvera/particles/","title":"Particles","text":"<p>TODO: color palette - implement using State TODO: Rewrite Particle class as tv.s.particle TODO: Particle.dist debug toroidal distance wrap function TODO: expose self.speed over OSC FIXME: refactor tmp_* fields and setters to use State</p>"},{"location":"reference/tolvera/particles/#tolvera.particles.Particles","title":"<code>Particles</code>","text":"Source code in <code>src/tolvera/particles.py</code> <pre><code>@ti.data_oriented\nclass Particles:\n    # def __init__(self, tolvera, species: Species, **kwargs):\n    def __init__(self, tolvera, **kwargs):\n        self.tv = tolvera\n        self.kwargs = kwargs\n        self.n = self.tv.pn\n        # self.s = species\n        self._speed = ti.field(ti.f32, shape=())\n        self._speed[None] = 1.0\n        self.substep = self.tv.substep\n        self.field = Particle.field(shape=(self.n))\n        # TODO: These should be possible with State\n        # self.pos = State(self.tv, {\n        #     'x': (0., self.tv.x),\n        #     'y': (0., self.tv.y),\n        # }, shape=(self.n,), osc=('get'), name='particles_pos')\n        self.tmp_pos = ti.Vector.field(2, ti.f32, shape=(self.n))\n        self.tmp_vel = ti.Vector.field(2, ti.f32, shape=(self.n))\n        self.tmp_pos_species = ti.Vector.field(2, ti.f32, shape=(self.tv.species))\n        self.tmp_vel_species = ti.Vector.field(2, ti.f32, shape=(self.tv.species))\n        self.tmp_vel_stats = ti.Vector.field(1, ti.f32, shape=(7))\n        self.active_indexes = ti.field(ti.i32, shape=(self.n))\n        self.active_count = ti.field(ti.i32, shape=())\n        self.init()\n    def init(self):\n        self.assign_species()\n        self.randomise()\n    @ti.kernel\n    def assign_species(self):\n        for i in range(self.n):\n            self.field[i].species = i % self.tv.species\n    def _randomise(self):\n        self.randomise()\n    @ti.kernel\n    def randomise(self):\n        for i in range(self.n):\n            si = self.field[i].species\n            s = self.tv.s.species[si]\n            species = si\n            active  = 1.0\n            pos     = [self.tv.x*ti.random(ti.f32),self.tv.y*ti.random(ti.f32)]\n            vel     = [2*(ti.random(ti.f32)-0.5), 2*(ti.random(ti.f32)-0.5)]\n            mass    = ti.random(ti.f32) * s.mass\n            size    = ti.random(ti.f32) * s.size\n            speed   = ti.random(ti.f32) * s.speed\n            self.field[i] = Particle(species=species, pos=pos, vel=vel, active=active, mass=mass, size=size, speed=speed)\n    @ti.kernel\n    def update(self):\n        # TODO: collisions\n        for i in range(self.n):\n            if self.field[i] == 0.0: continue\n            self.toroidal_wrap(i)\n            self.limit_speed(i)\n    @ti.kernel\n    def update_active(self):\n        j = 0\n        for i in range(self.n):\n            p = self.field[i]\n            if p.active &gt; 0.0:\n                self.active_indexes[j] = i\n                j += 1\n        self.active_count[None] = j\n    @ti.func\n    def toroidal_wrap(self, i):\n        p = self.field[i]\n        if p.pos[0] &gt; self.tv.x: self.field[i].pos[0] = 0.0\n        if p.pos[0] &lt; 0.0:    self.field[i].pos[0] = self.tv.x\n        if p.pos[1] &gt; self.tv.y: self.field[i].pos[1] = 0.0\n        if p.pos[1] &lt; 0.0:    self.field[i].pos[1] = self.tv.y\n    @ti.func\n    def limit_speed(self, i: int):\n        p = self.field[i]\n        s = self.tv.s.species[p.species]\n        if p.vel.norm() &gt; s.speed:\n            self.field[i].vel = p.vel.normalized() * s.speed * self._speed[None]\n    @ti.kernel\n    def activity_decay(self):\n        for i in range(self.active_count[None]):\n            idx = self.active_indexes[i]\n            self.field[idx].active *= self.field[i].decay\n    def process(self):\n        for i in range(self.substep):\n            self.update_active()\n            self.update()\n    @ti.kernel\n    def set_active(self, a: ti.i32):\n        for i in range(self.field.shape[0]):\n            if i &gt; a:\n                self.field[i].active = 0\n            else:\n                self.field[i].active = 1\n    @ti.kernel\n    def set_species_active(self, i: ti.i32, a: ti.i32):\n        for j in range(self.field.shape[0]):\n            if self.field[j].species == i:\n                if j &gt; a:\n                    self.field[j].active = 0\n                else:\n                    self.field[j].active = 1\n    def set_pos(self, i, x, y):\n        self.field[i].pos = [x, y]\n    def set_vel(self, i, x, y):\n        self.field[i].vel = [x, y]\n    def set_speed(self, i, s):\n        self.field[i].speed = s\n    def set_size(self, i, s):\n        self.field[i].size = s\n    def get_pos(self, i):\n        return self.field[i].pos.to_numpy().tolist()\n    def get_vel(self, i):\n        return self.field[i].vel.to_numpy().tolist()\n    def get_pos_all_1d(self):\n        self._get_pos_all()\n        return self.tmp_pos.to_numpy().flatten().tolist()\n    def get_pos_all_2d(self):\n        self._get_pos_all()\n        return self.tmp_pos.to_numpy().tolist()\n    def get_vel_all_1d(self):\n        self._get_vel_all()\n        return self.tmp_vel.to_numpy().flatten().tolist()\n    def get_vel_all_2d(self):\n        self._get_vel_all()\n        return self.tmp_vel.to_numpy().tolist()\n    @ti.kernel\n    def _get_pos_all(self):\n        # for i in range(self.active_count[None]):\n        #     idx = self.active_indexes[i]\n        #     p = self.field[idx]\n        #     self.tmp_pos[i] = p.pos / [self.tv.x, self.tv.y]\n        # TODO: Only send active particle positions...? Or inactive=-1?\n        for i in range(self.n):\n            p = self.field[i]\n            if p.active &gt; 0.0:\n                self.tmp_pos[i] = p.pos / [self.tv.x, self.tv.y]\n            # else:\n            #     self.tmp_pos[i] = [0.0,0.0] # ???\n    @ti.kernel\n    def _get_vel_all(self):\n        for i in range(self.n):\n            p = self.field[i]\n            if p.active &gt; 0.0:\n                self.tmp_vel[i] = p.vel\n    def get_pos_species_1d(self, species):\n        self._get_pos_species()\n        return self.tmp_pos_species.to_numpy().flatten().tolist()\n    def get_pos_species_2d(self, species):\n        self._get_pos_species(species)\n        return self.tmp_pos_species.to_numpy().tolist()\n    @ti.kernel\n    def _get_pos_species(self, i: ti.i32):\n        for j in range(self.n):\n            p = self.field[i]\n            if self.field[j].species == i and p.active &gt; 0.0:\n                self.tmp_pos_species[j] = p.pos / [self.tv.x, self.tv.y]\n    def get_vel_species_1d(self, species):\n        self._get_vel_species(species)\n        return self.tmp_vel_species.to_numpy().flatten().tolist()\n    def get_vel_species_2d(self, species):\n        self._get_vel_species(species)\n        return self.tmp_vel_species.to_numpy().tolist()\n    @ti.kernel\n    def _get_vel_species(self, i: ti.i32):\n        for j in range(self.n):\n            p = self.field[i]\n            if self.field[j].species == i and p.active &gt; 0.0:\n                self.tmp_vel_species[j] = p.vel\n    def get_vel_stats_species_1d(self, species):\n        self._species_velocity_statistics(species)\n        return self.tmp_vel_stats.to_numpy().flatten().tolist()\n    @ti.kernel\n    def _species_velocity_statistics(self, i: ti.i32):\n        '''\n        Centre of Mass Velocity: This is the average velocity of all particles in the species.\n        Relative Velocity: This is the average velocity of all particles in the species relative to the centre of mass velocity.\n        Angular Momentum: This is the sum of the angular momentum of all particles, which is given by mass * velocity * radius for each particle.\n        Kinetic Energy: This is the sum of the kinetic energy of all particles, which is given by 0.5 * mass * velocity^2 for each particle.\n        Temperature: In statistical mechanics, the temperature of a system of particles is related to the average kinetic energy of the particles.\n        '''\n        centre_of_mass_velocity = ti.Vector([0.0,0.0])\n        relative_velocity = ti.Vector([0.0,0.0])\n        angular_momentum = ti.Vector([0.0])\n        kinetic_energy = ti.Vector([0.0])\n        for j in range(self.n):\n            if self.field[j].species == i:\n                v = self.field[j].vel\n                p = self.field[j].pos\n                m = self.field[j].mass\n                centre_of_mass_velocity += v\n                relative_velocity       += v# - centre_of_mass_velocity\n                angular_momentum        += m * ti.math.cross(v,p)\n                kinetic_energy          += 0.5 * m * v.norm_sqr()\n        centre_of_mass_velocity = centre_of_mass_velocity / self.n_per_species\n        relative_velocity = (relative_velocity - centre_of_mass_velocity * self.n_per_species) / self.n_per_species\n        temperature = 2.0 * kinetic_energy / (self.particles_per_species * 1.380649e-23)\n        self.tmp_vel_stats[0] = centre_of_mass_velocity[0]\n        self.tmp_vel_stats[1] = centre_of_mass_velocity[1]\n        self.tmp_vel_stats[2] = relative_velocity[0]\n        self.tmp_vel_stats[3] = relative_velocity[1]\n        self.tmp_vel_stats[4] = angular_momentum[0]\n        self.tmp_vel_stats[5] = kinetic_energy[0]\n        self.tmp_vel_stats[6] = temperature[0]\n    def reset(self):\n        self.init()\n    def speed(self, speed: float=None):\n        if speed is not None:\n            self._speed[None] = speed\n        else:\n            return self._speed[None]\n    def __call__(self):\n        self.process()\n</code></pre>"},{"location":"reference/tolvera/patches/","title":"Patches","text":"<p>Workaround for:</p> <p>'dill.source.findsource fails when in asyncio REPL' https://github.com/uqfoundation/dill/issues/627</p>"},{"location":"reference/tolvera/patches/#tolvera.patches.findsource","title":"<code>findsource(object)</code>","text":"<p>Return the entire source file and starting line number for an object. For interactively-defined objects, the 'file' is the interpreter's history.</p> <p>The argument may be a module, class, method, function, traceback, frame, or code object.  The source code is returned as a list of all the lines in the file and the line number indexes a line in that list.  An IOError is raised if the source code cannot be retrieved, while a TypeError is raised for objects where the source code is unavailable (e.g. builtins).</p> Source code in <code>src/tolvera/patches.py</code> <pre><code>def findsource(object):\n    # print(f\"[dill.source.findsource] PATCHED\")\n\n    \"\"\"Return the entire source file and starting line number for an object.\n    For interactively-defined objects, the 'file' is the interpreter's history.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An IOError\n    is raised if the source code cannot be retrieved, while a TypeError is\n    raised for objects where the source code is unavailable (e.g. builtins).\"\"\"\n\n    def patched_getfile(module):\n        # set file = None when module.__package__ == 'asyncio'\n        # print(f\"[dill.source.patched_getfile] module={module}\\nmodule.__package__={module.__package__}\\nmodule.__name__={module.__name__}\")\n        if module.__package__ == 'asyncio':\n            raise TypeError\n        # if module.__package__ == 'sardine':\n        #     raise TypeError\n        ret = getfile(module)\n        return ret\n\n    module = getmodule(object)\n    # try: file = getfile(module)\n    try: file = patched_getfile(module)\n    except TypeError: file = None\n    # correctly compute `is_module_main` when in asyncio\n    is_module_main = (module and module.__name__ == '__main__' and not file)\n    # is_module_main = (module and module.__name__ == '__main__' or module.__name__ == 'sardine' and not file)\n    print(f\"[dill.source.findsource] module: {module}, file: {file}, is_module_main: {is_module_main}\")\n    if IS_IPYTHON and is_module_main:\n        #FIXME: quick fix for functions and classes in IPython interpreter\n        try:\n            file = getfile(object)\n            sourcefile = getsourcefile(object)\n        except TypeError:\n            if isclass(object):\n                for object_method in filter(isfunction, object.__dict__.values()):\n                    # look for a method of the class\n                    file_candidate = getfile(object_method)\n                    if not file_candidate.startswith('&lt;ipython-input-'):\n                        continue\n                    file = file_candidate\n                    sourcefile = getsourcefile(object_method)\n                    break\n        if file:\n            lines = linecache.getlines(file)\n        else:\n            # fallback to use history\n            history = '\\n'.join(get_ipython().history_manager.input_hist_parsed)\n            lines = [line + '\\n' for line in history.splitlines()]\n    # use readline when working in interpreter (i.e. __main__ and not file)\n    elif is_module_main:\n        try:\n            import readline\n            err = ''\n        except ImportError:\n            import sys\n            err = sys.exc_info()[1].args[0]\n            if sys.platform[:3] == 'win':\n                err += \", please install 'pyreadline'\"\n        if err:\n            raise IOError(err)\n        lbuf = readline.get_current_history_length()\n        lines = [readline.get_history_item(i)+'\\n' for i in range(1,lbuf)]\n    else:\n        try: # special handling for class instances\n            if not isclass(object) and isclass(type(object)): # __class__\n                file = getfile(module)\n                sourcefile = getsourcefile(module)\n            else: # builtins fail with a TypeError\n                file = getfile(object)\n                sourcefile = getsourcefile(object)\n        except (TypeError, AttributeError): # fail with better error\n            file = getfile(object)\n            sourcefile = getsourcefile(object)\n        if not sourcefile and file[:1] + file[-1:] != '&lt;&gt;':\n            raise IOError('source code not available')\n        file = sourcefile if sourcefile else file\n\n        module = getmodule(object, file)\n        if module:\n            lines = linecache.getlines(file, module.__dict__)\n        else:\n            lines = linecache.getlines(file)\n\n    if not lines:\n        raise IOError('could not extract source code')\n\n    #FIXME: all below may fail if exec used (i.e. exec('f = lambda x:x') )\n    if ismodule(object):\n        return lines, 0\n\n    #NOTE: beneficial if search goes from end to start of buffer history\n    name = pat1 = obj = ''\n    pat2 = r'^(\\s*@)'\n#   pat1b = r'^(\\s*%s\\W*=)' % name #FIXME: finds 'f = decorate(f)', not exec\n    if ismethod(object):\n        name = object.__name__\n        if name == '&lt;lambda&gt;': pat1 = r'(.*(?&lt;!\\w)lambda(:|\\s))'\n        else: pat1 = r'^(\\s*def\\s)'\n        object = object.__func__\n    if isfunction(object):\n        name = object.__name__\n        if name == '&lt;lambda&gt;':\n            pat1 = r'(.*(?&lt;!\\w)lambda(:|\\s))'\n            obj = object #XXX: better a copy?\n        else: pat1 = r'^(\\s*def\\s)'\n        object = object.__code__\n    if istraceback(object):\n        object = object.tb_frame\n    if isframe(object):\n        object = object.f_code\n    if iscode(object):\n        if not hasattr(object, 'co_firstlineno'):\n            raise IOError('could not find function definition')\n        # stdin = object.co_filename == '&lt;stdin&gt;'\n        stdin = object.co_filename in ('&lt;console&gt;', '&lt;stdin&gt;')\n        # print(f\"[dill.source.findsource] object.co_filename: {object.co_filename}, stdin: {stdin}\")\n        if stdin:\n            lnum = len(lines) - 1 # can't get lnum easily, so leverage pat\n            if not pat1: pat1 = r'^(\\s*def\\s)|(.*(?&lt;!\\w)lambda(:|\\s))|^(\\s*@)'\n        else:\n            lnum = object.co_firstlineno - 1\n            pat1 = r'^(\\s*def\\s)|(.*(?&lt;!\\w)lambda(:|\\s))|^(\\s*@)'\n        pat1 = re.compile(pat1); pat2 = re.compile(pat2)\n       #XXX: candidate_lnum = [n for n in range(lnum) if pat1.match(lines[n])]\n        while lnum &gt; 0: #XXX: won't find decorators in &lt;stdin&gt; ?\n            line = lines[lnum]\n            if pat1.match(line):\n                if not stdin: break # co_firstlineno does the job\n                if name == '&lt;lambda&gt;': # hackery needed to confirm a match\n                    if _matchlambda(obj, line): break\n                else: # not a lambda, just look for the name\n                    if name in line: # need to check for decorator...\n                        hats = 0\n                        for _lnum in range(lnum-1,-1,-1):\n                            if pat2.match(lines[_lnum]): hats += 1\n                            else: break\n                        lnum = lnum - hats\n                        break\n            lnum = lnum - 1\n        return lines, lnum\n\n    try: # turn instances into classes\n        if not isclass(object) and isclass(type(object)): # __class__\n            object = object.__class__ #XXX: sometimes type(class) is better?\n            #XXX: we don't find how the instance was built\n    except AttributeError: pass\n    if isclass(object):\n        name = object.__name__\n        pat = re.compile(r'^(\\s*)class\\s*' + name + r'\\b')\n        # make some effort to find the best matching class definition:\n        # use the one with the least indentation, which is the one\n        # that's most probably not inside a function definition.\n        candidates = []\n        for i in range(len(lines)-1,-1,-1):\n            match = pat.match(lines[i])\n            if match:\n                # if it's at toplevel, it's already the best one\n                if lines[i][0] == 'c':\n                    return lines, i\n                # else add whitespace to candidate list\n                candidates.append((match.group(1), i))\n        if candidates:\n            # this will sort by whitespace, and by line number,\n            # less whitespace first  #XXX: should sort high lnum before low\n            candidates.sort()\n            return lines, candidates[0][1]\n        else:\n            raise IOError('could not find class definition')\n    raise IOError('could not find code object')\n</code></pre>"},{"location":"reference/tolvera/pixels/","title":"Pixels","text":"<p>TODO: convert all ints to floats FIXME: @ti.dataclass inheritance https://github.com/taichi-dev/taichi/issues/7422 TODO: add convex hull algorithm TODO: add algobets-style shape analysis (to CV?) TODO: add draw funcs to OSCMap? how to handle state/repainting? TODO: add functions for symmetry? (e.g. mirror, rotate, etc.)</p>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels","title":"<code>Pixels</code>","text":"Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.data_oriented\nclass Pixels:\n    def __init__(self, tolvera, **kwargs):\n        self.tv = tolvera\n        self.kwargs = kwargs\n        self.polygon_mode = kwargs.get('polygon_mode', 'crossing')\n        self.x = self.tv.x\n        self.y = self.tv.y\n        self.px = Pixel.field(shape=(self.x, self.y))\n        self.shape_enum = {\n            'point':    0,\n            'line':     1,\n            'rect':     2,\n            'circle':   3,\n            'triangle': 4,\n            'polygon':  5,\n        }\n    def set(self, px):\n        self.px.rgba = px.rgba\n    def get(self):\n        return self.px\n    @ti.kernel\n    def clear(self):\n        self.px.rgba.fill(0)\n    @ti.kernel\n    def diffuse(self, evaporate: ti.f32):\n        for i, j in ti.ndrange(self.x, self.y):\n            d = ti.Vector([0.0,0.0,0.0,0.0])\n            for di in ti.static(range(-1, 2)):\n                for dj in ti.static(range(-1, 2)):\n                    dx = (i + di) % self.x\n                    dy = (j + dj) % self.y\n                    d += self.px.rgba[dx, dy]\n            d *= evaporate/9.0\n            self.px.rgba[i,j] = d\n    @ti.func\n    def background(self,r,g,b):\n        bg = ti.Vector([r,g,b,1.0])\n        self.rect(0, 0, self.x, self.y, bg)\n    @ti.func\n    def point(self, x: ti.i32, y: ti.i32, rgba: vec4):\n        self.px.rgba[x,y] = rgba\n    @ti.func\n    def points(self, x: ti.template(), y: ti.template(), rgba: vec4):\n        for i in ti.static(range(len(x))):\n            self.point(x[i], y[i], rgba)\n    @ti.func\n    def rect(self, x: ti.i32, y: ti.i32, w: ti.i32, h: ti.i32, rgba: vec4):\n        # TODO: fill arg\n        # TODO: gradients, lerp with ti.math.mix(x, y, a)\n        for i, j in ti.ndrange(w, h):\n            self.px.rgba[x+i, y+j] = rgba\n    @ti.func\n    def line(self, x0: ti.i32, y0: ti.i32, x1: ti.i32, y1: ti.i32, rgba: vec4):\n        '''\n        Bresenham's line algorithm\n        TODO: thickness\n        TODO: anti-aliasing\n        TODO: should lines wrap around (as two lines)?\n        '''\n        dx = ti.abs(x1 - x0)\n        dy = ti.abs(y1 - y0)\n        x, y = x0, y0\n        sx = -1 if x0 &gt; x1 else 1\n        sy = -1 if y0 &gt; y1 else 1\n        if dx &gt; dy:\n            err = dx / 2.0\n            while x != x1:\n                self.px.rgba[x, y] = rgba\n                err -= dy\n                if err &lt; 0:\n                    y += sy\n                    err += dx\n                x += sx\n        else:\n            err = dy / 2.0\n            while y != y1:\n                self.px.rgba[x, y] = rgba\n                err -= dx\n                if err &lt; 0:\n                    x += sx\n                    err += dy\n                y += sy\n        self.px.rgba[x, y] = rgba\n    @ti.func\n    def circle(self, x: ti.i32, y: ti.i32, r: ti.i32, rgba: vec4):\n        for i in range(r + 1):\n            d = ti.sqrt(r ** 2 - i ** 2)\n            d_int = ti.cast(d, ti.i32)\n            # TODO: parallelise ?\n            for j in range(d_int):\n                self.px.rgba[x + i, y + j] = rgba\n                self.px.rgba[x + i, y - j] = rgba\n                self.px.rgba[x - i, y - j] = rgba\n                self.px.rgba[x - i, y + j] = rgba\n    @ti.func\n    def circles(self, x: ti.template(), y: ti.template(), r: ti.template(), rgba: vec4):\n        for i in ti.static(range(len(x))):\n            self.circle(x[i], y[i], r[i], rgba)\n    @ti.func\n    def triangle(self, a, b, c, rgba: vec4):\n        # TODO: fill arg\n        x = ti.Vector([a[0], b[0], c[0]])\n        y = ti.Vector([a[1], b[1], c[1]])\n        self.polygon(x,y,rgba)\n    @ti.func\n    def polygon(self, x: ti.template(), y: ti.template(), rgba: vec4):\n        # TODO: fill arg\n        # after http://www.dgp.toronto.edu/~mac/e-stuff/point_in_polygon.py\n        x_min, x_max = ti.cast(x.min(), ti.i32), ti.cast(x.max(), ti.i32)\n        y_min, y_max = ti.cast(y.min(), ti.i32), ti.cast(y.max(), ti.i32)\n        l = len(x)\n        for i, j in ti.ndrange(x_max-x_min, y_max-y_min):\n            p = [x_min+i, y_min+j]\n            if self._is_inside(p,x,y,l) != 0:\n                # TODO: abstract out, weight?\n                '''\n                x-1,y-1  x,y-1  x+1,y-1\n                x-1,y    x,y    x+1,y\n                x-1,y+1  x,y+1  x+1,y+1\n                '''\n                _x, _y = p[0], p[1]\n                self.px.rgba[_x-1,_y-1] = rgba\n                self.px.rgba[_x-1,_y]   = rgba\n                self.px.rgba[_x-1,_y+1] = rgba\n\n                self.px.rgba[_x,_y-1]   = rgba\n                self.px.rgba[_x,_y]     = rgba\n                self.px.rgba[_x,_y+1]   = rgba\n\n                self.px.rgba[_x+1,_y-1] = rgba\n                self.px.rgba[_x+1,_y]   = rgba\n                self.px.rgba[_x+1,_y+1] = rgba\n\n    @ti.func\n    def _is_inside(self,p,x,y,l):\n        is_inside = 0\n        if self.polygon_mode == 'crossing':\n            is_inside = self._is_inside_crossing(p,x,y,l)\n        elif self.polygon_mode == 'winding':\n            is_inside = self._is_inside_winding(p,x,y,l)\n        return is_inside\n    @ti.func\n    def _is_inside_crossing(self,p,x,y,l):\n        n = 0\n        v0, v1 = ti.Vector([0.0,0.0]), ti.Vector([0.0,0.0])\n        for i in range(l):\n            i1 = i + 1 if i &lt; l - 1 else 0\n            v0, v1 = [x[i], y[i]], [x[i1], y[i1]]\n            if (v0[1] &lt;= p[1] and v1[1] &gt; p[1]) or \\\n                (v0[1] &gt; p[1] and v1[1] &lt;= p[1]):\n                vt = (p[1] - v0[1]) / (v1[1] - v0[1])\n                if p[0] &lt; v0[0] + vt * (v1[0] - v0[0]):\n                    n += 1\n        return n % 2\n    @ti.func\n    def _is_inside_winding(self,p,x,y,l):\n        n = 0\n        v0, v1 = ti.Vector([0.0,0.0]), ti.Vector([0.0,0.0])\n        for i in range(l):\n            i1 = i + 1 if i &lt; l - 1 else 0\n            v0, v1 = [x[i], y[i]], [x[i1], y[i1]]\n            if v0[1] &lt;= p[1] and v1[1] &gt; p[1] and \\\n                (v0 - v1).cross(p - v1) &gt; 0:\n                n += 1\n            elif v1[1] &lt;= p[1] and (v0-v1).cross(p-v1) &lt; 0:\n                n -= 1\n        return n\n    @ti.kernel\n    def flip_x(self):\n        '''\n        Invert image in x-axis.\n        '''\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba_inv[i,j] = self.px.rgba[self.x-1-i,j]\n    @ti.kernel\n    def flip_y(self):\n        '''\n        Flip image in y-axis.\n        '''\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba_inv[i,j] = self.px.rgba[i,self.y-1-j]\n    @ti.kernel\n    def decay(self, evaporate: ti.f32):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] *= evaporate\n    @ti.kernel\n    def blend_add(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] += px.rgba[i,j]\n    @ti.kernel\n    def blend_sub(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] -= px.rgba[i,j]\n    @ti.kernel\n    def blend_mul(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] *= px.rgba[i,j]\n    @ti.kernel\n    def blend_div(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] /= px.rgba[i,j]\n    @ti.kernel\n    def blend_min(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] = ti.min(self.px.rgba[i,j], px.rgba[i,j])\n    @ti.kernel\n    def blend_max(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] = ti.max(self.px.rgba[i,j], px.rgba[i,j])\n    @ti.kernel\n    def blend_diff(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] = ti.abs(self.px.rgba[i,j] - px.rgba[i,j])\n    @ti.kernel\n    def blend_diff_inv(self, px: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] = ti.abs(px.rgba[i,j] - self.px.rgba[i,j])\n    @ti.kernel\n    def blend_mix(self, px: ti.template(), a: ti.f32):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i,j] = ti.math.mix(self.px.rgba[i,j], px.rgba[i,j], a)\n    def particles(self, particles: ti.template(), species: ti.template(), shape='circle'):\n        shape = self.shape_enum[shape]\n        self._particles(particles, species, shape)\n    @ti.kernel\n    def _particles(self, particles: ti.template(), species: ti.template(), shape: int):\n        for i in range(self.tv.p.n):\n            p = particles.field[i]\n            s = species.field[p.species]\n            if p.active == 0.0: continue\n            px = ti.cast(p.pos[0], ti.i32)\n            py = ti.cast(p.pos[1], ti.i32)\n            vx = ti.cast(p.pos[0] + p.vel[0]*20, ti.i32)\n            vy = ti.cast(p.pos[1] + p.vel[1]*20, ti.i32)\n            if shape == 0:\n                self.point(px, py, s.rgba)\n            elif shape == 1:\n                self.line(px, py, vx, vy, s.rgba)\n            elif shape == 2:\n                side = int(s.size)*2\n                self.rect(px, py, side, side, s.rgba)\n            elif shape == 3:\n                self.circle(px, py, s.size, s.rgba)\n            elif shape == 4:\n                a = p.pos\n                b = p.pos + 1\n                c = a + b\n                self.triangle(a,b,c, s.rgba)\n            # elif shape == 5:\n            #     self.polygon(px, py, s.rgba)\n    @ti.kernel\n    def update(self):\n        pass\n    def reset(self):\n        self.clear()\n    def __call__(self):\n        return self.get()\n    @ti.func\n    def rgba_inv(self):# -&gt; vec3:\n        # TODO: rgba_inv\n        pass\n    # TODO: Normalise positions to [0,1] range?\n    @ti.func\n    def pos_to_px(self, pos: ti.math.vec2) -&gt; ti.math.vec2:\n        return pos * [self.tv.x, self.tv.y]\n    @ti.func\n    def px_to_pos(self, px: ti.math.vec2) -&gt; ti.math.vec2:\n        return px / [self.tv.x, self.tv.y]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.flip_x","title":"<code>flip_x()</code>","text":"<p>Invert image in x-axis.</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.kernel\ndef flip_x(self):\n    '''\n    Invert image in x-axis.\n    '''\n    for i, j in ti.ndrange(self.x, self.y):\n        self.px.rgba_inv[i,j] = self.px.rgba[self.x-1-i,j]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.flip_y","title":"<code>flip_y()</code>","text":"<p>Flip image in y-axis.</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.kernel\ndef flip_y(self):\n    '''\n    Flip image in y-axis.\n    '''\n    for i, j in ti.ndrange(self.x, self.y):\n        self.px.rgba_inv[i,j] = self.px.rgba[i,self.y-1-j]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.line","title":"<code>line(x0, y0, x1, y1, rgba)</code>","text":"<p>Bresenham's line algorithm TODO: thickness TODO: anti-aliasing TODO: should lines wrap around (as two lines)?</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.func\ndef line(self, x0: ti.i32, y0: ti.i32, x1: ti.i32, y1: ti.i32, rgba: vec4):\n    '''\n    Bresenham's line algorithm\n    TODO: thickness\n    TODO: anti-aliasing\n    TODO: should lines wrap around (as two lines)?\n    '''\n    dx = ti.abs(x1 - x0)\n    dy = ti.abs(y1 - y0)\n    x, y = x0, y0\n    sx = -1 if x0 &gt; x1 else 1\n    sy = -1 if y0 &gt; y1 else 1\n    if dx &gt; dy:\n        err = dx / 2.0\n        while x != x1:\n            self.px.rgba[x, y] = rgba\n            err -= dy\n            if err &lt; 0:\n                y += sy\n                err += dx\n            x += sx\n    else:\n        err = dy / 2.0\n        while y != y1:\n            self.px.rgba[x, y] = rgba\n            err -= dx\n            if err &lt; 0:\n                x += sx\n                err += dy\n            y += sy\n    self.px.rgba[x, y] = rgba\n</code></pre>"},{"location":"reference/tolvera/species/","title":"Species","text":""},{"location":"reference/tolvera/state/","title":"State","text":"<p>TODO: save/load? serialise/deserialise TODO: OSCMap getters     state analysers -&gt; OSC senders     iipyper osc returns? TODO: tidy up <code>osc_receive_randomise</code>, move into iipyper.map.py? TODO: IML: add default mapping? TODO: Sardine: pattern utils? TODO: @ti.func struct methods - can these be monkey patched?     if not add to constructor as a dict     use case would be Particles.Particle</p>"},{"location":"reference/tolvera/utils/","title":"Utils","text":"<p>TODO: Save/load</p>"},{"location":"reference/tolvera/utils/#tolvera.utils.CONSTS","title":"<code>CONSTS</code>","text":"<p>Dict of CONSTS that can be used in Taichi scope</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>class CONSTS:\n    '''\n    Dict of CONSTS that can be used in Taichi scope\n    '''\n    def __init__(self, dict: dict[str, (DataType, Any)]):\n        self.struct = ti.types.struct(**{k: v[0] for k, v in dict.items()})\n        self.consts = self.struct(**{k: v[1] for k, v in dict.items()})\n    def __getattr__(self, name):\n        try:\n            return self.consts[name]\n        except:\n            raise AttributeError(f\"CONSTS has no attribute {name}\")\n    def __getitem__(self, name):\n        try:\n            return self.consts[name]\n        except:\n            raise AttributeError(f\"CONSTS has no attribute {name}\")\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.dotdict","title":"<code>dotdict</code>","text":"<p>             Bases: <code>dict</code></p> <p>dot.notation access to dictionary attributes</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>class dotdict(dict):\n    \"\"\"dot.notation access to dictionary attributes\"\"\"\n    __getattr__ = dict.get\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.time_function","title":"<code>time_function(func, *args, **kwargs)</code>","text":"<p>Time how long it takes to run a function and print the result</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def time_function(func, *args, **kwargs):\n    \"\"\"Time how long it takes to run a function and print the result\n    \"\"\"\n    start = time.time()\n    func(*args, **kwargs)\n    end = time.time()\n    print(f\"[Tolvera.utils] {func.__name__}() ran in {end-start:.4f}s\")\n    return end-start\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.validate_json_path","title":"<code>validate_json_path(path)</code>","text":"<p>Validate a JSON file path. It uses validate_path for initial validation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The JSON file path to be validated.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path is a valid JSON file path, raises an exception otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path does not end with '.json'.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def validate_json_path(path: str) -&gt; bool:\n    \"\"\"\n    Validate a JSON file path. It uses validate_path for initial validation.\n\n    Args:\n        path (str): The JSON file path to be validated.\n\n    Returns:\n        bool: True if the path is a valid JSON file path, raises an exception otherwise.\n\n    Raises:\n        ValueError: If the path does not end with '.json'.\n    \"\"\"\n    # Using validate_path for basic path validation\n    validate_path(path)\n\n    if not path.endswith('.json'):\n        raise ValueError(\"Path should end with '.json'\")\n\n    return True\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.validate_path","title":"<code>validate_path(path)</code>","text":"<p>Validate a path using os.path and pathlib.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to be validated.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path is valid, raises an exception otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input is not a string.</p> <code>FileNotFoundError</code> <p>If the path does not exist.</p> <code>PermissionError</code> <p>If the path is not accessible.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def validate_path(path: str) -&gt; bool:\n    \"\"\"\n    Validate a path using os.path and pathlib.\n\n    Args:\n        path (str): The path to be validated.\n\n    Returns:\n        bool: True if the path is valid, raises an exception otherwise.\n\n    Raises:\n        TypeError: If the input is not a string.\n        FileNotFoundError: If the path does not exist.\n        PermissionError: If the path is not accessible.\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(f\"Expected a string for path, but received {type(path)}\")\n\n    path_obj = Path(path)\n    if not path_obj.is_file():\n        raise FileNotFoundError(f\"The path {path} does not exist or is not a file\")\n\n    if not os.access(path, os.R_OK):\n        raise PermissionError(f\"The path {path} is not accessible\")\n\n    return True\n</code></pre>"},{"location":"reference/tolvera/tests/__init__/","title":"init","text":""},{"location":"reference/tolvera/tests/test_npndarray/","title":"Test npndarray","text":""},{"location":"reference/tolvera/tests/test_rules_setters/","title":"Test rules setters","text":"<p>TODO: segfaults, how do Taichi run their tests?</p>"},{"location":"reference/tolvera/tests/test_state/","title":"Test state","text":""},{"location":"reference/tolvera/tests/test_taichi_serialize/","title":"Test taichi serialize","text":"<p>TODO: Add assertions</p>"},{"location":"reference/tolvera/vera/__init__/","title":"init","text":""},{"location":"reference/tolvera/vera/attractor/","title":"Attractor","text":"<p>TODO: why is mass so sensitive? TODO: render() TODO: more neighbour funcs/stats TODO: move particles.seek|avoid here? (attract|repel) TODO: rename to Target? TODO: wall behaviour TODO: should be a particle field itself? to use move functions etc</p>"},{"location":"reference/tolvera/vera/flock/","title":"Flock","text":"<p>FIXME: still some NaNs happening? TODO: particle state analysis/applications? TODO: is half of self.state.dist redundant? print with low n TODO: re-add credit</p>"},{"location":"reference/tolvera/vera/move/","title":"Move","text":""},{"location":"reference/tolvera/vera/reaction_diffusion/","title":"Reaction diffusion","text":"<p>TODO: why does substep &gt; 20 crash? TODO: make toroidal TODO: improve stability TODO: make reset() work</p>"},{"location":"reference/tolvera/vera/slime/","title":"Slime","text":"<p>FIXME: deposit: bug in species indexing causing color changes TODO: sense_rgba:      test     remove <code>a</code> from <code>rgba</code>?     separate slime class? slimergba? TODO: re-add credit</p>"}]}