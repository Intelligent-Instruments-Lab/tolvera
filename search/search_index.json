{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"T\u00f6lvera","text":""},{"location":"#tolvera","title":"T\u00f6lvera","text":"<p>T\u00f6lvera is a library for exploring musical performance with artificial life (ALife) and self-organising systems. The word is an Icelandic kenning:</p> <ul> <li>T\u00f6lva = computer, from tala (number) + v\u00f6lva (prophetess)</li> <li>Vera = being</li> <li>T\u00f6lvera = number being</li> </ul> <p>T\u00f6lvera is written in Taichi, a domain-specific language embedded in Python.</p> <p>This is experimental software and everything is currently subject to change.</p> <p>Join us on the T\u00f6lvera Discord.</p>"},{"location":"#showcase","title":"Showcase","text":"<p>Visit the YouTube Playlist (if you'd like to add a video, please get in touch).</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li><code>tv.v</code>: a collection of \"vera\" (beings) including Move, Flock, Slime and Swarm, with more being continuously added. Vera can be combined and composed in various ways.</li> <li><code>tv.p</code>: extensible particle system. Particles are divided into multiple species, where each species has a unique relationship with every other species, including itself</li> <li><code>tv.s</code>: n-dimensional state structures that can be used by \"vera\", including built-in OSC and IML creation (see below).</li> <li><code>tv.px</code>: drawing library including various shapes and blend modes, styled similarly to p5.js etc.</li> <li><code>tv.osc</code>: Open Sound Control (OSC) via iipyper, including automated export of OSC schemas to JSON, XML, Pure Data (Pd), Max/MSP (SuperCollider TBC).</li> <li><code>tv.iml</code>: Interactive Machine Learning via anguilla.</li> <li><code>tv.ti</code>: Taichi-based simulation and rendering engine. Can be run \"headless\" (without graphics).</li> <li><code>tv.cv</code>: computer vision integration based on OpenCV.</li> </ul>"},{"location":"#install","title":"Install","text":"<p>Taichi supports numerous operating systems and backends. If you plan on using Vulkan for graphics (recommended for macOS), you may need to install the Vulkan SDK first and restart your machine.</p> <p>T\u00f6lvera is registered on PyPI and can be installed via a Python package manager such as <code>pip</code>:</p> <pre><code>pip install tolvera\n</code></pre>"},{"location":"#development","title":"Development","text":"<p>Fork/clone this repository and install the package in editable mode:</p> <pre><code>git clone https://github.com/Intelligent-Instruments-Lab/tolvera # (or clone your own fork)\ncd tolvera\npip install -e tolvera\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome Pull Requests across all areas of the project:</p> <ul> <li>Addressing Issues</li> <li>Adding features (see Issues and Discussion)</li> <li>Examples</li> <li>Tests</li> <li>Documentation</li> </ul>"},{"location":"#community","title":"Community","text":"<p>To discuss T\u00f6lvera with developers and other users:</p> <ul> <li>Use GitHub Issues to report bugs and make specific feature requests.</li> <li>Use GitHub Discussions to share ideas and ask questions.</li> <li>Use Discord for further support, sharing your work, and general chat.</li> </ul> <p>Across the project, we follow the Algorave Code of Conduct. Please get in touch if you experience or witness any conduct issues.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>See Discussion.</p>"},{"location":"#citing","title":"Citing","text":"<p>T\u00f6lvera is being written about and used in a number of contexts (see references.bib), here are a few recent examples:</p> <pre><code>@inproceedings{armitageAgentialScoresExploring2023,\n  Address = {Boston, Massachusetts, USA},\n  Author = { Jack Armitage and Thor Magnusson },\n  Title = {Agential Scores: Artificial Life for Emergent, Self-Organising and Entangled Music Notation},\n  Booktitle = {Proceedings of the International Conference on Technologies for Music Notation and Representation -- TENOR'2023},\n  Pages = {51 - 61},\n  Year = {2023},\n  Editor = {Anthony Paul De Ritis and Victor Zappi and Jeremy Van Buskirk and John Mallia},\n  Publisher = {Northeastern University},\n  ISBN = {978-0-6481592-7-8}\n}\n\n@inproceedings{armitageStrengjavera2023,\n  title = {Strengjavera},\n  booktitle = {{{AI Music Creativity}} 2023},\n  author = {Armitage, Jack},\n  year = {2023},\n  address = {{University of Sussex, Brighton, UK}},\n  doi = {10.5281/zenodo.8329855},\n  ISBN = {978-0-9957862-9-5},\n  url = {https://zenodo.org/records/8329855}\n}\n</code></pre>"},{"location":"#inspiration","title":"Inspiration","text":"<ul> <li>SwissGL</li> <li>Lenia</li> <li>Particle Life (attributed to various, see for example Clusters)</li> <li>Journey to the Microcosmos</li> <li>Complexity Explorables</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p><code>tolvera</code> is developed by the Intelligent Instruments Lab. Get in touch to collaborate:</p> <p>\u25e6 iil.is \u25e6  Facebook \u25e6  Instagram \u25e6  X (Twitter) \u25e6  YouTube \u25e6  Discord \u25e6  GitHub \u25e6  LinkedIn \u25e6  Email \u25e6 </p>"},{"location":"#funding","title":"Funding","text":"<p>The Intelligent Instruments project (INTENT) is funded by the European Research Council (ERC) under the European Union\u2019s Horizon 2020 research and innovation programme (Grant agreement No. 101001848).</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>The full collection of examples can be found in iil-examples. Here are some simple examples:</p>"},{"location":"examples/#rendering-motionless-particles","title":"Rendering motionless particles","text":"<p>This is the most basic syntax for creating a T\u00f6lvera scene. When run, this scene will render a window using default options, and display some motionless particles:</p> <pre><code>from tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @tv.render\n    def _():\n        pass\n</code></pre>"},{"location":"examples/#making-particles-behave","title":"Making particles behave","text":"<p>We can make the particles behave by passing them to a \"vera\", moving or flocking them based on their properties:</p> <pre><code>from tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @tv.render\n    def _():\n        tv.v.move(tv.p) # Moving\n        # tv.v.flock(tv.p) # Flocking\n</code></pre>"},{"location":"examples/#controlling-vera-via-osc-input","title":"Controlling \"vera\" via OSC input","text":"<p>T\u00f6lvera will create an OSC server and client when <code>osc=True</code> is passed: </p> <pre><code>from tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(osc=True, **kwargs)\n\n    @tv.render\n    def _():\n        tv.v.flock(tv.p)\n</code></pre> <p><code>tv.v.flock</code> can now be controlled via OSC in a number of different ways.</p> <p>The full OSC options and their defaults are:</p> <pre><code>{\n    'osc': False,\n    'host': '127.0.0.1',\n    'client': '127.0.0.1',\n    'client_name': 'tolvera',\n    'receive_port': 5001,\n    'send_port': 5000,\n    'osc_debug': False,\n}\n</code></pre>"},{"location":"examples/#osc-output-api","title":"OSC output API","text":"<p>TBC.</p>"},{"location":"examples/#adding-custom-behaviour-with-tiachi-kernels","title":"Adding custom behaviour with Tiachi kernels","text":"<p>We can use Taichi kernels and functions in T\u00f6lvera to add custom behaviours. In this example we add an attractor kernel, and draw it with <code>tv.px.circle</code>:</p> <pre><code>from tolvera import Tolvera\nimport taichi as ti\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @ti.kernel\n    def attract(tv: ti.template(), pos: ti.math.vec2, mass: ti.f32, radius: ti.f32):\n        for i in range(tv.p.n):\n            p = tv.p.field[i]\n            if p.active == 0: continue\n            target_distance = (pos-p.pos).norm()\n            if target_distance &lt; radius:\n                factor = (radius-target_distance)/radius\n                tv.p.field[i].vel += (pos-p.pos).normalized() * mass * factor\n        tv.px.circle(pos[0], pos[1], radius, [1.,1.,1.,1.])\n\n    @tv.render\n    def _():\n        tv.v.move(tv.p)\n        attract(tv, [tv.x/2, tv.y/2], 10., 300.)\n</code></pre>"},{"location":"examples/#live-coding-with-sardine","title":"Live Coding with Sardine","text":"<p>Sardine is a Python-based live coding environment which can be used to live code T\u00f6lvera (currently tested in Visual Studio Code only):</p> <pre><code>from sardine_core.run import *\nfrom tolvera import Tolvera\n\ndef main(**kwargs):\n    tv = Tolvera(**kwargs)\n\n    @ti.kernel\n    def attract(tv: ti.template(), pos: ti.math.vec2, mass: ti.f32, radius: ti.f32):\n        for i in range(tv.p.n):\n            p = tv.p.field[i]\n            if p.active == 0: continue\n            target_distance = (pos-p.pos).norm()\n            if target_distance &lt; radius:\n                factor = (radius-target_distance)/radius\n                tv.p.field[i].vel += (pos-p.pos).normalized() * mass * factor\n        tv.px.circle(pos[0], pos[1], radius, [1.,1.,1.,1.])\n    attract_kernel = attract # workaround for redefining kernels\n\n    # State that can be used inside Taichi scope\n    attract_state = tv.State({\n        'mass':   (0.,10.), #\u00a0name: (min, max)\n        'radius': (0.,1000.),\n    }, tv.o.species) # field shape is int -&gt; (int, int)\n\n    # Sardine @swim function running at control rate\n    @swim\n    def control(p=4, i=0):\n        attract_state.field[0,0].mass = P('1 1.2', i)\n        attract_state.field[0,0].radius = P('1900 100', i)\n        again(control, p=1/2, i=i+1)\n\n    # Sardine @swim function running at render rate\n    @swim\n    def render(p=0.5, i=0):\n        tv.v.move(tv.p)\n        attract_kernel(tv, \n            [tv.x/2, tv.y/2], \n            attract_state.field[0,0].mass, \n            attract_state.field[0,0].radius)\n        tv.show(tv.p) #\u00a0used instead of @tv.render\n        again(render, p=1/64, i=i+1)\n</code></pre> <p>Note that Sardine is not installed by T\u00f6lvera, and needs to be installed separately.</p>"},{"location":"examples/#interactive-machine-learning","title":"Interactive machine learning","text":""},{"location":"reference/tolvera/__init__/","title":"init","text":"<p>T\u00f6lvera: a library for exploring musical performance with artificial life and self-organising systems.</p>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera","title":"<code>Tolvera</code>","text":"<p>T\u00f6lvera class which contains all T\u00f6lvera components; Particles, Species, Vera, and Pixels. Multiple T\u00f6lvera instances share the same T\u00f6lveraContext.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>class Tolvera:\n    \"\"\"\n    T\u00f6lvera class which contains all T\u00f6lvera components;\n    Particles, Species, Vera, and Pixels.\n    Multiple T\u00f6lvera instances share the same T\u00f6lveraContext.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"\n        Initialise and setup T\u00f6lvera with given keyword arguments.\n\n        Args:\n            **kwargs: Keyword arguments for setup and initialisation.\n        \"\"\"\n        self.kwargs = kwargs\n        self.name = kwargs.get(\"name\", \"T\u00f6lvera\")\n        self.name_clean = clean_name(self.name)\n        if \"ctx\" not in kwargs:\n            self.init_context(**kwargs)\n        else:\n            self.share_context(kwargs[\"ctx\"])\n        self.setup(**kwargs)\n        print(f\"[{self.name}] Initialisation and setup complete.\")\n\n    def init_context(self, **kwargs):\n        \"\"\"Initiliase T\u00f6lveraContext with given keyword arguments.\n\n        Args:\n            **kwargs: Keyword arguments for T\u00f6lveraContext.\n        \"\"\"\n        context = TolveraContext(**kwargs)\n        self.share_context(context)\n\n    def share_context(self, context):\n        \"\"\"Share T\u00f6lveraContext with another T\u00f6lvera instance.\n\n        Args:\n            context: T\u00f6lveraContext to share.\n        \"\"\"\n        if len(context.get_names()) == 0:\n            print(f\"[{self.name}] Sharing context '{context.name}'.\")\n        else:\n            print(\n                f\"[{self.name}] Sharing context '{context.name}' with {context.get_names()}.\"\n            )\n        self.ctx = context\n        self.x = context.x\n        self.y = context.y\n        self.ti = context.ti\n        self.show = context.show\n        self.canvas = context.canvas\n        self.osc = context.osc\n        self.iml = context.iml\n        self.render = context.render\n        self.cleanup = context.cleanup\n        self.cv = context.cv\n\n    def setup(self, **kwargs):\n        \"\"\"\n        Setup T\u00f6lvera with given keyword arguments.\n        This can be called multiple throughout the lifetime of a T\u00f6lvera instance.\n\n        Args:\n            **kwargs: Keyword arguments for setup.\n                speed (float): Global timebase speed.\n                particles (int): Number of particles.\n                species (int): Number of species.\n                substep (int): Number of substeps per frame.\n                see also kwargs for Pixels, Species, Particles, and Vera.\n        \"\"\"\n        self._speed = kwargs.get(\"speed\", 1)  # global timebase\n        self.particles = kwargs.get(\"particles\", 1024)\n        self.species = kwargs.get(\"species\", 4)\n        self.pn = self.particles\n        self.sn = self.species\n        self.p_per_s = self.particles // self.species\n        self.substep = kwargs.get(\"substep\", 1)\n        self.s = StateDict(self)\n        self.px = Pixels(self, **kwargs)\n        self._species = Species(self, **kwargs)\n        self.p = Particles(self, **kwargs)\n        self.v = Vera(self, **kwargs)\n        if self.osc is not False:\n            self.add_to_osc_map()\n        self.ctx.add(self)\n        print(f\"[{self.name}] Setup complete.\")\n\n    def randomise(self):\n        \"\"\"\n        Randomise particles, species, and Vera.\n        \"\"\"\n        self.p.randomise()\n        self.s.species.randomise()\n        self.v.randomise()\n\n    def reset(self, **kwargs):\n        \"\"\"\n        Reset T\u00f6lvera with given keyword arguments.\n        This will call setup() with given keyword arguments, but not init().\n\n        Args:\n            **kwargs: Keyword arguments for reset.\n        \"\"\"\n        print(f\"[{self.name}] Resetting self with kwargs={kwargs}...\")\n        if kwargs is not None:\n            self.kwargs = kwargs\n        self.setup()\n\n    def speed(self, speed: float = None):\n        \"\"\"Set or get global timebase speed.\"\"\"\n        if speed is not None:\n            self._speed = speed\n            self.p.speed(speed)\n        return self._speed\n\n    def add_to_osc_map(self):\n        \"\"\"\n        Add top-level T\u00f6lvera functions to OSCMap.\n        \"\"\"\n        setter_name = f\"{self.name_clean}_set\"\n        getter_name = f\"{self.name_clean}_get\"\n        self.osc.map.receive_args_inline(setter_name + \"_randomise\", self.randomise)\n        # self.osc.map.receive_args_inline(setter_name+'_reset', self.reset) # TODO: kwargs?\n        self.osc.map.receive_args_inline(\n            setter_name + \"_particles_randomise\", self.p._randomise\n        )  # TODO: move inside Particles\n\n        @self.osc.map.receive_args(speed=(1, 0, 100), count=1)\n        def tolvera_set_speed(speed: float):\n            \"\"\"Set global timebase speed.\"\"\"\n            self.speed(speed)\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialise and setup T\u00f6lvera with given keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for setup and initialisation.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"\n    Initialise and setup T\u00f6lvera with given keyword arguments.\n\n    Args:\n        **kwargs: Keyword arguments for setup and initialisation.\n    \"\"\"\n    self.kwargs = kwargs\n    self.name = kwargs.get(\"name\", \"T\u00f6lvera\")\n    self.name_clean = clean_name(self.name)\n    if \"ctx\" not in kwargs:\n        self.init_context(**kwargs)\n    else:\n        self.share_context(kwargs[\"ctx\"])\n    self.setup(**kwargs)\n    print(f\"[{self.name}] Initialisation and setup complete.\")\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.add_to_osc_map","title":"<code>add_to_osc_map()</code>","text":"<p>Add top-level T\u00f6lvera functions to OSCMap.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def add_to_osc_map(self):\n    \"\"\"\n    Add top-level T\u00f6lvera functions to OSCMap.\n    \"\"\"\n    setter_name = f\"{self.name_clean}_set\"\n    getter_name = f\"{self.name_clean}_get\"\n    self.osc.map.receive_args_inline(setter_name + \"_randomise\", self.randomise)\n    # self.osc.map.receive_args_inline(setter_name+'_reset', self.reset) # TODO: kwargs?\n    self.osc.map.receive_args_inline(\n        setter_name + \"_particles_randomise\", self.p._randomise\n    )  # TODO: move inside Particles\n\n    @self.osc.map.receive_args(speed=(1, 0, 100), count=1)\n    def tolvera_set_speed(speed: float):\n        \"\"\"Set global timebase speed.\"\"\"\n        self.speed(speed)\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.init_context","title":"<code>init_context(**kwargs)</code>","text":"<p>Initiliase T\u00f6lveraContext with given keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for T\u00f6lveraContext.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def init_context(self, **kwargs):\n    \"\"\"Initiliase T\u00f6lveraContext with given keyword arguments.\n\n    Args:\n        **kwargs: Keyword arguments for T\u00f6lveraContext.\n    \"\"\"\n    context = TolveraContext(**kwargs)\n    self.share_context(context)\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.randomise","title":"<code>randomise()</code>","text":"<p>Randomise particles, species, and Vera.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def randomise(self):\n    \"\"\"\n    Randomise particles, species, and Vera.\n    \"\"\"\n    self.p.randomise()\n    self.s.species.randomise()\n    self.v.randomise()\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.reset","title":"<code>reset(**kwargs)</code>","text":"<p>Reset T\u00f6lvera with given keyword arguments. This will call setup() with given keyword arguments, but not init().</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for reset.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def reset(self, **kwargs):\n    \"\"\"\n    Reset T\u00f6lvera with given keyword arguments.\n    This will call setup() with given keyword arguments, but not init().\n\n    Args:\n        **kwargs: Keyword arguments for reset.\n    \"\"\"\n    print(f\"[{self.name}] Resetting self with kwargs={kwargs}...\")\n    if kwargs is not None:\n        self.kwargs = kwargs\n    self.setup()\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.setup","title":"<code>setup(**kwargs)</code>","text":"<p>Setup T\u00f6lvera with given keyword arguments. This can be called multiple throughout the lifetime of a T\u00f6lvera instance.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for setup. speed (float): Global timebase speed. particles (int): Number of particles. species (int): Number of species. substep (int): Number of substeps per frame. see also kwargs for Pixels, Species, Particles, and Vera.</p> <code>{}</code> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def setup(self, **kwargs):\n    \"\"\"\n    Setup T\u00f6lvera with given keyword arguments.\n    This can be called multiple throughout the lifetime of a T\u00f6lvera instance.\n\n    Args:\n        **kwargs: Keyword arguments for setup.\n            speed (float): Global timebase speed.\n            particles (int): Number of particles.\n            species (int): Number of species.\n            substep (int): Number of substeps per frame.\n            see also kwargs for Pixels, Species, Particles, and Vera.\n    \"\"\"\n    self._speed = kwargs.get(\"speed\", 1)  # global timebase\n    self.particles = kwargs.get(\"particles\", 1024)\n    self.species = kwargs.get(\"species\", 4)\n    self.pn = self.particles\n    self.sn = self.species\n    self.p_per_s = self.particles // self.species\n    self.substep = kwargs.get(\"substep\", 1)\n    self.s = StateDict(self)\n    self.px = Pixels(self, **kwargs)\n    self._species = Species(self, **kwargs)\n    self.p = Particles(self, **kwargs)\n    self.v = Vera(self, **kwargs)\n    if self.osc is not False:\n        self.add_to_osc_map()\n    self.ctx.add(self)\n    print(f\"[{self.name}] Setup complete.\")\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.share_context","title":"<code>share_context(context)</code>","text":"<p>Share T\u00f6lveraContext with another T\u00f6lvera instance.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <p>T\u00f6lveraContext to share.</p> required Source code in <code>src/tolvera/__init__.py</code> <pre><code>def share_context(self, context):\n    \"\"\"Share T\u00f6lveraContext with another T\u00f6lvera instance.\n\n    Args:\n        context: T\u00f6lveraContext to share.\n    \"\"\"\n    if len(context.get_names()) == 0:\n        print(f\"[{self.name}] Sharing context '{context.name}'.\")\n    else:\n        print(\n            f\"[{self.name}] Sharing context '{context.name}' with {context.get_names()}.\"\n        )\n    self.ctx = context\n    self.x = context.x\n    self.y = context.y\n    self.ti = context.ti\n    self.show = context.show\n    self.canvas = context.canvas\n    self.osc = context.osc\n    self.iml = context.iml\n    self.render = context.render\n    self.cleanup = context.cleanup\n    self.cv = context.cv\n</code></pre>"},{"location":"reference/tolvera/__init__/#tolvera.Tolvera.speed","title":"<code>speed(speed=None)</code>","text":"<p>Set or get global timebase speed.</p> Source code in <code>src/tolvera/__init__.py</code> <pre><code>def speed(self, speed: float = None):\n    \"\"\"Set or get global timebase speed.\"\"\"\n    if speed is not None:\n        self._speed = speed\n        self.p.speed(speed)\n    return self._speed\n</code></pre>"},{"location":"reference/tolvera/_taichi/","title":"taichi","text":""},{"location":"reference/tolvera/context/","title":"Context","text":"<p>T\u00f6lvera context for sharing between multiple T\u00f6lvera instances.</p>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext","title":"<code>TolveraContext</code>","text":"<p>Context for sharing between multiple T\u00f6lvera instances. Context includes Taichi, OSC, IML and CV. All T\u00f6lvera instances share the same context and are added to a dict.</p> Source code in <code>src/tolvera/context.py</code> <pre><code>class TolveraContext:\n    \"\"\"\n    Context for sharing between multiple T\u00f6lvera instances.\n    Context includes Taichi, OSC, IML and CV.\n    All T\u00f6lvera instances share the same context and are added to a dict.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"Initialise T\u00f6lvera context with given keyword arguments.\"\"\"\n        self.kwargs = kwargs\n        self.init(**kwargs)\n\n    def init(self, **kwargs):\n        \"\"\"\n        Initialise wrapped external packages with given keyword arguments.\n        This only happens once when T\u00f6lvera is first initialised.\n\n        Args:\n            **kwargs: Keyword arguments for component initialisation.\n                x (int): Width of canvas.\n                y (int): Height of canvas.\n                osc (bool): Enable OSC.\n                iml (bool): Enable IML.\n                cv (bool): Enable CV.\n                see also kwargs for Taichi, OSC, IMLDict, and CV.\n        \"\"\"\n        self.name = \"T\u00f6lvera Context\"\n        self.name_clean = clean_name(self.name)\n        print(f\"[{self.name}] Initializing context...\")\n        self.i = 0\n        self.x = kwargs.get(\"x\", 1920)\n        self.y = kwargs.get(\"y\", 1080)\n        self.ti = Taichi(self, **kwargs)\n        self.show = self.ti.show\n        self.canvas = Pixels(self, **kwargs)\n        self.osc = kwargs.get(\"osc\", False)\n        self.iml = kwargs.get(\"iml\", False)\n        self.cv = kwargs.get(\"cv\", False)\n        if self.osc:\n            self.osc = OSC(self, **kwargs)\n        if self.iml:\n            self.iml = IMLDict(self)\n        if self.cv:\n            self.cv = CV(self, **kwargs)\n        self._cleanup_fns = []\n        self.tolveras = {}\n        print(f\"[{self.name}] Context initialisation complete.\")\n\n    def run(self, f=None, **kwargs):\n        \"\"\"\n        Run T\u00f6lvera with given render function and keyword arguments.\n        This function will run inside a locked thread until KeyboardInterrupt/exit.\n        It runs the render function, updates the OSC map (if enabled), and shows the pixels.\n\n        Args:\n            f: Function to run.\n            **kwargs: Keyword arguments for function.\n        \"\"\"\n        if f is not None:\n            print(f\"[{self.name}] Running with render function {f.__name__}...\")\n        else:\n            print(f\"[{self.name}] Running with no render function...\")\n        while self.ti.window.running:\n            with _lock:\n                if f is not None:\n                    self.canvas = f(**kwargs)\n                if self.osc is not False:\n                    self.osc.map()\n                if self.iml is not False:\n                    self.iml()\n                if self.cv is not False:\n                    self.cv()\n                self.ti.show(self.canvas)\n                self.i += 1\n\n    def stop(self):\n        \"\"\"\n        Run cleanup functions and exit.\n        \"\"\"\n        print(f\"\\n[{self.name}] Stopping {self.name}...\")\n        for f in self._cleanup_fns:\n            print(f\"\\n[{self.name}] Running cleanup function {f.__name__}...\")\n            f()\n        print(f\"\\n[{self.name}] Exiting {self.name}...\")\n        exit(0)\n\n    def render(self, f=None, **kwargs):\n        \"\"\"Render T\u00f6lvera with given function and keyword arguments.\n\n        Args:\n            f (function, optional): Function to run. Defaults to None.\n        \"\"\"\n        try:\n            self.run(f, **kwargs)\n        except KeyboardInterrupt:\n            self.stop()\n\n    def cleanup(self, f=None):\n        \"\"\"\n        Decorator for cleanup functions based on iipyper.\n        Make functions run on KeyBoardInterrupt (before exit).\n        Cleanup functions must be defined before render is called!\n\n        Args:\n            f: Function to cleanup.\n\n        Returns:\n            Decorator function if f is None, else decorated function.\n        \"\"\"\n        print(f\"\\n[{self.name}] Adding cleanup function {f.__name__}...\")\n\n        def decorator(f):\n            \"\"\"Decorator that appends function to cleanup functions.\"\"\"\n            self._cleanup_fns.append(f)\n            return f\n\n        if f is None:  # return a decorator\n            return decorator\n        else:  # bare decorator case; return decorated function\n            return decorator(f)\n\n    def add(self, tolvera):\n        \"\"\"\n        Add T\u00f6lvera to context.\n\n        Args:\n            tolvera (Tolvera): T\u00f6lvera to add.\n        \"\"\"\n        print(f\"[{self.name}] Adding tolvera='{tolvera.name}' to context.\")\n        self.tolveras[tolvera.name] = tolvera\n\n    def get_by_name(self, name):\n        \"\"\"\n        Get T\u00f6lvera by name.\n\n        Args:\n            name (str): Name of T\u00f6lvera to get.\n\n        Returns:\n            T\u00f6lvera: T\u00f6lvera with given name.\n        \"\"\"\n        return self.tolveras[name]\n\n    def get_names(self):\n        \"\"\"\n        Get names of all T\u00f6lveras in context.\n\n        Returns:\n            list: List of T\u00f6lvera names.\n        \"\"\"\n        return list(self.tolveras.keys())\n\n    def remove(self, name):\n        \"\"\"\n        Remove T\u00f6lvera by name.\n\n        Args:\n            name (str): Name of T\u00f6lvera to delete.\n        \"\"\"\n        print(f\"[{self.name}] Deleting tolvera='{name}' from context.\")\n        del self.tolveras[name]\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Initialise T\u00f6lvera context with given keyword arguments.</p> Source code in <code>src/tolvera/context.py</code> <pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"Initialise T\u00f6lvera context with given keyword arguments.\"\"\"\n    self.kwargs = kwargs\n    self.init(**kwargs)\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.add","title":"<code>add(tolvera)</code>","text":"<p>Add T\u00f6lvera to context.</p> <p>Parameters:</p> Name Type Description Default <code>tolvera</code> <code>Tolvera</code> <p>T\u00f6lvera to add.</p> required Source code in <code>src/tolvera/context.py</code> <pre><code>def add(self, tolvera):\n    \"\"\"\n    Add T\u00f6lvera to context.\n\n    Args:\n        tolvera (Tolvera): T\u00f6lvera to add.\n    \"\"\"\n    print(f\"[{self.name}] Adding tolvera='{tolvera.name}' to context.\")\n    self.tolveras[tolvera.name] = tolvera\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.cleanup","title":"<code>cleanup(f=None)</code>","text":"<p>Decorator for cleanup functions based on iipyper. Make functions run on KeyBoardInterrupt (before exit). Cleanup functions must be defined before render is called!</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>Function to cleanup.</p> <code>None</code> <p>Returns:</p> Type Description <p>Decorator function if f is None, else decorated function.</p> Source code in <code>src/tolvera/context.py</code> <pre><code>def cleanup(self, f=None):\n    \"\"\"\n    Decorator for cleanup functions based on iipyper.\n    Make functions run on KeyBoardInterrupt (before exit).\n    Cleanup functions must be defined before render is called!\n\n    Args:\n        f: Function to cleanup.\n\n    Returns:\n        Decorator function if f is None, else decorated function.\n    \"\"\"\n    print(f\"\\n[{self.name}] Adding cleanup function {f.__name__}...\")\n\n    def decorator(f):\n        \"\"\"Decorator that appends function to cleanup functions.\"\"\"\n        self._cleanup_fns.append(f)\n        return f\n\n    if f is None:  # return a decorator\n        return decorator\n    else:  # bare decorator case; return decorated function\n        return decorator(f)\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.get_by_name","title":"<code>get_by_name(name)</code>","text":"<p>Get T\u00f6lvera by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of T\u00f6lvera to get.</p> required <p>Returns:</p> Name Type Description <code>T\u00f6lvera</code> <p>T\u00f6lvera with given name.</p> Source code in <code>src/tolvera/context.py</code> <pre><code>def get_by_name(self, name):\n    \"\"\"\n    Get T\u00f6lvera by name.\n\n    Args:\n        name (str): Name of T\u00f6lvera to get.\n\n    Returns:\n        T\u00f6lvera: T\u00f6lvera with given name.\n    \"\"\"\n    return self.tolveras[name]\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.get_names","title":"<code>get_names()</code>","text":"<p>Get names of all T\u00f6lveras in context.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>List of T\u00f6lvera names.</p> Source code in <code>src/tolvera/context.py</code> <pre><code>def get_names(self):\n    \"\"\"\n    Get names of all T\u00f6lveras in context.\n\n    Returns:\n        list: List of T\u00f6lvera names.\n    \"\"\"\n    return list(self.tolveras.keys())\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.init","title":"<code>init(**kwargs)</code>","text":"<p>Initialise wrapped external packages with given keyword arguments. This only happens once when T\u00f6lvera is first initialised.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for component initialisation. x (int): Width of canvas. y (int): Height of canvas. osc (bool): Enable OSC. iml (bool): Enable IML. cv (bool): Enable CV. see also kwargs for Taichi, OSC, IMLDict, and CV.</p> <code>{}</code> Source code in <code>src/tolvera/context.py</code> <pre><code>def init(self, **kwargs):\n    \"\"\"\n    Initialise wrapped external packages with given keyword arguments.\n    This only happens once when T\u00f6lvera is first initialised.\n\n    Args:\n        **kwargs: Keyword arguments for component initialisation.\n            x (int): Width of canvas.\n            y (int): Height of canvas.\n            osc (bool): Enable OSC.\n            iml (bool): Enable IML.\n            cv (bool): Enable CV.\n            see also kwargs for Taichi, OSC, IMLDict, and CV.\n    \"\"\"\n    self.name = \"T\u00f6lvera Context\"\n    self.name_clean = clean_name(self.name)\n    print(f\"[{self.name}] Initializing context...\")\n    self.i = 0\n    self.x = kwargs.get(\"x\", 1920)\n    self.y = kwargs.get(\"y\", 1080)\n    self.ti = Taichi(self, **kwargs)\n    self.show = self.ti.show\n    self.canvas = Pixels(self, **kwargs)\n    self.osc = kwargs.get(\"osc\", False)\n    self.iml = kwargs.get(\"iml\", False)\n    self.cv = kwargs.get(\"cv\", False)\n    if self.osc:\n        self.osc = OSC(self, **kwargs)\n    if self.iml:\n        self.iml = IMLDict(self)\n    if self.cv:\n        self.cv = CV(self, **kwargs)\n    self._cleanup_fns = []\n    self.tolveras = {}\n    print(f\"[{self.name}] Context initialisation complete.\")\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.remove","title":"<code>remove(name)</code>","text":"<p>Remove T\u00f6lvera by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of T\u00f6lvera to delete.</p> required Source code in <code>src/tolvera/context.py</code> <pre><code>def remove(self, name):\n    \"\"\"\n    Remove T\u00f6lvera by name.\n\n    Args:\n        name (str): Name of T\u00f6lvera to delete.\n    \"\"\"\n    print(f\"[{self.name}] Deleting tolvera='{name}' from context.\")\n    del self.tolveras[name]\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.render","title":"<code>render(f=None, **kwargs)</code>","text":"<p>Render T\u00f6lvera with given function and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>function</code> <p>Function to run. Defaults to None.</p> <code>None</code> Source code in <code>src/tolvera/context.py</code> <pre><code>def render(self, f=None, **kwargs):\n    \"\"\"Render T\u00f6lvera with given function and keyword arguments.\n\n    Args:\n        f (function, optional): Function to run. Defaults to None.\n    \"\"\"\n    try:\n        self.run(f, **kwargs)\n    except KeyboardInterrupt:\n        self.stop()\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.run","title":"<code>run(f=None, **kwargs)</code>","text":"<p>Run T\u00f6lvera with given render function and keyword arguments. This function will run inside a locked thread until KeyboardInterrupt/exit. It runs the render function, updates the OSC map (if enabled), and shows the pixels.</p> <p>Parameters:</p> Name Type Description Default <code>f</code> <p>Function to run.</p> <code>None</code> <code>**kwargs</code> <p>Keyword arguments for function.</p> <code>{}</code> Source code in <code>src/tolvera/context.py</code> <pre><code>def run(self, f=None, **kwargs):\n    \"\"\"\n    Run T\u00f6lvera with given render function and keyword arguments.\n    This function will run inside a locked thread until KeyboardInterrupt/exit.\n    It runs the render function, updates the OSC map (if enabled), and shows the pixels.\n\n    Args:\n        f: Function to run.\n        **kwargs: Keyword arguments for function.\n    \"\"\"\n    if f is not None:\n        print(f\"[{self.name}] Running with render function {f.__name__}...\")\n    else:\n        print(f\"[{self.name}] Running with no render function...\")\n    while self.ti.window.running:\n        with _lock:\n            if f is not None:\n                self.canvas = f(**kwargs)\n            if self.osc is not False:\n                self.osc.map()\n            if self.iml is not False:\n                self.iml()\n            if self.cv is not False:\n                self.cv()\n            self.ti.show(self.canvas)\n            self.i += 1\n</code></pre>"},{"location":"reference/tolvera/context/#tolvera.context.TolveraContext.stop","title":"<code>stop()</code>","text":"<p>Run cleanup functions and exit.</p> Source code in <code>src/tolvera/context.py</code> <pre><code>def stop(self):\n    \"\"\"\n    Run cleanup functions and exit.\n    \"\"\"\n    print(f\"\\n[{self.name}] Stopping {self.name}...\")\n    for f in self._cleanup_fns:\n        print(f\"\\n[{self.name}] Running cleanup function {f.__name__}...\")\n        f()\n    print(f\"\\n[{self.name}] Exiting {self.name}...\")\n    exit(0)\n</code></pre>"},{"location":"reference/tolvera/cv/","title":"Cv","text":""},{"location":"reference/tolvera/iml/","title":"Iml","text":""},{"location":"reference/tolvera/iml/#tolvera.iml.IMLBase","title":"<code>IMLBase</code>","text":"<p>             Bases: <code>IML</code></p> <p>IML mapping base class</p> <p>Parameters:</p> Name Type Description Default <code>tolvera</code> <p>Tolvera instance.</p> required <code>kwargs</code> <p>size (tuple, required): (input, output) sizes. io (tuple, optional): (input, output) functions. config (dict, optional): {embed_input, embed_output, interpolate, index, verbose}. updater (cls, optional): See iipyper.osc.update (Updater, OSCUpdater, ...). update_rate (int, optional): Updater's update rate (defaults to 1). randomise (bool, optional): Randomise mapping on init (defaults to False). rand_pairs (int, optional): Number of random pairs to add (defaults to 32). rand_input_weight (Any, optional): Random input weight (defaults to None). rand_output_weight (Any, optional): Random output weight (defaults to None). rand_method (str, optional): rand_method type (see utils). rand_kw (dict, optional): Random kwargs to pass to rand_method (see utils). map_kw (dict, optional): kwargs to use in IML.map(). infun_kw (dict, optional): kwargs to use in infun() (type 'Fun2' only). outfun_kw (dict, optional): kwargs to use in outfun() (type '2Fun' only). lag (bool, optional): Lag mapped data (defaults to False). Incompatible with '*2Fun' types. lag_coef (float, optional): Lag coefficient (defaults to 0.5 if <code>lag</code> is True).</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLBase(iiIML):\n    \"\"\"IML mapping base class\n\n    Args:\n        tolvera: Tolvera instance.\n        kwargs:\n            size (tuple, required): (input, output) sizes.\n            io (tuple, optional): (input, output) functions.\n            config (dict, optional): {embed_input, embed_output, interpolate, index, verbose}.\n            updater (cls, optional): See iipyper.osc.update (Updater, OSCUpdater, ...).\n            update_rate (int, optional): Updater's update rate (defaults to 1).\n            randomise (bool, optional): Randomise mapping on init (defaults to False).\n            rand_pairs (int, optional): Number of random pairs to add (defaults to 32).\n            rand_input_weight (Any, optional): Random input weight (defaults to None).\n            rand_output_weight (Any, optional): Random output weight (defaults to None).\n            rand_method (str, optional): rand_method type (see utils).\n            rand_kw (dict, optional): Random kwargs to pass to rand_method (see utils).\n            map_kw (dict, optional): kwargs to use in IML.map().\n            infun_kw (dict, optional): kwargs to use in infun() (type 'Fun2*' only).\n            outfun_kw (dict, optional): kwargs to use in outfun() (type '*2Fun' only).\n            lag (bool, optional): Lag mapped data (defaults to False). Incompatible with '*2Fun' types.\n            lag_coef (float, optional): Lag coefficient (defaults to 0.5 if `lag` is True).\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        assert \"size\" in kwargs, f\"IMLBase requires 'size' kwarg.\"\n        self.size = kwargs[\"size\"]\n        self.updater = kwargs.get(\n            \"updater\", Updater(self.update, kwargs.get(\"update_rate\", 1))\n        )\n        self.config = kwargs.get(\"config\", {})\n        if isinstance(self.size[0], tuple):\n            self.config[\"embed_input\"] = \"ProjectAndSort\"\n        print(f\"[tolvera._iml.IMLBase] Initialising IML with config: {self.config}\")\n        super().__init__(**self.config)\n        self.data = dotdict()\n        self.map_kw = kwargs.get(\"map_kw\", {})\n        self.infun_kw = kwargs.get(\"infun_kw\", {})\n        self.outfun_kw = kwargs.get(\"outfun_kw\", {})\n        randomise = kwargs.get(\"randomise\", False)\n        if randomise:\n            self.rand_pairs = kwargs.get(\"rand_pairs\", 32)\n            self.rand_input_weight = kwargs.get(\"rand_input_weight\", None)\n            self.rand_output_weight = kwargs.get(\"rand_output_weight\", None)\n            self.rand_method = kwargs.get(\"rand_method\", \"rand\")\n            self.rand_kw = kwargs.get(\"rand_kw\", {})\n            self.randomise(\n                self.rand_pairs,\n                self.rand_input_weight,\n                self.rand_output_weight,\n                self.rand_method,\n                **self.rand_kw,\n            )\n        self.lag = kwargs.get(\"lag\", False)\n        if self.lag:\n            self.lag_coef = kwargs.get(\"lag_coef\", 0.5)\n            self.lag = Lag(coef=self.lag_coef)\n            print(\n                f\"[tolvera._iml.IMLBase] Lagging mapped data with coef {self.lag_coef}.\"\n            )\n\n    def randomise(\n        self,\n        times: int,\n        input_weight=None,\n        output_weight=None,\n        method: str = \"rand\",\n        **kwargs,\n    ):\n        self.rand = rand_select(method)\n        while len(self.pairs) &lt; times:\n            self.add_random_pair(input_weight, output_weight, **kwargs)\n\n    def set_random_method(self, method: str = \"rand\"):\n        self.rand = rand_select(method)\n\n    def add_random_pair(self, input_weight=None, output_weight=None, **kwargs):\n        indata, outdata = self.create_random_pair(input_weight, output_weight, **kwargs)\n        self.add(indata, outdata)\n\n    def create_random_pair(self, input_weight=None, output_weight=None, **kwargs):\n        if self.rand == None and \"rand_method\" not in kwargs:\n            print(f\"[tolvera._iml.IMLBase] No 'rand' method set. Using 'rand'.\")\n            self.set_random_method()\n        elif \"rand_method\" in kwargs:\n            self.set_random_method(kwargs[\"rand_method\"])\n        if input_weight is None:\n            input_weight = self.rand_input_weight\n        if output_weight is None:\n            output_weight = self.rand_output_weight\n        indata = self.rand(self.size[0], **kwargs)\n        outdata = self.rand(self.size[1], **kwargs)\n        if input_weight is not None:\n            if isinstance(input_weight, np.ndarray):\n                indata *= torch.from_numpy(input_weight)\n            elif isinstance(input_weight, (torch.Tensor, float, int)):\n                indata *= input_weight\n            elif isinstance(input_weight, list):\n                indata *= torch.Tensor(input_weight)\n            else:\n                raise ValueError(\n                    f\"[tolvera._iml.IMLBase] Invalid input_weight type '{type(input_weight)}'.\"\n                )\n        if output_weight is not None:\n            if isinstance(output_weight, np.ndarray):\n                outdata *= torch.from_numpy(output_weight)\n            elif isinstance(output_weight, (torch.Tensor, float, int)):\n                outdata *= output_weight\n            elif isinstance(output_weight, list):\n                outdata *= torch.Tensor(output_weight)\n            else:\n                raise ValueError(\n                    f\"[tolvera._iml.IMLBase] Invalid output_weight type '{type(output_weight)}'.\"\n                )\n        return indata, outdata\n\n    def remove_oldest(self, n: int = 1):\n        if len(self.pairs) &gt; n - 1:\n            [self.remove(min(self.pairs.keys())) for _ in range(n)]\n\n    def remove_newest(self, n: int = 1):\n        if len(self.pairs) &gt; n - 1:\n            [self.remove(max(self.pairs.keys())) for _ in range(n)]\n\n    def remove_random(self, n: int = 1):\n        if len(self.pairs) &gt; n - 1:\n            [self.remove(np.random.choice(list(self.pairs.keys()))) for _ in range(n)]\n\n    def lag_mapped_data(self, lag_coef: float = 0.5):\n        self.data.mapped = self.lag(self.data.mapped, lag_coef)\n\n    def update(self, invec):\n        if len(self.pairs) == 0:\n            return None\n        self.data.mapped = self.map(invec, **self.map_kw)\n        if hasattr(self, \"lag\") and type(self.lag) is Lag:\n            self.lag_mapped_data()\n        return self.data.mapped\n\n    def update_rate(self, rate: int = None):\n        if rate is not None:\n            self.updater.count = rate\n        return self.updater.count\n\n    def __call__(self, *args) -&gt; Any:\n        return self.updater(*args)\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLDict","title":"<code>IMLDict</code>","text":"<p>             Bases: <code>dotdict</code></p> <p>IML mapping dict</p> <p>TODO: remove tolvera dependency?</p> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLDict(dotdict):\n    \"\"\"IML mapping dict\n\n    TODO: remove tolvera dependency?\"\"\"\n\n    def __init__(self, tolvera) -&gt; None:\n        self.tv = tolvera\n        self.i = {}  # input vectors dict\n        self.o = {}  # output vectors dict\n\n    def set(self, name, kwargs: dict) -&gt; None:\n        try:\n            if name == \"tv\" and type(kwargs) is not dict and type(kwargs) is not tuple:\n                if name in self:\n                    raise ValueError(\n                        f\"[tolvera._iml.IMLDict] '{name}' cannot be replaced.\"\n                    )\n                self[name] = kwargs\n            elif name == \"i\" or name == \"o\":\n                if type(kwargs) is not dict:\n                    raise ValueError(\n                        f\"[tolvera._iml.IMLDict] '{name}' is a reserved dict.\"\n                    )\n                self[name] = kwargs\n            elif type(kwargs) is dict:\n                if \"type\" not in kwargs:\n                    raise ValueError(\n                        f\"[tolvera._iml.IMLDict] IMLDict requires 'type' key.\"\n                    )\n                return self.add(name, kwargs[\"type\"], **kwargs)\n            elif type(kwargs) is tuple:\n                # iml_type = kwargs[0] # TODO: which index is 'iml_type'?\n                # return self.add(name, iml_type, *kwargs)\n                raise NotImplementedError(\n                    f\"[tolvera._iml.IMLDict] set() with tuple not implemented yet.\"\n                )\n            else:\n                raise TypeError(\n                    f\"[tolvera._iml.IMLDict] set() requires dict|tuple, not {type(kwargs)}\"\n                )\n        except Exception as e:\n            raise type(e)(f\"[tolvera._iml.IMLDict] {e}\") from e\n\n    def __setattr__(self, __name: str, __value: Any) -&gt; None:\n        self.set(__name, __value)\n\n    def add(self, name, iml_type, **kwargs):\n        # TODO: should ^ be kwargs and not **kwargs?\n        # print(f\"[tolvera._iml.IMLDict] add({name}, {iml_type}, {kwargs})\")\n        match iml_type:\n            case \"vec2vec\":\n                ins = IMLVec2Vec(**kwargs)\n            case \"vec2fun\":\n                ins = IMLVec2Fun(**kwargs)\n            case \"vec2osc\":\n                ins = IMLVec2OSC(self.tv.osc.map, **kwargs)\n            case \"fun2vec\":\n                ins = IMLFun2Vec(**kwargs)\n            case \"fun2fun\":\n                ins = IMLFun2Fun(**kwargs)\n            case \"fun2osc\":\n                ins = IMLFun2OSC(self.tv.osc.map, **kwargs)\n            case \"osc2vec\":\n                ins = IMLOSC2Vec(self.tv.osc.map, **kwargs)\n            case \"osc2fun\":\n                ins = IMLOSC2Fun(self.tv.osc.map, **kwargs)\n            case \"osc2osc\":\n                ins = IMLOSC2OSC(self.tv.osc.map, **kwargs)\n            case _:\n                raise ValueError(\n                    f\"[tolvera._iml.IMLDict] Invalid IML_TYPE '{iml_type}'. Valid IML_TYPES: {IML_TYPES}.\"\n                )\n        self[name] = ins\n        self.o[name] = None\n        return ins\n\n    def __call__(self, name=None, *args: Any, **kwargs: Any) -&gt; Any:\n        if name is not None:\n            if name in self:\n                # OSC updaters are handled by tv.osc.map (OSCMap)\n                # TODO: Rethink this?\n                if \"OSC\" not in type(self[name]).__name__:\n                    return self[name](*args, **kwargs)\n            else:\n                raise ValueError(f\"[tolvera._iml.IMLDict] '{name}' not in dict.\")\n        else:\n            outvecs = {}\n            for iml in self:\n                if iml == \"tv\" or iml == \"i\" or iml == \"o\":\n                    continue\n                cls_name = type(self[iml]).__name__\n                if \"OSC\" in cls_name:\n                    continue\n                if \"Vec2\" in cls_name:\n                    if iml in self.i:\n                        invec = self.i[iml]\n                        outvecs[iml] = self[iml](invec, *args, **kwargs)\n                else:\n                    outvecs[iml] = self[iml](*args, **kwargs)\n            self.i.clear()\n            self.o.update(outvecs)\n            return self.o\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLFun2Fun","title":"<code>IMLFun2Fun</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML function to function mapping</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>io (tuple, required): (callable, callable) input and output functions. see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLFun2Fun(IMLBase):\n    \"\"\"IML function to function mapping\n\n    Args:\n        kwargs:\n            io (tuple, required): (callable, callable) input and output functions.\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        assert \"io\" in kwargs, f\"IMLFun2Fun requires 'io' kwarg.\"\n        assert callable(\n            kwargs[\"io\"][0]\n        ), f\"IMLFun2Fun requires 'io' kwarg to be (infun, outfun).\"\n        assert callable(\n            kwargs[\"io\"][1]\n        ), f\"IMLFun2Fun requires 'io' kwarg to be (infun, outfun).\"\n        self.infun = kwargs[\"io\"][0]\n        self.infun_params = inspect.signature(self.infun).parameters\n        self.outfun = kwargs[\"io\"][1]\n        self.outfun_params = inspect.signature(self.outfun).parameters\n        super().__init__(**kwargs)\n\n    def update(self):\n        if len(self.infun_params) &gt; 0:\n            invec = self.infun(**self.infun_kw)\n        else:\n            invec = self.infun()\n        mapped = self.map(invec, **self.map_kw)\n        self.data.mapped = self.outfun(mapped, **self.outfun_kw)\n        return self.data.mapped\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLFun2OSC","title":"<code>IMLFun2OSC</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML function to OSC mapping</p> <p>Parameters:</p> Name Type Description Default <code>osc_map</code> <code>(OSCMap, required)</code> <p>OSCMap instance.</p> required <code>kwargs</code> <p>see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLFun2OSC(IMLBase):\n    \"\"\"IML function to OSC mapping\n\n    Args:\n        osc_map (OSCMap, required): OSCMap instance.\n        kwargs:\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, osc_map, **kwargs) -&gt; None:\n        self.osc_map = osc_map\n        super().__init__(**kwargs)\n\n    def update(self, invec):\n        raise NotImplementedError(\n            f\"[tolvera._iml.IMLFun2OSC] update() not implemented.\"\n        )\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLFun2Vec","title":"<code>IMLFun2Vec</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML function to vector mapping</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>io (tuple, required): (callable, None) input function. see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLFun2Vec(IMLBase):\n    \"\"\"IML function to vector mapping\n\n    Args:\n        kwargs:\n            io (tuple, required): (callable, None) input function.\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        assert \"io\" in kwargs, f\"IMLFun2Vec requires 'io' kwarg.\"\n        assert callable(\n            kwargs[\"io\"][0]\n        ), f\"IMLFun2Vec requires 'io' kwarg to be (infun, None).\"\n        assert (\n            kwargs[\"io\"][1] is None\n        ), f\"IMLFun2Vec requires 'io' kwarg to be (infun, None).\"\n        self.infun = kwargs[\"io\"][0]\n        self.infun_params = inspect.signature(self.infun).parameters\n        super().__init__(**kwargs)\n\n    def update(self):\n        if len(self.infun_params) &gt; 0:\n            invec = self.infun(**self.infun_kw)\n        else:\n            invec = self.infun()\n        self.data.mapped = self.map(invec, **self.map_kw)\n        return self.data.mapped\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLOSC2Fun","title":"<code>IMLOSC2Fun</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML OSC to function mapping</p> <p>Parameters:</p> Name Type Description Default <code>osc_map</code> <code>(OSCMap, required)</code> <p>OSCMap instance.</p> required <code>kwargs</code> <p>see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLOSC2Fun(IMLBase):\n    \"\"\"IML OSC to function mapping\n\n    Args:\n        osc_map (OSCMap, required): OSCMap instance.\n        kwargs:\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, osc_map, **kwargs) -&gt; None:\n        self.osc_map = osc_map\n        super().__init__(**kwargs)\n\n    def update(self, invec):\n        raise NotImplementedError(\n            f\"[tolvera._iml.IMLOSC2Fun] update() not implemented.\"\n        )\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLOSC2OSC","title":"<code>IMLOSC2OSC</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML OSC to OSC mapping</p> <p>Parameters:</p> Name Type Description Default <code>osc_map</code> <code>(OSCMap, required)</code> <p>OSCMap instance.</p> required <code>kwargs</code> <p>see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLOSC2OSC(IMLBase):\n    \"\"\"IML OSC to OSC mapping\n\n    Args:\n        osc_map (OSCMap, required): OSCMap instance.\n        kwargs:\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, osc_map, **kwargs) -&gt; None:\n        self.osc_map = osc_map\n        super().__init__(**kwargs)\n\n    def update(self, invec):\n        \"\"\"\n        see iml.app.server.map?\n        \"\"\"\n        raise NotImplementedError(\n            f\"[tolvera._iml.IMLOSC2OSC] update() not implemented.\"\n        )\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLOSC2OSC.update","title":"<code>update(invec)</code>","text":"<p>see iml.app.server.map?</p> Source code in <code>src/tolvera/iml.py</code> <pre><code>def update(self, invec):\n    \"\"\"\n    see iml.app.server.map?\n    \"\"\"\n    raise NotImplementedError(\n        f\"[tolvera._iml.IMLOSC2OSC] update() not implemented.\"\n    )\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLOSC2Vec","title":"<code>IMLOSC2Vec</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML OSC to vector mapping</p> <p>Parameters:</p> Name Type Description Default <code>osc_map</code> <code>(OSCMap, required)</code> <p>OSCMap instance.</p> required <code>kwargs</code> <p>see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLOSC2Vec(IMLBase):\n    \"\"\"IML OSC to vector mapping\n\n    Args:\n        osc_map (OSCMap, required): OSCMap instance.\n        kwargs:\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, osc_map, **kwargs) -&gt; None:\n        self.osc_map = osc_map\n        super().__init__(**kwargs)\n\n    def update(self, invec):\n        raise NotImplementedError(\n            f\"[tolvera._iml.IMLOSC2Vec] update() not implemented.\"\n        )\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLVec2Fun","title":"<code>IMLVec2Fun</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML vector to function mapping</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>io (tuple, required): (None, callable) output function. see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLVec2Fun(IMLBase):\n    \"\"\"IML vector to function mapping\n\n    Args:\n        kwargs:\n            io (tuple, required): (None, callable) output function.\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        assert \"io\" in kwargs, f\"IMLVec2Fun requires 'io' kwarg.\"\n        assert (\n            kwargs[\"io\"][0] is None\n        ), f\"IMLVec2Fun requires 'io' kwarg to be (None, outfun).\"\n        assert callable(\n            kwargs[\"io\"][1]\n        ), f\"IMLVec2Fun requires 'io' kwarg to be (None, outfun).\"\n        self.outfun = kwargs[\"io\"][1]\n        super().__init__(**kwargs)\n\n    def update(self, invec):\n        mapped = self.map(invec, **self.map_kw)\n        self.data.mapped = self.outfun(mapped, **self.outfun_kw)\n        return self.data.mapped\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLVec2OSC","title":"<code>IMLVec2OSC</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML vector to OSC mapping</p> <p>Parameters:</p> Name Type Description Default <code>osc_map</code> <code>(OSCMap, required)</code> <p>OSCMap instance.</p> required <code>kwargs</code> <p>io (tuple, required): (None, str) output OSC route. see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLVec2OSC(IMLBase):\n    \"\"\"IML vector to OSC mapping\n\n    Args:\n        osc_map (OSCMap, required): OSCMap instance.\n        kwargs:\n            io (tuple, required): (None, str) output OSC route.\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, osc_map, **kwargs) -&gt; None:\n        self.osc_map = osc_map\n        \"\"\"\n        self.osc_map.add_somethingsomething(self.update)\n        kwargs['updater'] = OSCUpdater from self.osc_map\n        does OSCUpdater have args, kwargs?\n        \"\"\"\n        assert \"io\" in kwargs, f\"IMLVec2OSC requires 'io' kwarg.\"\n        assert (\n            kwargs[\"io\"][0] is None\n        ), f\"IMLVec2OSC requires 'io' kwarg to be (None, osc_route).\"\n        assert (\n            type(kwargs[\"io\"][1]) is str\n        ), f\"IMLVec2OSC requires 'io' kwarg to be (None, osc_route).\"\n        self.route = kwargs[\"io\"][1]\n        super().__init__(**kwargs)\n\n    def update(self, invec):\n        raise NotImplementedError(\n            f\"[tolvera._iml.IMLVec2OSC] update() not implemented.\"\n        )\n</code></pre>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLVec2OSC.osc_map","title":"<code>osc_map = osc_map</code>  <code>instance-attribute</code>","text":"<p>self.osc_map.add_somethingsomething(self.update) kwargs['updater'] = OSCUpdater from self.osc_map does OSCUpdater have args, kwargs?</p>"},{"location":"reference/tolvera/iml/#tolvera.iml.IMLVec2Vec","title":"<code>IMLVec2Vec</code>","text":"<p>             Bases: <code>IMLBase</code></p> <p>IML vector to vector mapping</p> <p>Parameters:</p> Name Type Description Default <code>kwargs</code> <p>see IMLBase kwargs.</p> <code>{}</code> Source code in <code>src/tolvera/iml.py</code> <pre><code>class IMLVec2Vec(IMLBase):\n    \"\"\"IML vector to vector mapping\n\n    Args:\n        kwargs:\n            see IMLBase kwargs.\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/","title":"Npndarray dict","text":""},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict","title":"<code>NpNdarrayDict</code>","text":"<p>A class that encapsulates a dictionary of NumPy ndarrays, each associated with a specific data type and a defined min-max range. It provides a structured and efficient way to manage and manipulate multidimensional arrays with constraints on their values.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>Dict[str, Dict[str, Union[ndarray, Any]]]</code> <p>A dictionary where each key represents an attribute,</p> <code>shape</code> <code>Tuple[int, int]</code> <p>The shape of the ndarrays, which is consistent across all attributes.</p> Example <p>state = NpNdarrayDict({         'i':  (np.int32, 2, 10),         'f':  (np.float32, 0., 1.),         'v2': (np_vec2, 0., 1.),         'v3': (np_vec3, 0., 1.),         'v4': (np_vec4, 0., 1.),     }, (2,2)) state.set_value('i', (0, 0), 5) print(state.get_value('i', (0, 0))) 5</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>class NpNdarrayDict:\n    \"\"\"\n    A class that encapsulates a dictionary of NumPy ndarrays, each associated with a specific data type and a defined min-max range.\n    It provides a structured and efficient way to manage and manipulate multidimensional arrays with constraints on their values.\n\n    Attributes:\n        data (Dict[str, Dict[str, Union[np.ndarray, Any]]]): A dictionary where each key represents an attribute,\n        and the value is another dictionary with keys 'array', 'min', and 'max', representing the ndarray,\n        its minimum value, and its maximum value, respectively.\n        shape (Tuple[int, int]): The shape of the ndarrays, which is consistent across all attributes.\n\n    Example:\n        &gt;&gt;&gt; state = NpNdarrayDict({\n                'i':  (np.int32, 2, 10),\n                'f':  (np.float32, 0., 1.),\n                'v2': (np_vec2, 0., 1.),\n                'v3': (np_vec3, 0., 1.),\n                'v4': (np_vec4, 0., 1.),\n            }, (2,2))\n        &gt;&gt;&gt; state.set_value('i', (0, 0), 5)\n        &gt;&gt;&gt; print(state.get_value('i', (0, 0)))\n        5\n    \"\"\"\n\n    def __init__(self, data_dict: dict[str, tuple[Any, Any, Any]], shape: tuple[int]):\n        \"\"\"\n        Initialize the State class.\n\n        Args:\n            data_dict: A dictionary where keys are attribute names and values are tuples\n                       of (dtype, min_value, max_value).\n            shape: The shape of the numpy arrays for each attribute.\n\n        \"\"\"\n        self.shape = shape\n        self.init(data_dict, shape)\n\n    def init(\n        self, data_dict: dict[str, tuple[Any, Any, Any]], shape: tuple[int]\n    ) -&gt; None:\n        self.dict = {}\n        self.data = {}\n        self.size = 0\n        for key, (dtype, min_val, max_val) in data_dict.items():\n            dshape = self.shape\n            length = 1\n            # handle np_vec2, np_vec3, np_vec4\n            if isinstance(dtype, np.ndarray):\n                dshape = dshape + dtype.shape\n                length = dtype.shape[0]\n                dtype = np.float32\n            self.dict[key] = {\n                \"dtype\": dtype,\n                \"min\": min_val,\n                \"max\": max_val,\n                \"length\": length,\n                \"shape\": dshape,\n                \"ndims\": len(dshape),\n            }\n            self.data[key] = np.zeros(dshape, dtype=dtype)\n            size = self.data[key].size\n            self.dict[key][\"size\"] = size\n            self.size += size\n\n    \"\"\"\n    to|from vec | list (iml)\n    \"\"\"\n\n    def from_vec(self, vec: list):\n        vec_start = 0\n        for key in self.data.keys():\n            attr_vec_size = self.dict[key][\"size\"]\n            attr_vec = vec[vec_start : vec_start + attr_vec_size]\n            self.attr_from_vec(key, attr_vec)\n            vec_start += attr_vec_size\n\n    def to_vec(self) -&gt; list:\n        vec = []\n        for key in self.data.keys():\n            vec += self.attr_to_vec(key).tolist()\n        return vec\n\n    def attr_from_vec(self, attr: str, vec: list):\n        if attr not in self.data:\n            raise KeyError(f\"Key {attr} not in {self.data.keys()}\")\n        attr_shape, attr_dtype = self.dict[attr][\"shape\"], self.dict[attr][\"dtype\"]\n        if len(vec) != np.prod(attr_shape):\n            raise ValueError(\n                f\"Length of vec {len(vec)} does not match the shape of {attr} {attr_shape}\"\n            )\n        nparr = np.array(vec, dtype=attr_dtype)\n        if len(attr_shape) &gt; 1:\n            nparr = np.reshape(nparr, attr_shape)\n        try:\n            self.data[attr] = nparr\n        except ValueError as e:\n            print(f\"ValueError occurred while setting {attr}: {e}\")\n            raise\n\n    def attr_to_vec(self, attr: str) -&gt; list:\n        if attr not in self.data:\n            raise KeyError(f\"Key {attr} not in {self.data.keys()}\")\n        vec = self.data[attr].flatten()\n        return vec\n\n    def slice_from_vec(\n        self, slice_args: Union[int, tuple[int, ...], slice], slice_vec: list\n    ):\n        # TODO: unique slice obj needed per key...\n        # slice_obj = create_safe_slice(slice_args)\n        raise NotImplementedError(f\"slice_from_vec()\")\n\n    def slice_to_vec(self, slice_args: Union[int, tuple[int, ...], slice]) -&gt; list:\n        # TODO: unique slice obj needed per key...\n        # vec = []\n        # for key in self.data.keys():\n        #     slice_obj = create_safe_slice(slice_args)\n        #     vec += self.attr_slice_to_vec(key, slice_obj)\n        # return vec\n        raise NotImplementedError(f\"slice_from_vec()\")\n\n    def attr_slice_from_vec(\n        self, attr: str, slice_args: Union[int, tuple[int, ...], slice], slice_vec: list\n    ):\n        if attr not in self.data:\n            raise KeyError(f\"Key {attr} not in {self.data.keys()}\")\n        slice_obj = create_safe_slice(slice_args)\n        attr_shape, attr_dtype = self.dict[attr][\"shape\"], self.dict[attr][\"dtype\"]\n        nparr = np.array(slice_vec, dtype=attr_dtype)\n        if len(attr_shape) &gt; 1:\n            nparr = np.reshape(nparr, attr_shape)\n        try:\n            self.data[attr][slice_obj] = nparr\n        except ValueError as e:\n            print(f\"ValueError occurred while setting slice: {e}\")\n            raise\n\n    def attr_slice_to_vec(\n        self, attr: str, slice_args: Union[int, tuple[int, ...], slice]\n    ) -&gt; list:\n        if attr not in self.data:\n            raise KeyError(f\"Key {attr} not in {self.data.keys()}\")\n        slice_obj = create_safe_slice(slice_args)\n        vec = self.data[attr][slice_obj].flatten()\n        return vec\n\n    \"\"\"\n    vec slice helpers\n    \"\"\"\n\n    def get_slice_size(self, slice_args: Union[int, tuple[int, ...], slice]) -&gt; int:\n        slice_obj = create_safe_slice(slice_args)\n        return np.sum([self.data[key][slice_obj].size for key in self.data.keys()])\n\n    def get_attr_slice_size(\n        self, attr: str, slice_args: Union[int, tuple[int, ...], slice]\n    ) -&gt; int:\n        if attr not in self.data:\n            raise KeyError(f\"Key {attr} not in {self.data.keys()}\")\n        slice_obj = create_safe_slice(slice_args)\n        return self.data[attr][slice_obj].size\n\n    \"\"\"\n    to|from vec_args (simple osc)\n    \"\"\"\n\n    \"\"\"\n    to|from ndarray | ndarraydict (serialised formats, complex osc)\n    \"\"\"\n\n    \"\"\"\n    ...\n    \"\"\"\n\n    def set_slice_from_dict(self, slice_indices: tuple, slice_values: dict):\n        for key, values in slice_values.items():\n            if key not in self.data:\n                raise KeyError(f\"Key {key} not found in data\")\n\n            array_slice = self.data[key][slice_indices]\n            if array_slice.shape != np.array(values).shape:\n                raise ValueError(\n                    f\"Shape {array_slice.shape} of values for key {key} does not match the shape of the slice {np.array(values).shape}\"\n                )\n\n            self.data[key][slice_indices] = np.array(\n                values, dtype=self.dict[key][\"dtype\"]\n            )\n\n    # def list_to_dict(self, _list: list) -&gt; dict:\n    #     \"\"\"\n    #     Convert a flat list to a dictionary.\n\n    #     :param _list: The flat list to convert.\n    #     :return: A dictionary that matches self.dict.\n    #     \"\"\"\n    #     pass\n\n    # def list_len_to_dict_shape(self, _list: list) -&gt; dict:\n    #     \"\"\"\n    #     Convert a flat list to a dictionary of shapes.\n\n    #     :param _list: The flat list to convert.\n    #     :return: shape of the dictionary of _list based on self.shape.\n    #     \"\"\"\n    #     list_len = len(_list)\n    #     dict_shape = ()\n    #     for key in self.data.keys():\n    #         dict_shape += self.dict[key]['shape'][1:]\n    #     dict_len = np.prod(dict_shape)\n    #     if list_len != dict_len:\n    #         raise ValueError(f\"Length of list {_list} does not match the length of the dictionary {dict_len}\")\n    #     return dict_shape\n\n    def set_slice_from_list(self, slice_indices: tuple, slice_values_list: list):\n        list_index = 0\n\n        for key in self.data.keys():\n            # Determine the total number of elements required for the current key\n            num_elements = np.prod(self.dict[key][\"shape\"][1:])\n            print(f\"[{key}] num_elements: {num_elements}\")\n\n            # Extract the slice from slice_values_list and reshape if necessary\n            slice_shape = self.dict[key][\"shape\"][1:]\n            slice = slice_values_list[list_index : list_index + num_elements]\n            print(f\"[{key}] slice_shape: {slice_shape}, slice: {slice}\")\n\n            # Check if the slice has the correct length\n            if len(slice) != num_elements:\n                raise ValueError(\n                    f\"Slice length {len(slice)} for key {key} does not match the number of elements {num_elements}\"\n                )\n\n            # Reshape the slice for ndarrays with more than 2 dimensions\n            if len(slice_shape) &gt; 1:\n                slice = np.reshape(slice, slice_shape)\n                print(f\"[{key}] (reshaping) slice_shape: {slice_shape}, slice: {slice}\")\n\n            # Assign the slice to the corresponding key\n            self.data[key][slice_indices] = slice\n\n            list_index += num_elements\n            print(f\"[{key}] list_index: {list_index}, num_elements: {num_elements}\")\n\n        print(f\"data: {self.data}\")\n\n        # Check if there are extra values in slice_values_list\n        if list_index != len(slice_values_list):\n            raise ValueError(\n                f\"Extra values {slice_values_list[list_index:]} in slice_values_list {slice_values_list} that do not correspond to any array\"\n            )\n\n    def set_data(self, new_data: dict[str, np.ndarray]) -&gt; None:\n        \"\"\"\n        Set the data with a new data dictionary.\n\n        Args:\n            new_data: A dictionary representing the new data, where each key is an\n                    attribute and the value is a numpy array.\n\n        Raises:\n            ValueError: If the new data is invalid (e.g., wrong shape, type, or value range).\n        \"\"\"\n        try:\n            self.data = new_data\n        except ValueError as e:\n            print(f\"ValueError occurred while setting data: {e}\")\n            raise\n\n    def get_data(self) -&gt; dict[str, np.ndarray]:\n        \"\"\"\n        Get the entire current data as a dictionary.\n\n        Returns:\n            A dictionary where each key is an attribute and the value is a numpy array.\n        \"\"\"\n        return self.data\n\n    def validate(self, new_state: dict[str, np.ndarray]) -&gt; bool:\n        raise NotImplementedError(\"validate() not implemented\")\n\n    def randomise(self) -&gt; None:\n        \"\"\"\n        Randomize the entire state dictionary based on the datatype, minimum,\n        and maximum values for each attribute.\n        \"\"\"\n        for key in self.data:\n            data_type = self.dict[key][\"dtype\"]\n            min_val = self.dict[key][\"min\"]\n            max_val = self.dict[key][\"max\"]\n            shape = self.dict[key][\"shape\"]\n\n            if np.issubdtype(data_type, np.integer):\n                self.data[key] = np.random.randint(\n                    min_val, max_val + 1, size=shape, dtype=data_type\n                )\n            elif np.issubdtype(data_type, np.floating):\n                self.data[key] = np.random.uniform(min_val, max_val, size=shape).astype(\n                    data_type\n                )\n            # Add more conditions here if you have other data types\n\n    def attr_apply(self, key: str, func: Callable[[np.ndarray], np.ndarray]) -&gt; None:\n        \"\"\"\n        Apply a user-defined function to the array of a specified key.\n\n        Args:\n            key: The attribute key.\n            func: A function that takes a numpy array and returns a numpy array.\n\n        Raises:\n            KeyError: If the key is not found.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found\")\n\n        self.data[key] = func(self.data[key])\n\n    def attr_broadcast(\n        self,\n        key: str,\n        other: Union[np.ndarray, \"NpNdarrayDict\"],\n        op: Callable[[np.ndarray, np.ndarray], np.ndarray],\n    ) -&gt; None:\n        \"\"\"\n        Perform a broadcasting operation between the array of the specified key and another array or NpNdarrayDict.\n\n        Args:\n            key: The key of the array in the dictionary to operate on.\n            other: The other array or NpNdarrayDict to use in the operation.\n            op: A function to perform the operation. This should be a NumPy ufunc (like np.add, np.multiply).\n\n        Raises:\n            KeyError: If the key is not found in the dictionary.\n            ValueError: If the operation cannot be broadcasted or if it violates the min-max constraints.\n        \"\"\"\n        if key not in self.data:\n            raise KeyError(f\"Key {key} not found\")\n\n        if isinstance(other, NpNdarrayDict):\n            if other.shape != self.shape:\n                raise ValueError(\"Shapes of NpNdarrayDict objects do not match\")\n            other_array = other.data[key]  # Assuming we want to operate on the same key\n        elif isinstance(other, np.ndarray):\n            other_array = other\n        else:\n            raise ValueError(\n                \"The 'other' parameter must be either a NumPy ndarray or NpNdarrayDict\"\n            )\n\n        result = op(self.data[key], other_array)\n\n        # Check if the result is within the allowed min-max range\n        if np.any(result &lt; self.dict[key][\"min\"]) or np.any(\n            result &gt; self.dict[key][\"max\"]\n        ):\n            raise ValueError(\"Operation result violates min-max constraints\")\n\n        self.data[key] = result\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.__init__","title":"<code>__init__(data_dict, shape)</code>","text":"<p>Initialize the State class.</p> <p>Parameters:</p> Name Type Description Default <code>data_dict</code> <code>dict[str, tuple[Any, Any, Any]]</code> <p>A dictionary where keys are attribute names and values are tuples        of (dtype, min_value, max_value).</p> required <code>shape</code> <code>tuple[int]</code> <p>The shape of the numpy arrays for each attribute.</p> required Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def __init__(self, data_dict: dict[str, tuple[Any, Any, Any]], shape: tuple[int]):\n    \"\"\"\n    Initialize the State class.\n\n    Args:\n        data_dict: A dictionary where keys are attribute names and values are tuples\n                   of (dtype, min_value, max_value).\n        shape: The shape of the numpy arrays for each attribute.\n\n    \"\"\"\n    self.shape = shape\n    self.init(data_dict, shape)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.attr_apply","title":"<code>attr_apply(key, func)</code>","text":"<p>Apply a user-defined function to the array of a specified key.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute key.</p> required <code>func</code> <code>Callable[[ndarray], ndarray]</code> <p>A function that takes a numpy array and returns a numpy array.</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def attr_apply(self, key: str, func: Callable[[np.ndarray], np.ndarray]) -&gt; None:\n    \"\"\"\n    Apply a user-defined function to the array of a specified key.\n\n    Args:\n        key: The attribute key.\n        func: A function that takes a numpy array and returns a numpy array.\n\n    Raises:\n        KeyError: If the key is not found.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found\")\n\n    self.data[key] = func(self.data[key])\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.attr_broadcast","title":"<code>attr_broadcast(key, other, op)</code>","text":"<p>Perform a broadcasting operation between the array of the specified key and another array or NpNdarrayDict.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key of the array in the dictionary to operate on.</p> required <code>other</code> <code>Union[ndarray, NpNdarrayDict]</code> <p>The other array or NpNdarrayDict to use in the operation.</p> required <code>op</code> <code>Callable[[ndarray, ndarray], ndarray]</code> <p>A function to perform the operation. This should be a NumPy ufunc (like np.add, np.multiply).</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found in the dictionary.</p> <code>ValueError</code> <p>If the operation cannot be broadcasted or if it violates the min-max constraints.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def attr_broadcast(\n    self,\n    key: str,\n    other: Union[np.ndarray, \"NpNdarrayDict\"],\n    op: Callable[[np.ndarray, np.ndarray], np.ndarray],\n) -&gt; None:\n    \"\"\"\n    Perform a broadcasting operation between the array of the specified key and another array or NpNdarrayDict.\n\n    Args:\n        key: The key of the array in the dictionary to operate on.\n        other: The other array or NpNdarrayDict to use in the operation.\n        op: A function to perform the operation. This should be a NumPy ufunc (like np.add, np.multiply).\n\n    Raises:\n        KeyError: If the key is not found in the dictionary.\n        ValueError: If the operation cannot be broadcasted or if it violates the min-max constraints.\n    \"\"\"\n    if key not in self.data:\n        raise KeyError(f\"Key {key} not found\")\n\n    if isinstance(other, NpNdarrayDict):\n        if other.shape != self.shape:\n            raise ValueError(\"Shapes of NpNdarrayDict objects do not match\")\n        other_array = other.data[key]  # Assuming we want to operate on the same key\n    elif isinstance(other, np.ndarray):\n        other_array = other\n    else:\n        raise ValueError(\n            \"The 'other' parameter must be either a NumPy ndarray or NpNdarrayDict\"\n        )\n\n    result = op(self.data[key], other_array)\n\n    # Check if the result is within the allowed min-max range\n    if np.any(result &lt; self.dict[key][\"min\"]) or np.any(\n        result &gt; self.dict[key][\"max\"]\n    ):\n        raise ValueError(\"Operation result violates min-max constraints\")\n\n    self.data[key] = result\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.get_data","title":"<code>get_data()</code>","text":"<p>Get the entire current data as a dictionary.</p> <p>Returns:</p> Type Description <code>dict[str, ndarray]</code> <p>A dictionary where each key is an attribute and the value is a numpy array.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def get_data(self) -&gt; dict[str, np.ndarray]:\n    \"\"\"\n    Get the entire current data as a dictionary.\n\n    Returns:\n        A dictionary where each key is an attribute and the value is a numpy array.\n    \"\"\"\n    return self.data\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.randomise","title":"<code>randomise()</code>","text":"<p>Randomize the entire state dictionary based on the datatype, minimum, and maximum values for each attribute.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def randomise(self) -&gt; None:\n    \"\"\"\n    Randomize the entire state dictionary based on the datatype, minimum,\n    and maximum values for each attribute.\n    \"\"\"\n    for key in self.data:\n        data_type = self.dict[key][\"dtype\"]\n        min_val = self.dict[key][\"min\"]\n        max_val = self.dict[key][\"max\"]\n        shape = self.dict[key][\"shape\"]\n\n        if np.issubdtype(data_type, np.integer):\n            self.data[key] = np.random.randint(\n                min_val, max_val + 1, size=shape, dtype=data_type\n            )\n        elif np.issubdtype(data_type, np.floating):\n            self.data[key] = np.random.uniform(min_val, max_val, size=shape).astype(\n                data_type\n            )\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.NpNdarrayDict.set_data","title":"<code>set_data(new_data)</code>","text":"<p>Set the data with a new data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>new_data</code> <code>dict[str, ndarray]</code> <p>A dictionary representing the new data, where each key is an     attribute and the value is a numpy array.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the new data is invalid (e.g., wrong shape, type, or value range).</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def set_data(self, new_data: dict[str, np.ndarray]) -&gt; None:\n    \"\"\"\n    Set the data with a new data dictionary.\n\n    Args:\n        new_data: A dictionary representing the new data, where each key is an\n                attribute and the value is a numpy array.\n\n    Raises:\n        ValueError: If the new data is invalid (e.g., wrong shape, type, or value range).\n    \"\"\"\n    try:\n        self.data = new_data\n    except ValueError as e:\n        print(f\"ValueError occurred while setting data: {e}\")\n        raise\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.dict_from_vector_args","title":"<code>dict_from_vector_args(a, scalars=None)</code>","text":"<p>Convert a list of arguments to a dictionary.</p> <p>Args: - a: A list of arguments. - scalars: A list of keys that should be unwrapped from lists.</p> <p>Returns: - A dictionary of keyword arguments.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def dict_from_vector_args(a: list, scalars=None):\n    \"\"\"Convert a list of arguments to a dictionary.\n\n    Args:\n    - a: A list of arguments.\n    - scalars: A list of keys that should be unwrapped from lists.\n\n    Returns:\n    - A dictionary of keyword arguments.\n    \"\"\"\n    a = list(a)\n    kw = defaultdict(list)\n    k = None\n    while len(a):\n        item = a.pop(0)\n        if isinstance(item, str):\n            k = item\n        else:\n            if k is None:\n                print(f\"ERROR: bad syntax in {a}\")\n            kw[k].append(item)\n    # unwrap scalars\n    for item in scalars or []:\n        if item in kw:\n            kw[item] = kw[item][0]\n    return kw\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.dict_to_vector_args","title":"<code>dict_to_vector_args(kw)</code>","text":"<p>Convert a dictionary to a list of arguments.</p> <p>This function takes a dictionary and returns a list of arguments.</p> <p>Args: - kw: A dictionary of keyword arguments.</p> <p>Returns: - A list of arguments.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def dict_to_vector_args(kw):\n    \"\"\"Convert a dictionary to a list of arguments.\n\n    This function takes a dictionary and returns a list of arguments.\n\n    Args:\n    - kw: A dictionary of keyword arguments.\n\n    Returns:\n    - A list of arguments.\n    \"\"\"\n    args = []\n    for key, value in kw.items():\n        args.append(key)\n        if isinstance(value, (list, np.ndarray)):\n            # If it's a numpy array (regardless of its shape), flatten it and extend the list\n            if isinstance(value, np.ndarray):\n                value = value.flatten()\n            args.extend(value)\n        else:\n            # Append the scalar value associated with the key\n            args.append(value)\n    return args\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.ndarraydict_from_vector_args","title":"<code>ndarraydict_from_vector_args(lst, shapes)</code>","text":"<p>Convert a list to a dictionary where each list is turned into a numpy array.</p> <p>This function takes a list in the format output by <code>dict_from_vector_args</code> and converts it into a dictionary. Each key's list of values is converted into a numpy array with a specified shape.</p> <p>Args: - lst: The list to be converted. - shapes: A dictionary where keys correspond to the keys in the original list and           values are tuples representing the desired shape of the numpy array.</p> <p>Returns: - A dictionary with keys mapped to numpy arrays.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def ndarraydict_from_vector_args(lst, shapes):\n    \"\"\"Convert a list to a dictionary where each list is turned into a numpy array.\n\n    This function takes a list in the format output by `dict_from_vector_args` and converts it\n    into a dictionary. Each key's list of values is converted into a numpy array with a\n    specified shape.\n\n    Args:\n    - lst: The list to be converted.\n    - shapes: A dictionary where keys correspond to the keys in the original list and\n              values are tuples representing the desired shape of the numpy array.\n\n    Returns:\n    - A dictionary with keys mapped to numpy arrays.\n    \"\"\"\n\n    def flatten(lst):\n        \"\"\"Flatten a nested list or return a non-nested list as is.\"\"\"\n        if all(isinstance(el, list) for el in lst):\n            # Flatten only if all elements are lists\n            return [item for sublist in lst for item in sublist]\n        return lst\n\n    kw = defaultdict(list)\n    k = None\n    for item in lst:\n        if isinstance(item, str):\n            k = item\n        else:\n            kw[k].append(item)\n\n    for key, shape in shapes.items():\n        if key in kw:\n            values = flatten(kw[key])\n            array_size = np.prod(shape)\n            if len(values) != array_size:\n                raise ValueError(\n                    f\"Shape mismatch for key '{key}': expected {array_size} elements, got {len(values)}.\"\n                )\n            kw[key] = np.array(values).reshape(shape)\n\n    return dict(kw)\n</code></pre>"},{"location":"reference/tolvera/npndarray_dict/#tolvera.npndarray_dict.shapes_from_ndarray_dict","title":"<code>shapes_from_ndarray_dict(ndarray_dict)</code>","text":"<p>Return a dictionary of shapes given a dictionary of numpy ndarrays.</p> <p>This function takes a dictionary where values are numpy ndarrays and returns a new dictionary with the same keys, where each value is the shape of the ndarray.</p> <p>Args: - ndarray_dict: A dictionary where values are numpy ndarrays.</p> <p>Returns: - A dictionary where each key maps to the shape of the corresponding ndarray.</p> Source code in <code>src/tolvera/npndarray_dict.py</code> <pre><code>def shapes_from_ndarray_dict(ndarray_dict):\n    \"\"\"Return a dictionary of shapes given a dictionary of numpy ndarrays.\n\n    This function takes a dictionary where values are numpy ndarrays and returns\n    a new dictionary with the same keys, where each value is the shape of the ndarray.\n\n    Args:\n    - ndarray_dict: A dictionary where values are numpy ndarrays.\n\n    Returns:\n    - A dictionary where each key maps to the shape of the corresponding ndarray.\n    \"\"\"\n    shapes = {}\n    for key, array in ndarray_dict.items():\n        shapes[key] = array.shape\n    return shapes\n</code></pre>"},{"location":"reference/tolvera/particles/","title":"Particles","text":""},{"location":"reference/tolvera/particles/#tolvera.particles.Particles","title":"<code>Particles</code>","text":"Source code in <code>src/tolvera/particles.py</code> <pre><code>@ti.data_oriented\nclass Particles:\n    # def __init__(self, tolvera, species: Species, **kwargs):\n    def __init__(self, tolvera, **kwargs):\n        self.tv = tolvera\n        self.kwargs = kwargs\n        self.n = self.tv.pn\n        self.p_per_s = self.tv.p_per_s\n        # self.s = species\n        self._speed = ti.field(ti.f32, shape=())\n        self._speed[None] = 1.0\n        self.substep = self.tv.substep\n        self.field = Particle.field(shape=(self.n))\n        # TODO: These should be possible with State\n        # self.pos = State(self.tv, {\n        #     'x': (0., self.tv.x),\n        #     'y': (0., self.tv.y),\n        # }, shape=(self.n,), osc=('get'), name='particles_pos')\n        self.tmp_pos = ti.Vector.field(2, ti.f32, shape=(self.n))\n        self.tmp_vel = ti.Vector.field(2, ti.f32, shape=(self.n))\n        self.tmp_pos_species = ti.Vector.field(2, ti.f32, shape=(self.p_per_s))\n        self.tmp_vel_species = ti.Vector.field(2, ti.f32, shape=(self.p_per_s))\n        self.tmp_vel_stats = ti.Vector.field(1, ti.f32, shape=(7))\n        self.active_indexes = ti.field(ti.i32, shape=(self.n))\n        self.active_count = ti.field(ti.i32, shape=())\n        self.init()\n\n    def init(self):\n        self.assign_species()\n        self.randomise()\n\n    @ti.kernel\n    def assign_species(self):\n        for i in range(self.n):\n            self.field[i].species = i % self.tv.species\n\n    def _randomise(self):\n        self.randomise()\n\n    @ti.kernel\n    def randomise(self):\n        for i in range(self.n):\n            si = self.field[i].species\n            s = self.tv.s.species[si]\n            # FIXME: ugly\n            # c = self.tv.species_consts\n            species = si\n            active = 1.0\n            pos = [self.tv.x * ti.random(ti.f32), self.tv.y * ti.random(ti.f32)]\n            vel = [2 * (ti.random(ti.f32) - 0.5), 2 * (ti.random(ti.f32) - 0.5)]\n            size = (\n                ti.random(ti.f32) * s.size * self.tv.species_consts.MAX_SIZE\n                + self.tv.species_consts.MIN_SIZE\n            )\n            speed = (\n                ti.random(ti.f32) * s.speed * self.tv.species_consts.MAX_SPEED\n                + self.tv.species_consts.MIN_SPEED\n            )\n            mass = ti.random(ti.f32) * s.mass * self.tv.species_consts.MAX_MASS\n            self.field[i] = Particle(\n                species=species,\n                pos=pos,\n                vel=vel,\n                active=active,\n                mass=mass,\n                size=size,\n                speed=speed,\n            )\n\n    @ti.kernel\n    def update(self):\n        # TODO: collisions\n        for i in range(self.n):\n            if self.field[i] == 0.0:\n                continue\n            self.toroidal_wrap(i)\n            self.limit_speed(i)\n\n    @ti.kernel\n    def update_active(self):\n        j = 0\n        for i in range(self.n):\n            p = self.field[i]\n            if p.active &gt; 0.0:\n                self.active_indexes[j] = i\n                j += 1\n        self.active_count[None] = j\n\n    @ti.func\n    def toroidal_wrap(self, i):\n        p = self.field[i]\n        if p.pos[0] &gt; self.tv.x:\n            self.field[i].pos[0] = 0.0\n        if p.pos[0] &lt; 0.0:\n            self.field[i].pos[0] = self.tv.x\n        if p.pos[1] &gt; self.tv.y:\n            self.field[i].pos[1] = 0.0\n        if p.pos[1] &lt; 0.0:\n            self.field[i].pos[1] = self.tv.y\n\n    @ti.func\n    def limit_speed(self, i: int):\n        p = self.field[i]\n        s = self.tv.s.species[p.species]\n        # FIXME: ugly\n        sp = (\n            s.speed * self.tv.species_consts.MAX_SPEED\n            + self.tv.species_consts.MIN_SPEED\n        )\n        if p.vel.norm() &gt; s.speed:\n            self.field[i].vel = p.vel.normalized() * sp * self._speed[None]\n\n    @ti.kernel\n    def activity_decay(self):\n        for i in range(self.active_count[None]):\n            idx = self.active_indexes[i]\n            self.field[idx].active *= self.field[i].decay\n\n    def process(self):\n        for i in range(self.substep):\n            self.update_active()\n            self.update()\n\n    @ti.kernel\n    def set_active(self, a: ti.i32):\n        for i in range(self.field.shape[0]):\n            if i &gt; a:\n                self.field[i].active = 0\n            else:\n                self.field[i].active = 1\n\n    @ti.kernel\n    def set_species_active(self, i: ti.i32, a: ti.i32):\n        for j in range(self.field.shape[0]):\n            if self.field[j].species == i:\n                if j &gt; a:\n                    self.field[j].active = 0\n                else:\n                    self.field[j].active = 1\n\n    @ti.kernel\n    def set_active_amount(self, a: ti.f32):\n        for i in range(self.field.shape[0]):\n            self.field[i].active = a\n\n    @ti.kernel\n    def set_species_active_amount(self, i: ti.i32, a: ti.f32):\n        for j in range(self.field.shape[0]):\n            if self.field[j].species == i:\n                self.field[j].active = a\n\n    def set_pos(self, i, x, y):\n        self.field[i].pos = [x, y]\n\n    def set_vel(self, i, x, y):\n        self.field[i].vel = [x, y]\n\n    def set_speed(self, i, s):\n        self.field[i].speed = s\n\n    def set_size(self, i, s):\n        self.field[i].size = s\n\n    def get_pos(self, i):\n        return self.field[i].pos.to_numpy().tolist()\n\n    def get_vel(self, i):\n        return self.field[i].vel.to_numpy().tolist()\n\n    def get_pos_all_1d(self):\n        self._get_pos_all()\n        return self.tmp_pos.to_numpy().flatten().tolist()\n\n    def get_pos_all_2d(self):\n        self._get_pos_all()\n        return self.tmp_pos.to_numpy().tolist()\n\n    def get_vel_all_1d(self):\n        self._get_vel_all()\n        return self.tmp_vel.to_numpy().flatten().tolist()\n\n    def get_vel_all_2d(self):\n        self._get_vel_all()\n        return self.tmp_vel.to_numpy().tolist()\n\n    @ti.kernel\n    def _get_pos_all(self):\n        # for i in range(self.active_count[None]):\n        #     idx = self.active_indexes[i]\n        #     p = self.field[idx]\n        #     self.tmp_pos[i] = p.pos / [self.tv.x, self.tv.y]\n        # TODO: Only send active particle positions...? Or inactive=-1?\n        for i in range(self.n):\n            p = self.field[i]\n            # if p.active &gt; 0.0: # causes IML shape assertion error\n            self.tmp_pos[i] = p.pos / [self.tv.x, self.tv.y]\n            # else:\n            #     self.tmp_pos[i] = [0.0,0.0] # ???\n\n    @ti.kernel\n    def _get_vel_all(self):\n        for i in range(self.n):\n            p = self.field[i]\n            if p.active &gt; 0.0:\n                self.tmp_vel[i] = p.vel\n\n    def get_pos_species_1d(self, species: int):\n        self._get_pos_species()\n        return self.tmp_pos_species.to_numpy().flatten().tolist()\n\n    def get_pos_species_2d(self, species: int):\n        if species &gt; self.tv.species - 1:\n            return\n        self._get_pos_species(species)\n        return self.tmp_pos_species.to_numpy().tolist()\n\n    @ti.kernel\n    def _get_pos_species(self, i: ti.i32):\n        for j in range(self.n):\n            si = j % self.tv.species\n            p = self.field[j]\n            if i == si and p.active &gt; 0.0:\n                species_index = (j - i) // self.tv.species\n                pos = p.pos / [self.tv.x, self.tv.y]\n                self.tmp_pos_species[species_index] = pos\n\n    def get_vel_species_1d(self, species: int):\n        self._get_vel_species(species)\n        return self.tmp_vel_species.to_numpy().flatten().tolist()\n\n    def get_vel_species_2d(self, species: int):\n        self._get_vel_species(species)\n        return self.tmp_vel_species.to_numpy().tolist()\n\n    @ti.kernel\n    def _get_vel_species(self, i: ti.i32):\n        for j in range(self.n):\n            si = j % self.tv.species\n            p = self.field[j]\n            if i == si and p.active &gt; 0.0:\n                species_index = (j - i) // self.tv.species\n                vel = p.vel / [self.tv.x, self.tv.y]\n                self.tmp_vel_species[species_index] = vel\n\n    def get_vel_stats_species_1d(self, species):\n        self._species_velocity_statistics(species)\n        return self.tmp_vel_stats.to_numpy().flatten().tolist()\n\n    @ti.kernel\n    def _species_velocity_statistics(self, i: ti.i32):\n        \"\"\"\n        Centre of Mass Velocity: This is the average velocity of all particles in the species.\n        Relative Velocity: This is the average velocity of all particles in the species relative to the centre of mass velocity.\n        Angular Momentum: This is the sum of the angular momentum of all particles, which is given by mass * velocity * radius for each particle.\n        Kinetic Energy: This is the sum of the kinetic energy of all particles, which is given by 0.5 * mass * velocity^2 for each particle.\n        Temperature: In statistical mechanics, the temperature of a system of particles is related to the average kinetic energy of the particles.\n        \"\"\"\n        centre_of_mass_velocity = ti.Vector([0.0, 0.0])\n        relative_velocity = ti.Vector([0.0, 0.0])\n        angular_momentum = ti.Vector([0.0])\n        kinetic_energy = ti.Vector([0.0])\n        for j in range(self.n):\n            if self.field[j].species == i:\n                v = self.field[j].vel\n                p = self.field[j].pos\n                m = self.field[j].mass\n                centre_of_mass_velocity += v\n                relative_velocity += v  # - centre_of_mass_velocity\n                angular_momentum += m * ti.math.cross(v, p)\n                kinetic_energy += 0.5 * m * v.norm_sqr()\n        centre_of_mass_velocity = centre_of_mass_velocity / self.n_per_species\n        relative_velocity = (\n            relative_velocity - centre_of_mass_velocity * self.n_per_species\n        ) / self.n_per_species\n        temperature = 2.0 * kinetic_energy / (self.particles_per_species * 1.380649e-23)\n        self.tmp_vel_stats[0] = centre_of_mass_velocity[0]\n        self.tmp_vel_stats[1] = centre_of_mass_velocity[1]\n        self.tmp_vel_stats[2] = relative_velocity[0]\n        self.tmp_vel_stats[3] = relative_velocity[1]\n        self.tmp_vel_stats[4] = angular_momentum[0]\n        self.tmp_vel_stats[5] = kinetic_energy[0]\n        self.tmp_vel_stats[6] = temperature[0]\n\n    def reset(self):\n        self.init()\n\n    def speed(self, speed: float = None):\n        if speed is not None:\n            self._speed[None] = 1 / (speed + 0.0001)\n        else:\n            return self._speed[None]\n\n    def __call__(self):\n        self.process()\n</code></pre>"},{"location":"reference/tolvera/patches/","title":"Patches","text":"<p>Patches for third-party libraries.</p> <p>Current patches: - 'dill.source.findsource fails when in asyncio REPL' https://github.com/uqfoundation/dill/issues/627</p>"},{"location":"reference/tolvera/patches/#tolvera.patches.findsource","title":"<code>findsource(object)</code>","text":"<p>Return the entire source file and starting line number for an object. For interactively-defined objects, the 'file' is the interpreter's history.</p> <p>The argument may be a module, class, method, function, traceback, frame, or code object.  The source code is returned as a list of all the lines in the file and the line number indexes a line in that list.  An IOError is raised if the source code cannot be retrieved, while a TypeError is raised for objects where the source code is unavailable (e.g. builtins).</p> Source code in <code>src/tolvera/patches.py</code> <pre><code>def findsource(object):\n    # print(f\"[dill.source.findsource] PATCHED\")\n\n    \"\"\"Return the entire source file and starting line number for an object.\n    For interactively-defined objects, the 'file' is the interpreter's history.\n\n    The argument may be a module, class, method, function, traceback, frame,\n    or code object.  The source code is returned as a list of all the lines\n    in the file and the line number indexes a line in that list.  An IOError\n    is raised if the source code cannot be retrieved, while a TypeError is\n    raised for objects where the source code is unavailable (e.g. builtins).\"\"\"\n\n    def patched_getfile(module):\n        # set file = None when module.__package__ == 'asyncio'\n        # print(f\"[dill.source.patched_getfile] module={module}\\nmodule.__package__={module.__package__}\\nmodule.__name__={module.__name__}\")\n        if module.__package__ == \"asyncio\":\n            raise TypeError\n        # if module.__package__ == 'sardine':\n        #     raise TypeError\n        ret = getfile(module)\n        return ret\n\n    module = getmodule(object)\n    # try: file = getfile(module)\n    try:\n        file = patched_getfile(module)\n    except TypeError:\n        file = None\n    # correctly compute `is_module_main` when in asyncio\n    is_module_main = module and module.__name__ == \"__main__\" and not file\n    # is_module_main = (module and module.__name__ == '__main__' or module.__name__ == 'sardine' and not file)\n    print(\n        f\"[dill.source.findsource] module: {module}, file: {file}, is_module_main: {is_module_main}\"\n    )\n    if IS_IPYTHON and is_module_main:\n        # FIXME: quick fix for functions and classes in IPython interpreter\n        try:\n            file = getfile(object)\n            sourcefile = getsourcefile(object)\n        except TypeError:\n            if isclass(object):\n                for object_method in filter(isfunction, object.__dict__.values()):\n                    # look for a method of the class\n                    file_candidate = getfile(object_method)\n                    if not file_candidate.startswith(\"&lt;ipython-input-\"):\n                        continue\n                    file = file_candidate\n                    sourcefile = getsourcefile(object_method)\n                    break\n        if file:\n            lines = linecache.getlines(file)\n        else:\n            # fallback to use history\n            history = \"\\n\".join(get_ipython().history_manager.input_hist_parsed)\n            lines = [line + \"\\n\" for line in history.splitlines()]\n    # use readline when working in interpreter (i.e. __main__ and not file)\n    elif is_module_main:\n        try:\n            import readline\n\n            err = \"\"\n        except ImportError:\n            import sys\n\n            err = sys.exc_info()[1].args[0]\n            if sys.platform[:3] == \"win\":\n                err += \", please install 'pyreadline'\"\n        if err:\n            raise IOError(err)\n        lbuf = readline.get_current_history_length()\n        lines = [readline.get_history_item(i) + \"\\n\" for i in range(1, lbuf)]\n    else:\n        try:  # special handling for class instances\n            if not isclass(object) and isclass(type(object)):  # __class__\n                file = getfile(module)\n                sourcefile = getsourcefile(module)\n            else:  # builtins fail with a TypeError\n                file = getfile(object)\n                sourcefile = getsourcefile(object)\n        except (TypeError, AttributeError):  # fail with better error\n            file = getfile(object)\n            sourcefile = getsourcefile(object)\n        if not sourcefile and file[:1] + file[-1:] != \"&lt;&gt;\":\n            raise IOError(\"source code not available\")\n        file = sourcefile if sourcefile else file\n\n        module = getmodule(object, file)\n        if module:\n            lines = linecache.getlines(file, module.__dict__)\n        else:\n            lines = linecache.getlines(file)\n\n    if not lines:\n        raise IOError(\"could not extract source code\")\n\n    # FIXME: all below may fail if exec used (i.e. exec('f = lambda x:x') )\n    if ismodule(object):\n        return lines, 0\n\n    # NOTE: beneficial if search goes from end to start of buffer history\n    name = pat1 = obj = \"\"\n    pat2 = r\"^(\\s*@)\"\n    #   pat1b = r'^(\\s*%s\\W*=)' % name #FIXME: finds 'f = decorate(f)', not exec\n    if ismethod(object):\n        name = object.__name__\n        if name == \"&lt;lambda&gt;\":\n            pat1 = r\"(.*(?&lt;!\\w)lambda(:|\\s))\"\n        else:\n            pat1 = r\"^(\\s*def\\s)\"\n        object = object.__func__\n    if isfunction(object):\n        name = object.__name__\n        if name == \"&lt;lambda&gt;\":\n            pat1 = r\"(.*(?&lt;!\\w)lambda(:|\\s))\"\n            obj = object  # XXX: better a copy?\n        else:\n            pat1 = r\"^(\\s*def\\s)\"\n        object = object.__code__\n    if istraceback(object):\n        object = object.tb_frame\n    if isframe(object):\n        object = object.f_code\n    if iscode(object):\n        if not hasattr(object, \"co_firstlineno\"):\n            raise IOError(\"could not find function definition\")\n        # stdin = object.co_filename == '&lt;stdin&gt;'\n        stdin = object.co_filename in (\"&lt;console&gt;\", \"&lt;stdin&gt;\")\n        # print(f\"[dill.source.findsource] object.co_filename: {object.co_filename}, stdin: {stdin}\")\n        if stdin:\n            lnum = len(lines) - 1  # can't get lnum easily, so leverage pat\n            if not pat1:\n                pat1 = r\"^(\\s*def\\s)|(.*(?&lt;!\\w)lambda(:|\\s))|^(\\s*@)\"\n        else:\n            lnum = object.co_firstlineno - 1\n            pat1 = r\"^(\\s*def\\s)|(.*(?&lt;!\\w)lambda(:|\\s))|^(\\s*@)\"\n        pat1 = re.compile(pat1)\n        pat2 = re.compile(pat2)\n        # XXX: candidate_lnum = [n for n in range(lnum) if pat1.match(lines[n])]\n        while lnum &gt; 0:  # XXX: won't find decorators in &lt;stdin&gt; ?\n            line = lines[lnum]\n            if pat1.match(line):\n                if not stdin:\n                    break  # co_firstlineno does the job\n                if name == \"&lt;lambda&gt;\":  # hackery needed to confirm a match\n                    if _matchlambda(obj, line):\n                        break\n                else:  # not a lambda, just look for the name\n                    if name in line:  # need to check for decorator...\n                        hats = 0\n                        for _lnum in range(lnum - 1, -1, -1):\n                            if pat2.match(lines[_lnum]):\n                                hats += 1\n                            else:\n                                break\n                        lnum = lnum - hats\n                        break\n            lnum = lnum - 1\n        return lines, lnum\n\n    try:  # turn instances into classes\n        if not isclass(object) and isclass(type(object)):  # __class__\n            object = object.__class__  # XXX: sometimes type(class) is better?\n            # XXX: we don't find how the instance was built\n    except AttributeError:\n        pass\n    if isclass(object):\n        name = object.__name__\n        pat = re.compile(r\"^(\\s*)class\\s*\" + name + r\"\\b\")\n        # make some effort to find the best matching class definition:\n        # use the one with the least indentation, which is the one\n        # that's most probably not inside a function definition.\n        candidates = []\n        for i in range(len(lines) - 1, -1, -1):\n            match = pat.match(lines[i])\n            if match:\n                # if it's at toplevel, it's already the best one\n                if lines[i][0] == \"c\":\n                    return lines, i\n                # else add whitespace to candidate list\n                candidates.append((match.group(1), i))\n        if candidates:\n            # this will sort by whitespace, and by line number,\n            # less whitespace first  #XXX: should sort high lnum before low\n            candidates.sort()\n            return lines, candidates[0][1]\n        else:\n            raise IOError(\"could not find class definition\")\n    raise IOError(\"could not find code object\")\n</code></pre>"},{"location":"reference/tolvera/pixels/","title":"Pixels","text":""},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels","title":"<code>Pixels</code>","text":"Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.data_oriented\nclass Pixels:\n    def __init__(self, tolvera, **kwargs):\n        self.tv = tolvera\n        self.kwargs = kwargs\n        self.polygon_mode = kwargs.get(\"polygon_mode\", \"crossing\")\n        self.x = self.tv.x\n        self.y = self.tv.y\n        self.px = Pixel.field(shape=(self.x, self.y))\n        brightness = kwargs.get(\"brightness\", 1.0)\n        self.CONSTS = CONSTS(\n            {\n                \"BRIGHTNESS\": (ti.f32, brightness),\n            }\n        )\n        self.shape_enum = {\n            \"point\": 0,\n            \"line\": 1,\n            \"rect\": 2,\n            \"circle\": 3,\n            \"triangle\": 4,\n            \"polygon\": 5,\n        }\n\n    def set(self, px):\n        self.px.rgba = self.rgba_from_px(px)\n\n    def get(self):\n        return self.px\n\n    @ti.kernel\n    def clear(self):\n        self.px.rgba.fill(0)\n\n    @ti.kernel\n    def diffuse(self, evaporate: ti.f32):\n        for i, j in ti.ndrange(self.x, self.y):\n            d = ti.Vector([0.0, 0.0, 0.0, 0.0])\n            for di in ti.static(range(-1, 2)):\n                for dj in ti.static(range(-1, 2)):\n                    dx = (i + di) % self.x\n                    dy = (j + dj) % self.y\n                    d += self.px.rgba[dx, dy]\n            d *= evaporate / 9.0\n            self.px.rgba[i, j] = d\n\n    @ti.func\n    def background(self, r, g, b):\n        bg = ti.Vector([r, g, b, 1.0])\n        self.rect(0, 0, self.x, self.y, bg)\n\n    @ti.func\n    def point(self, x: ti.i32, y: ti.i32, rgba: vec4):\n        self.px.rgba[x, y] = rgba\n\n    @ti.func\n    def points(self, x: ti.template(), y: ti.template(), rgba: vec4):\n        for i in ti.static(range(len(x))):\n            self.point(x[i], y[i], rgba)\n\n    @ti.func\n    def rect(self, x: ti.i32, y: ti.i32, w: ti.i32, h: ti.i32, rgba: vec4):\n        # TODO: fill arg\n        # TODO: gradients, lerp with ti.math.mix(x, y, a)\n        for i, j in ti.ndrange(w, h):\n            self.px.rgba[x + i, y + j] = rgba\n\n    @ti.func\n    def line(self, x0: ti.i32, y0: ti.i32, x1: ti.i32, y1: ti.i32, rgba: vec4):\n        \"\"\"\n        Bresenham's line algorithm\n        TODO: thickness\n        TODO: anti-aliasing\n        TODO: should lines wrap around (as two lines)?\n        \"\"\"\n        dx = ti.abs(x1 - x0)\n        dy = ti.abs(y1 - y0)\n        x, y = x0, y0\n        sx = -1 if x0 &gt; x1 else 1\n        sy = -1 if y0 &gt; y1 else 1\n        if dx &gt; dy:\n            err = dx / 2.0\n            while x != x1:\n                self.px.rgba[x, y] = rgba\n                err -= dy\n                if err &lt; 0:\n                    y += sy\n                    err += dx\n                x += sx\n        else:\n            err = dy / 2.0\n            while y != y1:\n                self.px.rgba[x, y] = rgba\n                err -= dx\n                if err &lt; 0:\n                    x += sx\n                    err += dy\n                y += sy\n        self.px.rgba[x, y] = rgba\n\n    @ti.func\n    def circle(self, x: ti.i32, y: ti.i32, r: ti.i32, rgba: vec4):\n        for i in range(r + 1):\n            d = ti.sqrt(r**2 - i**2)\n            d_int = ti.cast(d, ti.i32)\n            # TODO: parallelise ?\n            for j in range(d_int):\n                self.px.rgba[x + i, y + j] = rgba\n                self.px.rgba[x + i, y - j] = rgba\n                self.px.rgba[x - i, y - j] = rgba\n                self.px.rgba[x - i, y + j] = rgba\n\n    @ti.func\n    def circles(self, x: ti.template(), y: ti.template(), r: ti.template(), rgba: vec4):\n        for i in ti.static(range(len(x))):\n            self.circle(x[i], y[i], r[i], rgba)\n\n    @ti.func\n    def triangle(self, a, b, c, rgba: vec4):\n        # TODO: fill arg\n        x = ti.Vector([a[0], b[0], c[0]])\n        y = ti.Vector([a[1], b[1], c[1]])\n        self.polygon(x, y, rgba)\n\n    @ti.func\n    def polygon(self, x: ti.template(), y: ti.template(), rgba: vec4):\n        # TODO: fill arg\n        # after http://www.dgp.toronto.edu/~mac/e-stuff/point_in_polygon.py\n        x_min, x_max = ti.cast(x.min(), ti.i32), ti.cast(x.max(), ti.i32)\n        y_min, y_max = ti.cast(y.min(), ti.i32), ti.cast(y.max(), ti.i32)\n        l = len(x)\n        for i, j in ti.ndrange(x_max - x_min, y_max - y_min):\n            p = [x_min + i, y_min + j]\n            if self._is_inside(p, x, y, l) != 0:\n                # TODO: abstract out, weight?\n                \"\"\"\n                x-1,y-1  x,y-1  x+1,y-1\n                x-1,y    x,y    x+1,y\n                x-1,y+1  x,y+1  x+1,y+1\n                \"\"\"\n                _x, _y = p[0], p[1]\n                self.px.rgba[_x - 1, _y - 1] = rgba\n                self.px.rgba[_x - 1, _y] = rgba\n                self.px.rgba[_x - 1, _y + 1] = rgba\n\n                self.px.rgba[_x, _y - 1] = rgba\n                self.px.rgba[_x, _y] = rgba\n                self.px.rgba[_x, _y + 1] = rgba\n\n                self.px.rgba[_x + 1, _y - 1] = rgba\n                self.px.rgba[_x + 1, _y] = rgba\n                self.px.rgba[_x + 1, _y + 1] = rgba\n\n    @ti.func\n    def _is_inside(self, p, x, y, l):\n        is_inside = 0\n        if self.polygon_mode == \"crossing\":\n            is_inside = self._is_inside_crossing(p, x, y, l)\n        elif self.polygon_mode == \"winding\":\n            is_inside = self._is_inside_winding(p, x, y, l)\n        return is_inside\n\n    @ti.func\n    def _is_inside_crossing(self, p, x, y, l):\n        n = 0\n        v0, v1 = ti.Vector([0.0, 0.0]), ti.Vector([0.0, 0.0])\n        for i in range(l):\n            i1 = i + 1 if i &lt; l - 1 else 0\n            v0, v1 = [x[i], y[i]], [x[i1], y[i1]]\n            if (v0[1] &lt;= p[1] and v1[1] &gt; p[1]) or (v0[1] &gt; p[1] and v1[1] &lt;= p[1]):\n                vt = (p[1] - v0[1]) / (v1[1] - v0[1])\n                if p[0] &lt; v0[0] + vt * (v1[0] - v0[0]):\n                    n += 1\n        return n % 2\n\n    @ti.func\n    def _is_inside_winding(self, p, x, y, l):\n        n = 0\n        v0, v1 = ti.Vector([0.0, 0.0]), ti.Vector([0.0, 0.0])\n        for i in range(l):\n            i1 = i + 1 if i &lt; l - 1 else 0\n            v0, v1 = [x[i], y[i]], [x[i1], y[i1]]\n            if v0[1] &lt;= p[1] and v1[1] &gt; p[1] and (v0 - v1).cross(p - v1) &gt; 0:\n                n += 1\n            elif v1[1] &lt;= p[1] and (v0 - v1).cross(p - v1) &lt; 0:\n                n -= 1\n        return n\n\n    @ti.kernel\n    def flip_x(self):\n        \"\"\"\n        Invert image in x-axis.\n        \"\"\"\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba_inv[i, j] = self.px.rgba[self.x - 1 - i, j]\n\n    @ti.kernel\n    def flip_y(self):\n        \"\"\"\n        Flip image in y-axis.\n        \"\"\"\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba_inv[i, j] = self.px.rgba[i, self.y - 1 - j]\n\n    @ti.kernel\n    def invert(self):\n        \"\"\"\n        Invert image.\n        \"\"\"\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba_inv[i, j] = 1.0 - self.px.rgba[i, j]\n\n    @ti.kernel\n    def decay(self, evaporate: ti.f32):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] *= evaporate\n\n    def blend_add(self, px: ti.template()):\n        self._blend_add(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_add(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] += rgba[i, j]\n\n    def blend_sub(self, px: ti.template()):\n        self._blend_sub(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_sub(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] -= rgba[i, j]\n\n    def blend_mul(self, px: ti.template()):\n        self._blend_mul(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_mul(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] *= rgba[i, j]\n\n    def blend_div(self, px: ti.template()):\n        self._blend_div(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_div(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] /= rgba[i, j]\n\n    def blend_min(self, px: ti.template()):\n        self._blend_min(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_min(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] = ti.min(self.px.rgba[i, j], rgba[i, j])\n\n    def blend_max(self, px: ti.template()):\n        self._blend_max(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_max(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] = ti.max(self.px.rgba[i, j], rgba[i, j])\n\n    def blend_diff(self, px: ti.template()):\n        self._blend_diff(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_diff(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] = ti.abs(self.px.rgba[i, j] - rgba[i, j])\n\n    def blend_diff_inv(self, px: ti.template()):\n        self._blend_diff_inv(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_diff_inv(self, rgba: ti.template()):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] = ti.abs(rgba[i, j] - self.px.rgba[i, j])\n\n    def blend_mix(self, px: ti.template(), a: ti.f32):\n        self._blend_mix(self.rgba_from_px(px))\n\n    @ti.kernel\n    def _blend_mix(self, rgba: ti.template(), amount: ti.f32):\n        for i, j in ti.ndrange(self.x, self.y):\n            self.px.rgba[i, j] = ti.math.mix(self.px.rgba[i, j], rgba[i, j], amount)\n\n    @ti.kernel\n    def blur(self, radius: ti.i32):\n        \"\"\"\n        Box blur\n        \"\"\"\n        for i, j in ti.ndrange(self.x, self.y):\n            d = ti.Vector([0.0, 0.0, 0.0, 0.0])\n            for di in range(-radius, radius + 1):\n                for dj in range(-radius, radius + 1):\n                    dx = (i + di) % self.x\n                    dy = (j + dj) % self.y\n                    d += self.px.rgba[dx, dy]\n            d /= (radius * 2 + 1) ** 2\n            self.px.rgba[i, j] = d\n\n    def particles(\n        self, particles: ti.template(), species: ti.template(), shape=\"circle\"\n    ):\n        shape = self.shape_enum[shape]\n        self._particles(particles, species, shape)\n\n    @ti.kernel\n    def _particles(self, particles: ti.template(), species: ti.template(), shape: int):\n        for i in range(self.tv.p.n):\n            p = particles.field[i]\n            s = species[p.species]\n            if p.active == 0.0:\n                continue\n            px = ti.cast(p.pos[0], ti.i32)\n            py = ti.cast(p.pos[1], ti.i32)\n            vx = ti.cast(p.pos[0] + p.vel[0] * 20, ti.i32)\n            vy = ti.cast(p.pos[1] + p.vel[1] * 20, ti.i32)\n            rgba = s.rgba * self.CONSTS.BRIGHTNESS\n            if shape == 0:\n                self.point(px, py, rgba)\n            elif shape == 1:\n                self.line(px, py, vx, vy, rgba)\n            elif shape == 2:\n                side = int(s.size) * 2\n                self.rect(px, py, side, side, rgba)\n            elif shape == 3:\n                self.circle(px, py, p.size, rgba)\n            elif shape == 4:\n                a = p.pos\n                b = p.pos + 1\n                c = a + b\n                self.triangle(a, b, c, rgba)\n            # elif shape == 5:\n            #     self.polygon(px, py, rgba)\n\n    def rgba_from_px(self, px):\n        if isinstance(px, Pixels):\n            return px.px.rgba\n        elif isinstance(px, StructField):\n            return px.rgba\n        elif isinstance(px, MatrixField):\n            return px\n        else:\n            try:\n                return px.px.px.rgba\n            except:\n                raise TypeError(f\"Cannot find pixel field in {type(px)}\")\n\n    @ti.kernel\n    def update(self):\n        pass\n\n    def reset(self):\n        self.clear()\n\n    def __call__(self):\n        return self.get()\n\n    @ti.func\n    def rgba_inv(self):  # -&gt; vec3:\n        # TODO: rgba_inv\n        pass\n\n    # TODO: Normalise positions to [0,1] range?\n    @ti.func\n    def pos_to_px(self, pos: ti.math.vec2) -&gt; ti.math.vec2:\n        return pos * [self.tv.x, self.tv.y]\n\n    @ti.func\n    def px_to_pos(self, px: ti.math.vec2) -&gt; ti.math.vec2:\n        return px / [self.tv.x, self.tv.y]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.blur","title":"<code>blur(radius)</code>","text":"<p>Box blur</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.kernel\ndef blur(self, radius: ti.i32):\n    \"\"\"\n    Box blur\n    \"\"\"\n    for i, j in ti.ndrange(self.x, self.y):\n        d = ti.Vector([0.0, 0.0, 0.0, 0.0])\n        for di in range(-radius, radius + 1):\n            for dj in range(-radius, radius + 1):\n                dx = (i + di) % self.x\n                dy = (j + dj) % self.y\n                d += self.px.rgba[dx, dy]\n        d /= (radius * 2 + 1) ** 2\n        self.px.rgba[i, j] = d\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.flip_x","title":"<code>flip_x()</code>","text":"<p>Invert image in x-axis.</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.kernel\ndef flip_x(self):\n    \"\"\"\n    Invert image in x-axis.\n    \"\"\"\n    for i, j in ti.ndrange(self.x, self.y):\n        self.px.rgba_inv[i, j] = self.px.rgba[self.x - 1 - i, j]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.flip_y","title":"<code>flip_y()</code>","text":"<p>Flip image in y-axis.</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.kernel\ndef flip_y(self):\n    \"\"\"\n    Flip image in y-axis.\n    \"\"\"\n    for i, j in ti.ndrange(self.x, self.y):\n        self.px.rgba_inv[i, j] = self.px.rgba[i, self.y - 1 - j]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.invert","title":"<code>invert()</code>","text":"<p>Invert image.</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.kernel\ndef invert(self):\n    \"\"\"\n    Invert image.\n    \"\"\"\n    for i, j in ti.ndrange(self.x, self.y):\n        self.px.rgba_inv[i, j] = 1.0 - self.px.rgba[i, j]\n</code></pre>"},{"location":"reference/tolvera/pixels/#tolvera.pixels.Pixels.line","title":"<code>line(x0, y0, x1, y1, rgba)</code>","text":"<p>Bresenham's line algorithm TODO: thickness TODO: anti-aliasing TODO: should lines wrap around (as two lines)?</p> Source code in <code>src/tolvera/pixels.py</code> <pre><code>@ti.func\ndef line(self, x0: ti.i32, y0: ti.i32, x1: ti.i32, y1: ti.i32, rgba: vec4):\n    \"\"\"\n    Bresenham's line algorithm\n    TODO: thickness\n    TODO: anti-aliasing\n    TODO: should lines wrap around (as two lines)?\n    \"\"\"\n    dx = ti.abs(x1 - x0)\n    dy = ti.abs(y1 - y0)\n    x, y = x0, y0\n    sx = -1 if x0 &gt; x1 else 1\n    sy = -1 if y0 &gt; y1 else 1\n    if dx &gt; dy:\n        err = dx / 2.0\n        while x != x1:\n            self.px.rgba[x, y] = rgba\n            err -= dy\n            if err &lt; 0:\n                y += sy\n                err += dx\n            x += sx\n    else:\n        err = dy / 2.0\n        while y != y1:\n            self.px.rgba[x, y] = rgba\n            err -= dx\n            if err &lt; 0:\n                x += sx\n                err += dy\n            y += sy\n    self.px.rgba[x, y] = rgba\n</code></pre>"},{"location":"reference/tolvera/sketchbook/","title":"Sketchbook","text":""},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.get_sketch_info","title":"<code>get_sketch_info(sketch_file, sketchbook_folder='./')</code>","text":"<p>Gets information about a specific sketch file.</p> <p>Parameters:</p> Name Type Description Default <code>sketch_file</code> <code>str</code> <p>Name of the sketch file.</p> required <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary containing sketch information such as name, path, size, modified and created times.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def get_sketch_info(sketch_file: str, sketchbook_folder: str = \"./\") -&gt; Dict[str, Any]:\n    \"\"\"\n    Gets information about a specific sketch file.\n\n    Args:\n        sketch_file (str): Name of the sketch file.\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n\n    Returns:\n        Dict[str, Any]: Dictionary containing sketch information such as name, path, size, modified and created times.\n    \"\"\"\n    validate_sketch_file(sketch_file, sketchbook_folder)\n    datetimefmt = \"%Y-%m-%d %H:%M:%S\"\n    if not sketch_file.endswith(\".py\"):\n        sketch_file += \".py\"\n    file_path = os.path.join(sketchbook_folder, sketch_file)\n    module_name = os.path.splitext(sketch_file)[0]\n    file_info = os.stat(file_path)\n    size = file_info.st_size\n    modified = datetime.datetime.fromtimestamp(file_info.st_mtime).strftime(datetimefmt)\n    created = datetime.datetime.fromtimestamp(file_info.st_ctime).strftime(datetimefmt)\n    return {\n        \"name\": module_name,\n        \"path\": file_path,\n        \"size\": size,\n        \"modified\": modified,\n        \"created\": created,\n    }\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.get_sketchbook_files","title":"<code>get_sketchbook_files(sketchbook_folder='./')</code>","text":"<p>Gets all sketch files from the sketchbook folder.</p> <p>Parameters:</p> Name Type Description Default <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of sketch file names.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def get_sketchbook_files(sketchbook_folder: str = \"./\") -&gt; List[str]:\n    \"\"\"\n    Gets all sketch files from the sketchbook folder.\n\n    Args:\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n\n    Returns:\n        List[str]: List of sketch file names.\n    \"\"\"\n    files = os.listdir(sketchbook_folder)\n    exclude = [\"__init__.py\", \"__pycache__\", \".DS_Store\", \"imgui.ini\"]\n    return [f for f in files if f not in exclude]\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.get_sketchbook_files_info","title":"<code>get_sketchbook_files_info(sketches, sketchbook_folder='./')</code>","text":"<p>Gets information about all sketch files in the sketchbook folder.</p> <p>Parameters:</p> Name Type Description Default <code>sketches</code> <code>List[str]</code> <p>List of sketch file names.</p> required <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of sketch information dictionaries.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def get_sketchbook_files_info(\n    sketches: List[str], sketchbook_folder: str = \"./\"\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Gets information about all sketch files in the sketchbook folder.\n\n    Args:\n        sketches (List[str]): List of sketch file names.\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n\n    Returns:\n        List[Dict[str, Any]]: List of sketch information dictionaries.\n    \"\"\"\n    sketch_infos = []\n    for sketch in sketches:\n        sketch_info = get_sketch_info(sketch, sketchbook_folder)\n        sketch_infos.append(sketch_info)\n    return sketch_infos\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.import_sketch","title":"<code>import_sketch(module_name, file_path)</code>","text":"<p>Imports a sketch from a given file.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of the module.</p> required <code>file_path</code> <code>str</code> <p>Path to the file containing the module.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>Any</code> <p>Imported module.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def import_sketch(module_name: str, file_path: str) -&gt; Any:\n    \"\"\"\n    Imports a sketch from a given file.\n\n    Args:\n        module_name (str): Name of the module.\n        file_path (str): Path to the file containing the module.\n\n    Returns:\n        Any: Imported module.\n    \"\"\"\n    if not os.path.exists(file_path):\n        print(f\"File does not exist: {file_path}\")\n        return None\n\n    if not module_name:\n        print(\"Module name is empty or invalid.\")\n        return None\n    try:\n        print(f\"Importing {module_name} from {file_path}...\")\n        spec = importlib.util.spec_from_file_location(module_name, file_path)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n        return module\n    except Exception as e:\n        error_type = type(e).__name__\n        print(f\"Error importing {module_name} ({error_type}): {str(e)}\")\n        return None\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.list_sketches","title":"<code>list_sketches(sketchbook_folder='./', sort='name', direction='ascending')</code>","text":"<p>Lists all sketches in the given sketchbook folder.</p> <p>Parameters:</p> Name Type Description Default <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> <code>sort</code> <code>str</code> <p>Sort sketches by name, size, modified or created. Defaults to 'name'.</p> <code>'name'</code> <code>direction</code> <code>str</code> <p>Sort direction, either 'ascending' or 'descending'. Defaults to 'ascending'.</p> <code>'ascending'</code> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def list_sketches(\n    sketchbook_folder: str = \"./\", sort: str = \"name\", direction: str = \"ascending\"\n) -&gt; None:\n    \"\"\"\n    Lists all sketches in the given sketchbook folder.\n\n    Args:\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n        sort (str): Sort sketches by name, size, modified or created. Defaults to 'name'.\n        direction (str): Sort direction, either 'ascending' or 'descending'. Defaults to 'ascending'.\n    \"\"\"\n    validate_sketchbook_path(sketchbook_folder)\n    sketch_files_list = get_sketchbook_files(sketchbook_folder)\n    sketches = get_sketchbook_files_info(sketch_files_list, sketchbook_folder)\n    sorted_sketches = sort_sketch_files(sketches, sort, direction)\n    pretty_print_sketchbook(sorted_sketches, sketchbook_folder)\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.main","title":"<code>main(*args, **kwargs)</code>","text":"<p>Main function for running the sketchbook from the command line.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def main(*args, **kwargs):\n    \"\"\"\n    Main function for running the sketchbook from the command line.\n    \"\"\"\n    if \"sketchbook\" in kwargs:\n        sketchbook = kwargs[\"sketchbook\"]\n    else:\n        sketchbook = \"./\"\n    if \"sketch\" in kwargs:\n        sketch = kwargs[\"sketch\"]\n        if isinstance(sketch, str):\n            run_sketch_by_name(sketch, sketchbook, *args, **kwargs)\n        elif isinstance(sketch, int):\n            print(f\"Running sketch by index: {sketch}\")\n            run_sketch_by_index(sketch, sketchbook, *args, **kwargs)\n    elif \"sketches\" in kwargs:\n        sort = kwargs[\"sort\"] if \"sort\" in kwargs else \"name\"\n        direction = kwargs[\"direction\"] if \"direction\" in kwargs else \"ascending\"\n        list_sketches(sketchbook, sort, direction)\n        exit()\n    elif \"random\" in kwargs:\n        run_random_sketch(sketchbook)\n    else:\n        list_sketches(sketchbook)\n        exit()\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.pretty_print_sketchbook","title":"<code>pretty_print_sketchbook(sketches, sketchbook_folder='./')</code>","text":"<p>Pretty prints the sketchbook information.</p> <p>Parameters:</p> Name Type Description Default <code>sketches</code> <code>List[Dict[str, Any]]</code> <p>List of sketch information dictionaries.</p> required <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def pretty_print_sketchbook(\n    sketches: List[Dict[str, Any]], sketchbook_folder: str = \"./\"\n) -&gt; None:\n    \"\"\"\n    Pretty prints the sketchbook information.\n\n    Args:\n        sketches (List[Dict[str, Any]]): List of sketch information dictionaries.\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n    \"\"\"\n    validate_sketchbook_path(sketchbook_folder)\n    print(f\"\\nSketchbook '{sketchbook_folder}':\\n\")\n    print(\n        f\"  {'Index':&lt;5} {'Sketch':&lt;25} {'Size':&lt;10} {'Modified':&lt;20} {'Created':&lt;20}\"\n    )\n    print(f\"  {'-'*5:&lt;5} {'-'*25:&lt;25} {'-'*10:&lt;10} {'-'*20:&lt;20} {'-'*20:&lt;20}\")\n    for i, sketch in enumerate(sketches):\n        print(\n            f\"  {i:&lt;5} {sketch['name']:&lt;25} {sketch['size']:&lt;10} {sketch['modified']:&lt;20} {sketch['created']:&lt;20}\"\n        )\n    print()\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.run_random_sketch","title":"<code>run_random_sketch(sketchbook='./')</code>","text":"<p>Runs a random sketch from the sketchbook.</p> <p>Parameters:</p> Name Type Description Default <code>sketchbook</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def run_random_sketch(sketchbook=\"./\"):\n    \"\"\"\n    Runs a random sketch from the sketchbook.\n\n    Args:\n        sketchbook (str): Path to the sketchbook folder. Defaults to current directory.\n    \"\"\"\n    validate_sketchbook_path(sketchbook)\n    files = get_sketchbook_files(sketchbook)\n    sketch_file = files[random.randint(0, len(files) - 1)]\n    run_sketch_by_name(sketch_file, sketchbook)\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.run_sketch_by_index","title":"<code>run_sketch_by_index(index, sketchbook_folder='./', *args, **kwargs)</code>","text":"<p>Runs a sketch by its index in the sketchbook.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>Index of the sketch to run.</p> required <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def run_sketch_by_index(\n    index: int, sketchbook_folder: str = \"./\", *args: Any, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Runs a sketch by its index in the sketchbook.\n\n    Args:\n        index (int): Index of the sketch to run.\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n    \"\"\"\n    validate_sketchbook_path(sketchbook_folder)\n    files = get_sketchbook_files(sketchbook_folder)\n    for file in files:\n        if file.endswith(\".py\"):\n            module_name = os.path.splitext(file)[0]\n            file_path = os.path.join(sketchbook_folder, file)\n            if str(index) == module_name:\n                try_import_and_run_sketch(module_name, file_path, *args, **kwargs)\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.run_sketch_by_name","title":"<code>run_sketch_by_name(sketch_file, sketchbook_folder='./', *args, **kwargs)</code>","text":"<p>Runs a sketch by its file name.</p> <p>Parameters:</p> Name Type Description Default <code>sketch_file</code> <code>str</code> <p>Name of the sketch file.</p> required <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def run_sketch_by_name(\n    sketch_file: str, sketchbook_folder: str = \"./\", *args: Any, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Runs a sketch by its file name.\n\n    Args:\n        sketch_file (str): Name of the sketch file.\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n    \"\"\"\n    validate_sketchbook_path(sketchbook_folder)\n    if not sketch_file.endswith(\".py\"):\n        sketch_file += \".py\"\n    file_path = os.path.join(sketchbook_folder, sketch_file)\n    module_name = os.path.splitext(sketch_file)[0]\n    try_import_and_run_sketch(module_name, file_path, *args, **kwargs)\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.run_sketch_function_from_module","title":"<code>run_sketch_function_from_module(module, function_name, file_path, *args, **kwargs)</code>","text":"<p>Runs a specific function from a given module.</p> <p>Parameters:</p> Name Type Description Default <code>module</code> <code>Any</code> <p>The imported module.</p> required <code>function_name</code> <code>str</code> <p>Name of the function to run.</p> required <code>file_path</code> <code>str</code> <p>Path to the file containing the module.</p> required Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def run_sketch_function_from_module(\n    module: Any, function_name: str, file_path: str, *args: Any, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Runs a specific function from a given module.\n\n    Args:\n        module (Any): The imported module.\n        function_name (str): Name of the function to run.\n        file_path (str): Path to the file containing the module.\n    \"\"\"\n    try:\n        if hasattr(module, function_name) and callable(getattr(module, function_name)):\n            print(f\"Running {function_name} from {file_path}...\")\n            getattr(module, function_name)(*args, **kwargs)\n        else:\n            print(f\"{module} does not have a '{function_name}' function.\")\n    except Exception as e:\n        print(f\"Error running {function_name} from {file_path}: {str(e)}\")\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.sort_sketch_files","title":"<code>sort_sketch_files(sketch_files, sort='name', direction='ascending')</code>","text":"<p>Sorts sketch files by name, size, modified or created.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>str</code> <p>Sort sketches by name, size, modified or created. Defaults to 'name'.</p> <code>'name'</code> <code>sketch_files</code> <code>List[Dict[str, Any]]</code> <p>List of sketch information dictionaries.</p> required <code>direction</code> <code>str</code> <p>Sort direction, either 'ascending' or 'descending'. Defaults to 'ascending'.</p> <code>'ascending'</code> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List[Dict[str, Any]]: List of sorted sketch information dictionaries.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def sort_sketch_files(\n    sketch_files: List[Dict[str, Any]], sort: str = \"name\", direction: str = \"ascending\"\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"\n    Sorts sketch files by name, size, modified or created.\n\n    Args:\n        sort (str): Sort sketches by name, size, modified or created. Defaults to 'name'.\n        sketch_files (List[Dict[str, Any]]): List of sketch information dictionaries.\n        direction (str): Sort direction, either 'ascending' or 'descending'. Defaults to 'ascending'.\n\n    Returns:\n        List[Dict[str, Any]]: List of sorted sketch information dictionaries.\n    \"\"\"\n    reverse = True if direction == \"descending\" else False\n    if sort == \"name\":\n        return sorted(sketch_files, key=lambda k: k[\"name\"], reverse=reverse)\n    elif sort == \"size\":\n        return sorted(sketch_files, key=lambda k: k[\"size\"], reverse=reverse)\n    elif sort == \"modified\":\n        return sorted(sketch_files, key=lambda k: k[\"modified\"], reverse=reverse)\n    elif sort == \"created\":\n        return sorted(sketch_files, key=lambda k: k[\"created\"], reverse=reverse)\n    else:\n        return sketch_files\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.try_import_and_run_sketch","title":"<code>try_import_and_run_sketch(module_name, file_path, *args, **kwargs)</code>","text":"<p>Tries to import and run a sketch from a given file.</p> <p>Parameters:</p> Name Type Description Default <code>module_name</code> <code>str</code> <p>Name of the module.</p> required <code>file_path</code> <code>str</code> <p>Path to the file containing the module.</p> required Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def try_import_and_run_sketch(\n    module_name: str, file_path: str, *args: Any, **kwargs: Any\n) -&gt; None:\n    \"\"\"\n    Tries to import and run a sketch from a given file.\n\n    Args:\n        module_name (str): Name of the module.\n        file_path (str): Path to the file containing the module.\n    \"\"\"\n    try:\n        module = import_sketch(module_name, file_path)\n        run_sketch_function_from_module(module, \"sketch\", file_path, *args, **kwargs)\n    except Exception as e:\n        print(f\"Error running {module_name}: {str(e)}\")\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.validate_sketch_file","title":"<code>validate_sketch_file(sketch_file, sketchbook_folder='./')</code>","text":"<p>Validates if the given sketch file exists in the sketchbook folder.</p> <p>Parameters:</p> Name Type Description Default <code>sketch_file</code> <code>str</code> <p>Name of the sketch file.</p> required <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If the sketch file does not exist.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def validate_sketch_file(sketch_file: str, sketchbook_folder: str = \"./\") -&gt; None:\n    \"\"\"\n    Validates if the given sketch file exists in the sketchbook folder.\n\n    Args:\n        sketch_file (str): Name of the sketch file.\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n\n    Raises:\n        SystemExit: If the sketch file does not exist.\n    \"\"\"\n    validate_sketchbook_path(sketchbook_folder)\n    if not sketch_file.endswith(\".py\"):\n        sketch_file += \".py\"\n    file_path = os.path.join(sketchbook_folder, sketch_file)\n    if not os.path.isfile(file_path):\n        print(f\"Sketch file '{file_path}' does not exist.\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/tolvera/sketchbook/#tolvera.sketchbook.validate_sketchbook_path","title":"<code>validate_sketchbook_path(sketchbook_folder='./')</code>","text":"<p>Validates if the given sketchbook folder exists.</p> <p>Parameters:</p> Name Type Description Default <code>sketchbook_folder</code> <code>str</code> <p>Path to the sketchbook folder. Defaults to current directory.</p> <code>'./'</code> <p>Raises:</p> Type Description <code>SystemExit</code> <p>If the sketchbook folder does not exist.</p> Source code in <code>src/tolvera/sketchbook.py</code> <pre><code>def validate_sketchbook_path(sketchbook_folder: str = \"./\") -&gt; None:\n    \"\"\"\n    Validates if the given sketchbook folder exists.\n\n    Args:\n        sketchbook_folder (str): Path to the sketchbook folder. Defaults to current directory.\n\n    Raises:\n        SystemExit: If the sketchbook folder does not exist.\n    \"\"\"\n    if not os.path.isdir(sketchbook_folder):\n        print(f\"Sketchbook folder '{sketchbook_folder}' does not exist.\")\n        sys.exit(1)\n</code></pre>"},{"location":"reference/tolvera/species/","title":"Species","text":""},{"location":"reference/tolvera/state/","title":"State","text":"<p>State and StateDict classes for T\u00f6lvera.</p> <p>Every T\u00f6lvera instance has a StateDict, which is a dictionary of State instances. The StateDict is accessible via the 's' attribute of a T\u00f6lvera instance, and can be used to create and access states.</p> <p>Each State instance has a Taichi struct field and a corresponding NpNdarrayDict, which handles OSC and IML accessors and endpoints.</p>"},{"location":"reference/tolvera/state/#tolvera.state.State","title":"<code>State</code>","text":"<p>State class for T\u00f6lvera.</p> <p>This class takes a name, dictionary of state attributes, and a shape, and creates a Taichi struct field and a corresponding dictionary of NumPy arrays  (NpNdarrayDict) for a state.</p> <p>The Taichi struct field can be used in Taichi scope, and the NpNdarrayDict can be used in Python scope, and the two are kept in sync by the from_nddict() and to_nddict() methods.</p> <p>The State class also handles IML and OSC accessors for the state, which use the NpNdarrayDict to get and set data. A T\u00f6lvera instance is therefore required to initialise a State instance.</p> <p>State attributes are defined as a dictionary of attribute names and tuples of (Taichi type, min value, max value). The domain of the attribute is used when randomising the data in the state, and by OSCMap endpoints and client patches.</p> <p>The state is n-dimensional based on the shape argument, and the NpNdarrayDict provides methods for accessing the data in the state in n-dimensional slices.</p> Example <p>state = State(     tolvera,     name=\"state\",     state={         \"pos\": (ti.f32, -1.0, 1.0),         \"vel\": (ti.f32, -1.0, 1.0),         \"acc\": (ti.f32, -1.0, 1.0),     },     shape=10,     iml=\"get\",     osc=\"get\",     randomise=True, )</p> Source code in <code>src/tolvera/state.py</code> <pre><code>@ti.data_oriented\nclass State:\n    \"\"\"State class for T\u00f6lvera.\n\n    This class takes a name, dictionary of state attributes, and a shape, and\n    creates a Taichi struct field and a corresponding dictionary of NumPy arrays \n    (NpNdarrayDict) for a state.\n\n    The Taichi struct field can be used in Taichi scope, and the NpNdarrayDict\n    can be used in Python scope, and the two are kept in sync by the from_nddict()\n    and to_nddict() methods.\n\n    The State class also handles IML and OSC accessors for the state, which use the\n    NpNdarrayDict to get and set data. A T\u00f6lvera instance is therefore required\n    to initialise a State instance.\n\n    State attributes are defined as a dictionary of attribute names and tuples of\n    (Taichi type, min value, max value). The domain of the attribute is used when\n    randomising the data in the state, and by OSCMap endpoints and client patches.\n\n    The state is n-dimensional based on the shape argument, and the NpNdarrayDict\n    provides methods for accessing the data in the state in n-dimensional slices.\n\n    Example:\n        state = State(\n            tolvera,\n            name=\"state\",\n            state={\n                \"pos\": (ti.f32, -1.0, 1.0),\n                \"vel\": (ti.f32, -1.0, 1.0),\n                \"acc\": (ti.f32, -1.0, 1.0),\n            },\n            shape=10,\n            iml=\"get\",\n            osc=\"get\",\n            randomise=True,\n        )\n    \"\"\"\n    def __init__(\n        self,\n        tolvera,\n        name: str,\n        state: dict[str, tuple[DataType, Any, Any]],\n        shape: int | tuple[int] = None,\n        iml: str | tuple = None,  # 'get' | ('get', 'set')\n        osc: str | tuple = None,  # 'get' | ('get', 'set')\n        randomise: bool = True,\n        methods: dict[str, Any] = None,\n    ):\n        \"\"\"Initialise a state for T\u00f6lvera.\n\n        Args:\n            tolvera (Tolvera): Tolvera instance to which this state belongs.\n            name (str): Name of this state.\n            state (dict[str, tuple[DataType, Any, Any]]): Dict of state attributes.\n            shape (int | tuple[int], optional): Shape of the state. Defaults to 1.\n            iml (str | tuple, optional): Flag for IML via Anguilla. Defaults to False.\n            methods (dict[str, Any], optional): Flag for OSC via iipyper. Defaults to False.\n        \"\"\"\n        self.tv = tolvera\n        assert name is not None, \"State must have a name.\"\n        self.name = name\n        shape = 1 if shape is None else shape\n        self.setup_data(state, shape, randomise, methods)\n        self.setup_accessors(iml, osc)\n\n    def setup_data(\n        self,\n        dict: dict[str, tuple[DataType, Any, Any]],\n        shape: int | tuple[int],\n        randomise: bool = True,\n        methods: dict[str, Any] = None,\n    ):\n        \"\"\"Setup data structures and data for this state.\n\n        Args:\n            dict (dict[str, tuple[DataType, Any, Any]]): Dict of state attributes.\n            shape (int | tuple[int]): Shape of the state.\n            randomise (bool, optional): Flag to randomise the data on creation. Defaults to True.\n            methods (dict[str, Any], optional): Dict of Taichi field struct methods. Defaults to None.\n        \"\"\"\n        self.create_struct_field(dict, shape, methods)\n        self.create_npndarray_dict()\n        if randomise:\n            self.randomise()\n\n    def create_struct_field(\n        self,\n        dict: dict[str, tuple[DataType, Any, Any]],\n        shape: int | tuple[int],\n        methods: dict[str, Any] = None,\n    ):\n        \"\"\"Create a Taichi struct field for this state.\n\n        Args:\n            dict (dict[str, tuple[DataType, Any, Any]]): Dict of state attributes.\n            shape (int | tuple[int]): Shape of the state.\n            methods (dict[str, Any], optional): Dict of Taichi field struct methods. Defaults to None.\n        \"\"\"\n        self.dict = dict\n        self.shape = (shape,) if isinstance(shape, int) else shape\n        if methods is None:\n            self.struct = ti.types.struct(**{k: v[0] for k, v in self.dict.items()})\n        else:\n            self.methods = methods if methods is not None else {}\n            self.struct = ti.types.struct(\n                **{k: v[0] for k, v in self.dict.items()}, methods=self.methods\n            )\n        self.field = self.struct.field(shape=self.shape)\n\n    def create_npndarray_dict(self):\n        \"\"\"Create a NpNdarrayDict for this state.\n\n        Raises:\n            NotImplementedError: If no Numpy type is found for a Taichi type.\n        \"\"\"\n        nddict = {}\n        for k, v in self.dict.items():\n            titype, min_val, max_val = v\n            nptype = TiNpTypeMap.get(titype)\n            if nptype is None:\n                raise NotImplementedError(f\"no nptype for {titype}\")\n            nddict[k] = (nptype, min_val, max_val)\n        self.nddict = NpNdarrayDict(nddict, self.shape)\n        self.size = self.nddict.size\n\n    def randomise(self):\n        \"\"\"Randomise the data in this state.\"\"\"\n        self.nddict.randomise()\n        self.from_nddict()\n\n    def setup_accessors(self, iml: tuple = None, osc: tuple = None):\n        \"\"\"Setup IML and OSC accessors for this state.\"\"\"\n        self.setter_name = f\"{self.tv.name_clean}_set_{self.name}\"\n        self.getter_name = f\"{self.tv.name_clean}_get_{self.name}\"\n        self.handle_accessor_flags(iml, osc)\n        if self.tv.iml is not False and self.iml:\n            self.setup_iml_mapping()\n        if self.tv.osc is not False and self.osc:\n            self.setup_osc_mapping()\n\n    def handle_accessor_flags(self, iml, osc):\n        self.iml, self.iml_get, self.iml_set = self.handle_get_set(iml)\n        self.osc, self.osc_get, self.osc_set = self.handle_get_set(osc)\n\n    def handle_get_set(self, flag):\n        enabled = flag is not None\n        if isinstance(flag, str):\n            flag = (flag,)\n        get = \"get\" in flag if enabled else False\n        set = \"set\" in flag if enabled else False\n        return enabled, get, set\n\n    def setup_iml_mapping(self):\n        self.iml = self.tv.iml\n        # if self.iml_set:\n        #     self.add_iml_setters()\n        # if self.iml_get:\n        #     self.add_iml_getters()\n\n    def add_iml_setters(self):\n        name = self.setter_name\n        \"\"\"\n        self.iml[name] = IMLOSCToFunc(self.tv)\n        \"\"\"\n        self.iml.add_instance(name + \"\")\n\n    def add_iml_getters(self):\n        name = self.getter_name\n        \"\"\"\n        self.iml[name] = IMLFuncToOSC(self.tv)\n        \"\"\"\n        self.iml.add_instance(name + \"\")\n\n    def setup_osc_mapping(self):\n        self.osc = self.tv.osc\n        if self.osc_set:\n            self.add_osc_setters()\n        #     if self.iml_set:\n        #         self.add_iml_osc_setters()\n        # if self.osc_get:\n        #     self.add_osc_getters()\n        #     if self.iml_get:\n        #         self.add_iml_osc_getters()\n\n    def add_osc_setters(self):\n        name = self.setter_name\n        self.osc.map.receive_args_inline(name + \"_randomise\", self.randomise)\n\n    def add_osc_getters(self):\n        name = self.getter_name\n        for k, v in self.dict.items():\n            ranges = (int(v[0]), int(v[0]), int(v[1]))\n            kwargs = {\"i\": ranges, \"j\": ranges, \"attr\": (k, k, k)}\n            self.osc.map.receive_args_inline(f\"{name}\", self.osc_getter, **kwargs)\n\n    def osc_getter(self, i: int, j: int, attribute: str):\n        ret = self.get((i, j), attribute)\n        if ret is not None:\n            route = self.osc.map.pascal_to_path(self.getter_name)  # +'/'+attribute\n            self.osc.host.return_to_sender_by_name(\n                (route, attribute, ret), self.osc.client_name\n            )\n        return ret\n\n    def add_osc_streams(self, name):\n        # add send in broadcast mode\n        raise NotImplementedError(\"add_osc_streams not implemented\")\n\n    def add_iml_osc_setters(self):\n        name = self.setter_name\n\n    def add_iml_osc_getters(self):\n        name = self.getter_name\n\n    def serialize(self) -&gt; str:\n        return ti_serialize(self.field)\n\n    def deserialize(self, json_str: str):\n        ti_deserialize(self.field, json_str)\n\n    def save(self, path: str):\n        # TODO: path validation, save to path, etc.\n        json_str = self.serialize()\n        raise NotImplementedError(\"save not implemented\")\n\n    def load(self, path: str):\n        # TODO: path validation, file ext., etc.\n        # TODO: data validation (pydantic?)\n        json_str = jsons.load(path)\n        self.deserialize(json_str)\n        raise NotImplementedError(\"load not implemented\")\n\n    def from_nddict(self):\n        \"\"\"Copy data from NpNdarrayDict to Taichi field.\n\n        Raises:\n            Exception: If data cannot be copied.\n        \"\"\"\n        try:\n            data = self.nddict.get_data()\n            self.field.from_numpy(data)\n        except Exception as e:\n            raise Exception(f\"[tolvera.state.from_nddict] {e}\") from e\n\n    def to_nddict(self):\n        \"\"\"Copy data from Taichi field to NpNdarrayDict.\n\n        Raises:\n            Exception: If data cannot be copied.\n        \"\"\"\n        try:\n            data = self.field.to_numpy()\n            self.nddict.set_data(data)\n        except Exception as e:\n            raise Exception(f\"[tolvera.state.to_nddict] {e}\") from e\n\n    \"\"\"\n    npndarray_dict wrappers\n    \"\"\"\n\n    def from_vec(self, vec: list):\n        \"\"\"Wrapper for NpNdarrayDict.from_vec().\"\"\"\n        self.to_nddict()\n        self.nddict.from_vec(vec)\n        self.from_nddict()\n\n    def to_vec(self) -&gt; list:\n        \"\"\"Wrapper for NpNdarrayDict.to_vec().\"\"\"\n        self.to_nddict()\n        return self.nddict.to_vec()\n\n    def attr_from_vec(self, attr: str, vec: list):\n        \"\"\"Wrapper for NpNdarrayDict.attr_from_vec().\"\"\"\n        self.to_nddict()\n        self.nddict.attr_from_vec(attr, vec)\n        self.from_nddict()\n\n    def attr_to_vec(self, attr: str) -&gt; list:\n        \"\"\"Wrapper for NpNdarrayDict.attr_to_vec().\"\"\"\n        self.to_nddict()\n        return self.nddict.attr_to_vec(attr)\n\n    def slice_from_vec(self, slice_args: list, slice_vec: list):\n        \"\"\"Wrapper for NpNdarrayDict.slice_from_vec().\"\"\"\n        self.to_nddict()\n        self.nddict.slice_from_vec(slice_args, slice_vec)\n        self.from_nddict()\n\n    def slice_to_vec(self, slice_args: list) -&gt; list:\n        \"\"\"Wrapper for NpNdarrayDict.slice_to_vec().\"\"\"\n        self.to_nddict()\n        return self.nddict.slice_to_vec(slice_args)\n\n    def attr_slice_from_vec(self, attr: str, slice_args: list, slice_vec: list):\n        \"\"\"Wrapper for NpNdarrayDict.attr_slice_from_vec().\"\"\"\n        self.to_nddict()\n        self.nddict.attr_slice_from_vec(attr, slice_args, slice_vec)\n        self.from_nddict()\n\n    def attr_slice_to_vec(self, attr: str, slice_args: list) -&gt; list:\n        \"\"\"Wrapper for NpNdarrayDict.attr_slice_to_vec().\"\"\"\n        self.to_nddict()\n        return self.nddict.attr_slice_to_vec(attr, slice_args)\n\n    def attr_size(self, attr: str) -&gt; int:\n        \"\"\"Return the size of the attribute.\"\"\"\n        return self.nddict.data[attr].size\n\n    @ti.func\n    def __getitem__(self, key: str) -&gt; Any:\n        \"\"\"Return the Taichi field attribute.\n\n        Args:\n            key (str): Attribute name.\"\"\"\n        return self.field[key]\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n        \"\"\"Return the Taichi field.\"\"\"\n        return self.field\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.__call__","title":"<code>__call__(*args, **kwds)</code>","text":"<p>Return the Taichi field.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n    \"\"\"Return the Taichi field.\"\"\"\n    return self.field\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Return the Taichi field attribute.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Attribute name.</p> required Source code in <code>src/tolvera/state.py</code> <pre><code>@ti.func\ndef __getitem__(self, key: str) -&gt; Any:\n    \"\"\"Return the Taichi field attribute.\n\n    Args:\n        key (str): Attribute name.\"\"\"\n    return self.field[key]\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.__init__","title":"<code>__init__(tolvera, name, state, shape=None, iml=None, osc=None, randomise=True, methods=None)</code>","text":"<p>Initialise a state for T\u00f6lvera.</p> <p>Parameters:</p> Name Type Description Default <code>tolvera</code> <code>Tolvera</code> <p>Tolvera instance to which this state belongs.</p> required <code>name</code> <code>str</code> <p>Name of this state.</p> required <code>state</code> <code>dict[str, tuple[DataType, Any, Any]]</code> <p>Dict of state attributes.</p> required <code>shape</code> <code>int | tuple[int]</code> <p>Shape of the state. Defaults to 1.</p> <code>None</code> <code>iml</code> <code>str | tuple</code> <p>Flag for IML via Anguilla. Defaults to False.</p> <code>None</code> <code>methods</code> <code>dict[str, Any]</code> <p>Flag for OSC via iipyper. Defaults to False.</p> <code>None</code> Source code in <code>src/tolvera/state.py</code> <pre><code>def __init__(\n    self,\n    tolvera,\n    name: str,\n    state: dict[str, tuple[DataType, Any, Any]],\n    shape: int | tuple[int] = None,\n    iml: str | tuple = None,  # 'get' | ('get', 'set')\n    osc: str | tuple = None,  # 'get' | ('get', 'set')\n    randomise: bool = True,\n    methods: dict[str, Any] = None,\n):\n    \"\"\"Initialise a state for T\u00f6lvera.\n\n    Args:\n        tolvera (Tolvera): Tolvera instance to which this state belongs.\n        name (str): Name of this state.\n        state (dict[str, tuple[DataType, Any, Any]]): Dict of state attributes.\n        shape (int | tuple[int], optional): Shape of the state. Defaults to 1.\n        iml (str | tuple, optional): Flag for IML via Anguilla. Defaults to False.\n        methods (dict[str, Any], optional): Flag for OSC via iipyper. Defaults to False.\n    \"\"\"\n    self.tv = tolvera\n    assert name is not None, \"State must have a name.\"\n    self.name = name\n    shape = 1 if shape is None else shape\n    self.setup_data(state, shape, randomise, methods)\n    self.setup_accessors(iml, osc)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.attr_from_vec","title":"<code>attr_from_vec(attr, vec)</code>","text":"<p>Wrapper for NpNdarrayDict.attr_from_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def attr_from_vec(self, attr: str, vec: list):\n    \"\"\"Wrapper for NpNdarrayDict.attr_from_vec().\"\"\"\n    self.to_nddict()\n    self.nddict.attr_from_vec(attr, vec)\n    self.from_nddict()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.attr_size","title":"<code>attr_size(attr)</code>","text":"<p>Return the size of the attribute.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def attr_size(self, attr: str) -&gt; int:\n    \"\"\"Return the size of the attribute.\"\"\"\n    return self.nddict.data[attr].size\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.attr_slice_from_vec","title":"<code>attr_slice_from_vec(attr, slice_args, slice_vec)</code>","text":"<p>Wrapper for NpNdarrayDict.attr_slice_from_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def attr_slice_from_vec(self, attr: str, slice_args: list, slice_vec: list):\n    \"\"\"Wrapper for NpNdarrayDict.attr_slice_from_vec().\"\"\"\n    self.to_nddict()\n    self.nddict.attr_slice_from_vec(attr, slice_args, slice_vec)\n    self.from_nddict()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.attr_slice_to_vec","title":"<code>attr_slice_to_vec(attr, slice_args)</code>","text":"<p>Wrapper for NpNdarrayDict.attr_slice_to_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def attr_slice_to_vec(self, attr: str, slice_args: list) -&gt; list:\n    \"\"\"Wrapper for NpNdarrayDict.attr_slice_to_vec().\"\"\"\n    self.to_nddict()\n    return self.nddict.attr_slice_to_vec(attr, slice_args)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.attr_to_vec","title":"<code>attr_to_vec(attr)</code>","text":"<p>Wrapper for NpNdarrayDict.attr_to_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def attr_to_vec(self, attr: str) -&gt; list:\n    \"\"\"Wrapper for NpNdarrayDict.attr_to_vec().\"\"\"\n    self.to_nddict()\n    return self.nddict.attr_to_vec(attr)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.create_npndarray_dict","title":"<code>create_npndarray_dict()</code>","text":"<p>Create a NpNdarrayDict for this state.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If no Numpy type is found for a Taichi type.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def create_npndarray_dict(self):\n    \"\"\"Create a NpNdarrayDict for this state.\n\n    Raises:\n        NotImplementedError: If no Numpy type is found for a Taichi type.\n    \"\"\"\n    nddict = {}\n    for k, v in self.dict.items():\n        titype, min_val, max_val = v\n        nptype = TiNpTypeMap.get(titype)\n        if nptype is None:\n            raise NotImplementedError(f\"no nptype for {titype}\")\n        nddict[k] = (nptype, min_val, max_val)\n    self.nddict = NpNdarrayDict(nddict, self.shape)\n    self.size = self.nddict.size\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.create_struct_field","title":"<code>create_struct_field(dict, shape, methods=None)</code>","text":"<p>Create a Taichi struct field for this state.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>dict[str, tuple[DataType, Any, Any]]</code> <p>Dict of state attributes.</p> required <code>shape</code> <code>int | tuple[int]</code> <p>Shape of the state.</p> required <code>methods</code> <code>dict[str, Any]</code> <p>Dict of Taichi field struct methods. Defaults to None.</p> <code>None</code> Source code in <code>src/tolvera/state.py</code> <pre><code>def create_struct_field(\n    self,\n    dict: dict[str, tuple[DataType, Any, Any]],\n    shape: int | tuple[int],\n    methods: dict[str, Any] = None,\n):\n    \"\"\"Create a Taichi struct field for this state.\n\n    Args:\n        dict (dict[str, tuple[DataType, Any, Any]]): Dict of state attributes.\n        shape (int | tuple[int]): Shape of the state.\n        methods (dict[str, Any], optional): Dict of Taichi field struct methods. Defaults to None.\n    \"\"\"\n    self.dict = dict\n    self.shape = (shape,) if isinstance(shape, int) else shape\n    if methods is None:\n        self.struct = ti.types.struct(**{k: v[0] for k, v in self.dict.items()})\n    else:\n        self.methods = methods if methods is not None else {}\n        self.struct = ti.types.struct(\n            **{k: v[0] for k, v in self.dict.items()}, methods=self.methods\n        )\n    self.field = self.struct.field(shape=self.shape)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.from_nddict","title":"<code>from_nddict()</code>","text":"<p>Copy data from NpNdarrayDict to Taichi field.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If data cannot be copied.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def from_nddict(self):\n    \"\"\"Copy data from NpNdarrayDict to Taichi field.\n\n    Raises:\n        Exception: If data cannot be copied.\n    \"\"\"\n    try:\n        data = self.nddict.get_data()\n        self.field.from_numpy(data)\n    except Exception as e:\n        raise Exception(f\"[tolvera.state.from_nddict] {e}\") from e\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.from_vec","title":"<code>from_vec(vec)</code>","text":"<p>Wrapper for NpNdarrayDict.from_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def from_vec(self, vec: list):\n    \"\"\"Wrapper for NpNdarrayDict.from_vec().\"\"\"\n    self.to_nddict()\n    self.nddict.from_vec(vec)\n    self.from_nddict()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.randomise","title":"<code>randomise()</code>","text":"<p>Randomise the data in this state.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def randomise(self):\n    \"\"\"Randomise the data in this state.\"\"\"\n    self.nddict.randomise()\n    self.from_nddict()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.setup_accessors","title":"<code>setup_accessors(iml=None, osc=None)</code>","text":"<p>Setup IML and OSC accessors for this state.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def setup_accessors(self, iml: tuple = None, osc: tuple = None):\n    \"\"\"Setup IML and OSC accessors for this state.\"\"\"\n    self.setter_name = f\"{self.tv.name_clean}_set_{self.name}\"\n    self.getter_name = f\"{self.tv.name_clean}_get_{self.name}\"\n    self.handle_accessor_flags(iml, osc)\n    if self.tv.iml is not False and self.iml:\n        self.setup_iml_mapping()\n    if self.tv.osc is not False and self.osc:\n        self.setup_osc_mapping()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.setup_data","title":"<code>setup_data(dict, shape, randomise=True, methods=None)</code>","text":"<p>Setup data structures and data for this state.</p> <p>Parameters:</p> Name Type Description Default <code>dict</code> <code>dict[str, tuple[DataType, Any, Any]]</code> <p>Dict of state attributes.</p> required <code>shape</code> <code>int | tuple[int]</code> <p>Shape of the state.</p> required <code>randomise</code> <code>bool</code> <p>Flag to randomise the data on creation. Defaults to True.</p> <code>True</code> <code>methods</code> <code>dict[str, Any]</code> <p>Dict of Taichi field struct methods. Defaults to None.</p> <code>None</code> Source code in <code>src/tolvera/state.py</code> <pre><code>def setup_data(\n    self,\n    dict: dict[str, tuple[DataType, Any, Any]],\n    shape: int | tuple[int],\n    randomise: bool = True,\n    methods: dict[str, Any] = None,\n):\n    \"\"\"Setup data structures and data for this state.\n\n    Args:\n        dict (dict[str, tuple[DataType, Any, Any]]): Dict of state attributes.\n        shape (int | tuple[int]): Shape of the state.\n        randomise (bool, optional): Flag to randomise the data on creation. Defaults to True.\n        methods (dict[str, Any], optional): Dict of Taichi field struct methods. Defaults to None.\n    \"\"\"\n    self.create_struct_field(dict, shape, methods)\n    self.create_npndarray_dict()\n    if randomise:\n        self.randomise()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.slice_from_vec","title":"<code>slice_from_vec(slice_args, slice_vec)</code>","text":"<p>Wrapper for NpNdarrayDict.slice_from_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def slice_from_vec(self, slice_args: list, slice_vec: list):\n    \"\"\"Wrapper for NpNdarrayDict.slice_from_vec().\"\"\"\n    self.to_nddict()\n    self.nddict.slice_from_vec(slice_args, slice_vec)\n    self.from_nddict()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.slice_to_vec","title":"<code>slice_to_vec(slice_args)</code>","text":"<p>Wrapper for NpNdarrayDict.slice_to_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def slice_to_vec(self, slice_args: list) -&gt; list:\n    \"\"\"Wrapper for NpNdarrayDict.slice_to_vec().\"\"\"\n    self.to_nddict()\n    return self.nddict.slice_to_vec(slice_args)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.to_nddict","title":"<code>to_nddict()</code>","text":"<p>Copy data from Taichi field to NpNdarrayDict.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If data cannot be copied.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def to_nddict(self):\n    \"\"\"Copy data from Taichi field to NpNdarrayDict.\n\n    Raises:\n        Exception: If data cannot be copied.\n    \"\"\"\n    try:\n        data = self.field.to_numpy()\n        self.nddict.set_data(data)\n    except Exception as e:\n        raise Exception(f\"[tolvera.state.to_nddict] {e}\") from e\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.State.to_vec","title":"<code>to_vec()</code>","text":"<p>Wrapper for NpNdarrayDict.to_vec().</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def to_vec(self) -&gt; list:\n    \"\"\"Wrapper for NpNdarrayDict.to_vec().\"\"\"\n    self.to_nddict()\n    return self.nddict.to_vec()\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict","title":"<code>StateDict</code>","text":"<p>             Bases: <code>dotdict</code></p> <p>StateDict class for T\u00f6lvera.</p> <p>This class is a dictionary of State instances, and is accessible via the 's' attribute of a T\u00f6lvera instance.</p> <p>States can be created by assigning a dictionary or a tuple to a StateDict key. and can be used in Taichi scope and Python scope respectively.</p> Example <p>tv = Tolvera(**kwargs)</p> <p>tv.s.mystate = {     \"state\": {         \"id\":  (ti.i32, 0, tv.pn - 1),         \"pos\": (ti.math.vec2, -1.0, 1.0),         \"vel\": (ti.math.vec2, -1.0, 1.0),     },      \"shape\": (tv.pn, 1),      \"iml\": \"get\",      \"osc\": \"get\",      \"randomise\": True }</p> <p>tv.s.mystate.field.pos[0] = 0.5</p> Source code in <code>src/tolvera/state.py</code> <pre><code>class StateDict(dotdict):\n    \"\"\"StateDict class for T\u00f6lvera.\n\n    This class is a dictionary of State instances, and is accessible via the 's'\n    attribute of a T\u00f6lvera instance.\n\n    States can be created by assigning a dictionary or a tuple to a StateDict key.\n    and can be used in Taichi scope and Python scope respectively.\n\n    Example:\n        tv = Tolvera(**kwargs)\n\n        tv.s.mystate = {\n            \"state\": {\n                \"id\":  (ti.i32, 0, tv.pn - 1),\n                \"pos\": (ti.math.vec2, -1.0, 1.0),\n                \"vel\": (ti.math.vec2, -1.0, 1.0),\n            }, \n            \"shape\": (tv.pn, 1), \n            \"iml\": \"get\", \n            \"osc\": \"get\", \n            \"randomise\": True\n        }\n\n        tv.s.mystate.field.pos[0] = 0.5\n    \"\"\"\n    def __init__(self, tolvera) -&gt; None:\n        \"\"\"Initialise a StateDict for T\u00f6lvera.\n\n        Args:\n            tolvera (Tolvera): Tolvera instance to which this StateDict belongs.\n        \"\"\"\n        self.tv = tolvera\n        self.size = 0\n\n    def set(self, name, kwargs: Any) -&gt; None:\n        \"\"\"Set a state in the StateDict.\n\n        Args:\n            name (str): Name of the state.\n            kwargs (Any): State attributes.\n\n        Raises:\n            ValueError: If the state is already in the StateDict.\n            Exception: If the state cannot be added.\n        \"\"\"\n        if name in self and name != \"size\":\n            raise ValueError(f\"[tolvera.state.StateDict] '{name}' already in dict.\")\n        try:\n            self.add(name, kwargs)\n        except Exception as e:\n            raise type(e)(f\"[tolvera.state.StateDict] {e}\") from e\n\n    def add(self, name, kwargs: Any):\n        \"\"\"Add a state to the StateDict.\n\n        Args:\n            name (str): Name of the state.\n            kwargs (Any): State attributes.\n\n        Raises:\n            TypeError: If kwargs is not a dict or tuple.\n        \"\"\"\n        if name == \"tv\" and type(kwargs) is not dict and type(kwargs) is not tuple:\n            self[name] = kwargs\n        elif name == \"size\" and type(kwargs) is int:\n            self[name] = kwargs\n        elif type(kwargs) is dict:\n            self[name] = State(self.tv, name=name, **kwargs)\n            self.size += self[name].size\n        elif type(kwargs) is tuple:\n            self[name] = State(self.tv, name, *kwargs)\n            self.size += self[name].size\n        else:\n            raise TypeError(\n                f\"[tolvera.state.StateDict] set() requires dict|tuple, not {type(kwargs)}\"\n            )\n\n    def from_vec(self, states: list[str], vector: list[float]):\n        \"\"\"Copy data from a vector to states in the StateDict.\n\n        Args:\n            states (list[str]): List of state names.\n            vector (list[float]): Vector of data to copy.\n\n        Raises:\n            Exception: If the vector is not the correct size.\n        \"\"\"\n        sizes_sum = self.get_size(states)\n        assert sizes_sum == len(\n            vector\n        ), f\"sizes_sum={sizes_sum} != len(vector)={len(vector)}\"\n        vec_start = 0\n        for state in states:\n            s = self.tv.s[state]\n            vec = vector[vec_start : vec_start + s.size]\n            s.from_vec(vec)\n            vec_start += s.size\n\n    def get_size(self, states: str | list[str]) -&gt; int:\n        \"\"\"Return the size of the states in the StateDict.\n\n        Args:\n            states (str | list[str]): State name or list of state names.\n\n        Returns:\n            int: Size of the states.\n        \"\"\"\n        if isinstance(states, str):\n            states = [states]\n        return sum([self.tv.s[state].size for state in states])\n\n    def __setattr__(self, __name: str, __value: Any) -&gt; None:\n        \"\"\"Set a state in the StateDict.\n\n        Args:\n            __name (str): Name of the state.\n            __value (Any): State attributes.\n        \"\"\"\n        self.set(__name, __value)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict.__init__","title":"<code>__init__(tolvera)</code>","text":"<p>Initialise a StateDict for T\u00f6lvera.</p> <p>Parameters:</p> Name Type Description Default <code>tolvera</code> <code>Tolvera</code> <p>Tolvera instance to which this StateDict belongs.</p> required Source code in <code>src/tolvera/state.py</code> <pre><code>def __init__(self, tolvera) -&gt; None:\n    \"\"\"Initialise a StateDict for T\u00f6lvera.\n\n    Args:\n        tolvera (Tolvera): Tolvera instance to which this StateDict belongs.\n    \"\"\"\n    self.tv = tolvera\n    self.size = 0\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict.__setattr__","title":"<code>__setattr__(__name, __value)</code>","text":"<p>Set a state in the StateDict.</p> <p>Parameters:</p> Name Type Description Default <code>__name</code> <code>str</code> <p>Name of the state.</p> required <code>__value</code> <code>Any</code> <p>State attributes.</p> required Source code in <code>src/tolvera/state.py</code> <pre><code>def __setattr__(self, __name: str, __value: Any) -&gt; None:\n    \"\"\"Set a state in the StateDict.\n\n    Args:\n        __name (str): Name of the state.\n        __value (Any): State attributes.\n    \"\"\"\n    self.set(__name, __value)\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict.add","title":"<code>add(name, kwargs)</code>","text":"<p>Add a state to the StateDict.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state.</p> required <code>kwargs</code> <code>Any</code> <p>State attributes.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>If kwargs is not a dict or tuple.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def add(self, name, kwargs: Any):\n    \"\"\"Add a state to the StateDict.\n\n    Args:\n        name (str): Name of the state.\n        kwargs (Any): State attributes.\n\n    Raises:\n        TypeError: If kwargs is not a dict or tuple.\n    \"\"\"\n    if name == \"tv\" and type(kwargs) is not dict and type(kwargs) is not tuple:\n        self[name] = kwargs\n    elif name == \"size\" and type(kwargs) is int:\n        self[name] = kwargs\n    elif type(kwargs) is dict:\n        self[name] = State(self.tv, name=name, **kwargs)\n        self.size += self[name].size\n    elif type(kwargs) is tuple:\n        self[name] = State(self.tv, name, *kwargs)\n        self.size += self[name].size\n    else:\n        raise TypeError(\n            f\"[tolvera.state.StateDict] set() requires dict|tuple, not {type(kwargs)}\"\n        )\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict.from_vec","title":"<code>from_vec(states, vector)</code>","text":"<p>Copy data from a vector to states in the StateDict.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>list[str]</code> <p>List of state names.</p> required <code>vector</code> <code>list[float]</code> <p>Vector of data to copy.</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>If the vector is not the correct size.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def from_vec(self, states: list[str], vector: list[float]):\n    \"\"\"Copy data from a vector to states in the StateDict.\n\n    Args:\n        states (list[str]): List of state names.\n        vector (list[float]): Vector of data to copy.\n\n    Raises:\n        Exception: If the vector is not the correct size.\n    \"\"\"\n    sizes_sum = self.get_size(states)\n    assert sizes_sum == len(\n        vector\n    ), f\"sizes_sum={sizes_sum} != len(vector)={len(vector)}\"\n    vec_start = 0\n    for state in states:\n        s = self.tv.s[state]\n        vec = vector[vec_start : vec_start + s.size]\n        s.from_vec(vec)\n        vec_start += s.size\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict.get_size","title":"<code>get_size(states)</code>","text":"<p>Return the size of the states in the StateDict.</p> <p>Parameters:</p> Name Type Description Default <code>states</code> <code>str | list[str]</code> <p>State name or list of state names.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Size of the states.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def get_size(self, states: str | list[str]) -&gt; int:\n    \"\"\"Return the size of the states in the StateDict.\n\n    Args:\n        states (str | list[str]): State name or list of state names.\n\n    Returns:\n        int: Size of the states.\n    \"\"\"\n    if isinstance(states, str):\n        states = [states]\n    return sum([self.tv.s[state].size for state in states])\n</code></pre>"},{"location":"reference/tolvera/state/#tolvera.state.StateDict.set","title":"<code>set(name, kwargs)</code>","text":"<p>Set a state in the StateDict.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the state.</p> required <code>kwargs</code> <code>Any</code> <p>State attributes.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the state is already in the StateDict.</p> <code>Exception</code> <p>If the state cannot be added.</p> Source code in <code>src/tolvera/state.py</code> <pre><code>def set(self, name, kwargs: Any) -&gt; None:\n    \"\"\"Set a state in the StateDict.\n\n    Args:\n        name (str): Name of the state.\n        kwargs (Any): State attributes.\n\n    Raises:\n        ValueError: If the state is already in the StateDict.\n        Exception: If the state cannot be added.\n    \"\"\"\n    if name in self and name != \"size\":\n        raise ValueError(f\"[tolvera.state.StateDict] '{name}' already in dict.\")\n    try:\n        self.add(name, kwargs)\n    except Exception as e:\n        raise type(e)(f\"[tolvera.state.StateDict] {e}\") from e\n</code></pre>"},{"location":"reference/tolvera/utils/","title":"Utils","text":"<p>Utility functions for Tolvera.</p>"},{"location":"reference/tolvera/utils/#tolvera.utils.CONSTS","title":"<code>CONSTS</code>","text":"<p>Dict of CONSTS that can be used in Taichi scope</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>class CONSTS:\n    \"\"\"\n    Dict of CONSTS that can be used in Taichi scope\n    \"\"\"\n\n    def __init__(self, dict: dict[str, (DataType, Any)]):\n        self.struct = ti.types.struct(**{k: v[0] for k, v in dict.items()})\n        self.consts = self.struct(**{k: v[1] for k, v in dict.items()})\n\n    def __getattr__(self, name):\n        try:\n            return self.consts[name]\n        except:\n            raise AttributeError(f\"CONSTS has no attribute {name}\")\n\n    def __getitem__(self, name):\n        try:\n            return self.consts[name]\n        except:\n            raise AttributeError(f\"CONSTS has no attribute {name}\")\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.dotdict","title":"<code>dotdict</code>","text":"<p>             Bases: <code>dict</code></p> <p>dot.notation access to dictionary attributes</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>class dotdict(dict):\n    \"\"\"dot.notation access to dictionary attributes\"\"\"\n    __getattr__ = dict.get\n    __setattr__ = dict.__setitem__\n    __delattr__ = dict.__delitem__\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.create_and_validate_slice","title":"<code>create_and_validate_slice(arg, target_array)</code>","text":"<p>Creates and validates a slice object based on the target array.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def create_and_validate_slice(\n    arg: Union[int, tuple[int, ...], slice], target_array: np.ndarray\n) -&gt; slice:\n    \"\"\"\n    Creates and validates a slice object based on the target array.\n    \"\"\"\n    try:\n        slice_obj = create_safe_slice(arg)\n        if not validate_slice(slice_obj, target_array):\n            raise ValueError(f\"Invalid slice: {slice_obj}\")\n        return slice_obj\n    except Exception as e:\n        raise type(e)(f\"Error creating slice: {e}\")\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.create_ndslices","title":"<code>create_ndslices(dims)</code>","text":"<p>Create a multi-dimensional slice from a list of tuples.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>list[tuple]</code> <p>A list of tuples containing the slice parameters for each dimension.</p> required <p>Returns:</p> Type Description <code>s_</code> <p>np.s_: A multi-dimensional slice object.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def create_ndslices(dims: list[tuple]) -&gt; np.s_:\n    \"\"\"\n    Create a multi-dimensional slice from a list of tuples.\n\n    Args:\n        dims (list[tuple]): A list of tuples containing the slice parameters for each dimension.\n\n    Returns:\n        np.s_: A multi-dimensional slice object.\n    \"\"\"\n    return np.s_[tuple(slice(*dim) if isinstance(dim, tuple) else dim for dim in dims)]\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.create_safe_slice","title":"<code>create_safe_slice(arg)</code>","text":"<p>Creates a slice object based on the input argument.</p> <p>Parameters:</p> Name Type Description Default <code>arg</code> <code>(int, tuple, slice)</code> <p>The argument for creating the slice. It can be an integer,                      a tuple with slice parameters, or a slice object itself.</p> required <p>Returns:</p> Name Type Description <code>slice</code> <code>slice</code> <p>A slice object created based on the provided argument.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def create_safe_slice(arg: Union[int, tuple[int, ...], slice]) -&gt; slice:\n    \"\"\"\n    Creates a slice object based on the input argument.\n\n    Args:\n        arg (int, tuple, slice): The argument for creating the slice. It can be an integer,\n                                 a tuple with slice parameters, or a slice object itself.\n\n    Returns:\n        slice: A slice object created based on the provided argument.\n    \"\"\"\n    try:\n        if isinstance(arg, slice):\n            return arg\n        elif isinstance(arg, tuple):\n            return slice(*arg)\n        elif isinstance(arg, int):\n            return slice(arg, arg + 1)\n        else:\n            raise TypeError(f\"Invalid slice type: {type(arg)} {arg}\")\n    except Exception as e:\n        raise type(e)(f\"[create_safe_slice] Error creating slice: {e}\")\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.flatten","title":"<code>flatten(lst)</code>","text":"<p>Flatten a nested list or return a non-nested list as is.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def flatten(lst):\n    \"\"\"Flatten a nested list or return a non-nested list as is.\"\"\"\n    if all(isinstance(el, list) for el in lst):\n        return [item for sublist in lst for item in sublist]\n    return lst\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.generic_slice","title":"<code>generic_slice(array, slice_params)</code>","text":"<p>Slices a NumPy array based on a tuple of slice parameters for each dimension.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> <p>The array to be sliced.</p> required <code>slice_params</code> <code>tuple</code> <p>A tuple where each item is either an integer, a tuple with                  slice parameters, or a slice object.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>ndarray</code> <p>The sliced array.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def generic_slice(\n    array: np.ndarray,\n    slice_params: Union[\n        tuple[Union[int, tuple[int, ...], slice], ...],\n        Union[int, tuple[int, ...], slice],\n    ],\n) -&gt; np.ndarray:\n    \"\"\"\n    Slices a NumPy array based on a tuple of slice parameters for each dimension.\n\n    Args:\n        array (np.ndarray): The array to be sliced.\n        slice_params (tuple): A tuple where each item is either an integer, a tuple with\n                             slice parameters, or a slice object.\n\n    Returns:\n        ndarray: The sliced array.\n    \"\"\"\n    if not isinstance(slice_params, tuple):\n        slice_params = (slice_params,)\n    slices = tuple(create_safe_slice(param) for param in slice_params)\n    return array.__getitem__(slices)\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.time_function","title":"<code>time_function(func, *args, **kwargs)</code>","text":"<p>Time how long it takes to run a function and print the result</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def time_function(func, *args, **kwargs):\n    \"\"\"Time how long it takes to run a function and print the result\"\"\"\n    start = time.time()\n    ret = func(*args, **kwargs)\n    end = time.time()\n    print(f\"[Tolvera.utils] {func.__name__}() ran in {end-start:.4f}s\")\n    if ret is not None:\n        return (ret, end - start)\n    return end - start\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.validate_json_path","title":"<code>validate_json_path(path)</code>","text":"<p>Validate a JSON file path. It uses validate_path for initial validation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The JSON file path to be validated.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path is a valid JSON file path, raises an exception otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the path does not end with '.json'.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def validate_json_path(path: str) -&gt; bool:\n    \"\"\"\n    Validate a JSON file path. It uses validate_path for initial validation.\n\n    Args:\n        path (str): The JSON file path to be validated.\n\n    Returns:\n        bool: True if the path is a valid JSON file path, raises an exception otherwise.\n\n    Raises:\n        ValueError: If the path does not end with '.json'.\n    \"\"\"\n    # Using validate_path for basic path validation\n    validate_path(path)\n\n    if not path.endswith(\".json\"):\n        raise ValueError(\"Path should end with '.json'\")\n\n    return True\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.validate_path","title":"<code>validate_path(path)</code>","text":"<p>Validate a path using os.path and pathlib.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to be validated.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the path is valid, raises an exception otherwise.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the input is not a string.</p> <code>FileNotFoundError</code> <p>If the path does not exist.</p> <code>PermissionError</code> <p>If the path is not accessible.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def validate_path(path: str) -&gt; bool:\n    \"\"\"\n    Validate a path using os.path and pathlib.\n\n    Args:\n        path (str): The path to be validated.\n\n    Returns:\n        bool: True if the path is valid, raises an exception otherwise.\n\n    Raises:\n        TypeError: If the input is not a string.\n        FileNotFoundError: If the path does not exist.\n        PermissionError: If the path is not accessible.\n    \"\"\"\n    if not isinstance(path, str):\n        raise TypeError(f\"Expected a string for path, but received {type(path)}\")\n\n    path_obj = Path(path)\n    if not path_obj.is_file():\n        raise FileNotFoundError(f\"The path {path} does not exist or is not a file\")\n\n    if not os.access(path, os.R_OK):\n        raise PermissionError(f\"The path {path} is not accessible\")\n\n    return True\n</code></pre>"},{"location":"reference/tolvera/utils/#tolvera.utils.validate_slice","title":"<code>validate_slice(slice_obj, target_array)</code>","text":"<p>Validates if the given slice object is applicable to the target ndarray.</p> <p>Parameters:</p> Name Type Description Default <code>slice_obj</code> <code>tuple[slice]</code> <p>A tuple containing slice objects for each dimension.</p> required <code>target_array</code> <code>ndarray</code> <p>The array to be sliced.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the slice is valid for the given array, False otherwise.</p> Source code in <code>src/tolvera/utils.py</code> <pre><code>def validate_slice(slice_obj: tuple[slice], target_array: np.ndarray) -&gt; bool:\n    \"\"\"\n    Validates if the given slice object is applicable to the target ndarray.\n\n    Args:\n        slice_obj (tuple[slice]): A tuple containing slice objects for each dimension.\n        target_array (np.ndarray): The array to be sliced.\n\n    Returns:\n        bool: True if the slice is valid for the given array, False otherwise.\n    \"\"\"\n    if len(slice_obj) != target_array.ndim:\n        return False\n\n    for sl, size in zip(slice_obj, target_array.shape):\n        # Check if slice start and stop are within the dimension size\n        start, stop, _ = sl.indices(size)\n        if not (0 &lt;= start &lt; size and (0 &lt;= stop &lt;= size or stop == -1)):\n            return False\n    return True\n</code></pre>"},{"location":"reference/tolvera/osc/__init__/","title":"init","text":""},{"location":"reference/tolvera/osc/__init__/#tolvera.osc.OSCMap","title":"<code>OSCMap</code>","text":"<p>OSCMap maps OSC messages to functions It creates a Max/MSP patcher that can be used to control the OSCMap It uses OSCSendUpdater and OSCReceiveUpdater to decouple incoming messages</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>class OSCMap:\n    \"\"\"\n    OSCMap maps OSC messages to functions\n    It creates a Max/MSP patcher that can be used to control the OSCMap\n    It uses OSCSendUpdater and OSCReceiveUpdater to decouple incoming messages\n    \"\"\"\n\n    def __init__(\n        self,\n        osc: iiOSC,\n        client_name=\"client\",\n        patch_type=\"Max\",  # | \"Pd\"\n        patch_filepath=\"osc_controls\",\n        create_patch=True,\n        pd_net_or_udp=\"udp\",\n        pd_bela=False,\n        export=None,  # 'JSON' | 'XML' | True\n    ) -&gt; None:\n        self.osc = osc\n        self.client_name = client_name\n        self.client_address, self.client_port = self.osc.client_names[self.client_name]\n        self.dict = {\"send\": {}, \"receive\": {}}\n        self.create_patch = create_patch\n        self.patch_filepath = patch_filepath\n        self.patch_type = patch_type\n        if create_patch is True:\n            self.init_patcher(patch_type, patch_filepath, pd_net_or_udp, pd_bela)\n        if export is not None:\n            assert (\n                export == \"JSON\" or export == \"XML\" or export == True\n            ), \"export must be 'JSON', 'XML' or True\"\n        self.export = export\n\n    def init_patcher(self, patch_type, patch_filepath, pd_net_or_udp, pd_bela):\n        # create self.patch_dir if it doesn't exist\n        self.patch_dir = \"pd\" if patch_type == \"Pd\" else \"max\"\n        if not os.path.exists(self.patch_dir):\n            print(f\"Creating {self.patch_dir} directory...\")\n            os.makedirs(self.patch_dir)\n        self.patch_appendix = \"_local\" if self.osc.host == \"127.0.0.1\" else \"_remote\"\n        self.patch_filepath = (\n            self.patch_dir + \"/\" + patch_filepath + self.patch_appendix\n        )\n        if patch_type == \"Max\":\n            self.patcher = MaxPatcher(self.osc, self.client_name, self.patch_filepath)\n        elif patch_type == \"Pd\":\n            if pd_bela is True:\n                self.patcher = PdPatcher(\n                    self.osc,\n                    self.client_name,\n                    self.patch_filepath,\n                    net_or_udp=pd_net_or_udp,\n                    bela=True,\n                )\n            else:\n                self.patcher = PdPatcher(\n                    self.osc,\n                    self.client_name,\n                    self.patch_filepath,\n                    net_or_udp=pd_net_or_udp,\n                )\n        else:\n            assert False, \"`patch_type` must be 'Max' or 'Pd'\"\n\n    def add(self, **kwargs):\n        print(\n            \"DeprecationError: OSCMap.add() has been split into separate functions: use `send_args`, `send_list`, `receive_args` or `receive_list` instead!\"\n        )\n        exit()\n\n    def map_func_to_dict(self, func, kwargs):\n        if \"name\" not in kwargs:\n            n = func.__name__\n            address = \"/\" + n.replace(\"_\", \"/\")\n        else:\n            if isinstance(kwargs[\"name\"], str):\n                n = kwargs[\"name\"]\n                address = \"/\" + kwargs[\"name\"].replace(\"_\", \"/\")\n            else:\n                raise TypeError(\n                    f\"OSC func name must be string, found {str(type(kwargs['name']))}\"\n                )\n        # TODO: Move this into specific send/receive functions\n        params = {\n            k: v\n            for k, v in kwargs.items()\n            if k != \"count\" and k != \"send_mode\" and k != \"length\" and k != \"name\"\n        }\n        # TODO: turn params into dict with type hints (see export_dict)\n        hints = get_type_hints(func)\n        f = {\"f\": func, \"name\": n, \"address\": address, \"params\": params, \"hints\": hints}\n        return f\n\n    \"\"\"\n    send args\n    \"\"\"\n\n    def send_args(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_send_args(func, kwargs)\n                return func()\n\n            default_args = [\n                kwargs[a][0]\n                for a in kwargs\n                if a != \"count\" and a != \"send_mode\" and a != \"name\"\n            ]\n            wrapper(*default_args)\n            return wrapper\n\n        return decorator\n\n    def add_send_args(self, func, kwargs):\n        self.add_send_args_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_send_args_to_patcher(func)\n\n    def add_send_args_to_osc_map(self, func, kwargs):\n        f = self.map_func_to_dict(func, kwargs)\n        if kwargs[\"send_mode\"] == \"broadcast\":\n            f[\"updater\"] = OSCSendUpdater(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        else:\n            f[\"sender\"] = OSCSend(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        f[\"type\"] = \"args\"\n        self.dict[\"send\"][f[\"name\"]] = f\n        if self.export is not None:\n            self.export_dict()\n\n    def add_send_args_to_patcher(self, func):\n        f = self.dict[\"send\"][func.__name__]\n        self.patcher.send_args_func(f)\n\n    \"\"\"\n    send list\n    \"\"\"\n\n    def send_list(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_send_list(func, kwargs)\n                return func()\n\n            default_arg = [\n                kwargs[a][0]\n                for a in kwargs\n                if a != \"count\" and a != \"send_mode\" and a != \"length\" and a != \"name\"\n            ]\n            default_arg = default_arg  # *kwargs['length']\n            wrapper(default_arg)\n            return wrapper\n\n        return decorator\n\n    def add_send_list(self, func, kwargs):\n        self.add_send_list_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_send_list_to_patcher(func)\n\n    def add_send_list_to_osc_map(self, func, kwargs):\n        f = self.map_func_to_dict(func, kwargs)\n        hint = f[\"hints\"][\"return\"]\n        assert hint == list[float], \"send_list can only send list[float], found \" + str(\n            hint\n        )\n        if kwargs[\"send_mode\"] == \"broadcast\":\n            f[\"updater\"] = OSCSendUpdater(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        else:\n            f[\"sender\"] = OSCSend(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        f[\"type\"] = \"list\"\n        f[\"length\"] = kwargs[\"length\"]\n        self.dict[\"send\"][f[\"name\"]] = f\n        if self.export is not None:\n            self.export_dict()\n\n    def add_send_list_to_patcher(self, func):\n        f = self.dict[\"send\"][func.__name__]\n        self.patcher.send_list_func(f)\n\n    \"\"\"\n    send kwargs\n    \"\"\"\n\n    def send_kwargs(self, **kwargs):\n        raise NotImplementedError(\"send_kwargs not implemented yet\")\n\n    \"\"\"\n    receive args\n    \"\"\"\n\n    def receive_args(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_receive_args(func, kwargs)\n                return func(*args)\n\n            default_args = [\n                kwargs[a][0] for a in kwargs if a != \"count\" and a != \"name\"\n            ]\n            wrapper(*default_args)\n            return wrapper\n\n        return decorator\n\n    def add_receive_args(self, func, kwargs):\n        f = self.add_receive_args_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_receive_args_to_patcher(f)\n\n    def add_receive_args_to_osc_map(self, func, kwargs):\n        f = self.map_func_to_dict(func, kwargs)\n        f[\"updater\"] = OSCReceiveUpdater(\n            self.osc, f[\"address\"], f=func, count=kwargs[\"count\"]\n        )\n        f[\"type\"] = \"args\"\n        self.dict[\"receive\"][f[\"name\"]] = f\n        return f\n\n    def add_receive_args_to_patcher(self, func):\n        f = self.dict[\"receive\"][func[\"name\"]]\n        self.patcher.receive_args_func(f)\n\n    def receive_args_inline(self, name: str, receiver_func, **kwargs):\n        kwargs = {**kwargs, **{\"count\": 1, \"name\": name}}\n        self.receive_args(**kwargs)(receiver_func)\n\n    \"\"\"\n    receive list\n    \"\"\"\n\n    def receive_list(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_receive_list(func, kwargs)\n                return func(*args)\n\n            # TODO: This probably shouldn't be here...\n            randomised_list = self.randomise_list(\n                kwargs[\"length\"], kwargs[\"vector\"][1], kwargs[\"vector\"][2]\n            )\n            wrapper(randomised_list)\n            return wrapper\n\n        return decorator\n\n    def randomise_list(self, length, min, max):\n        return min + (np.random.rand(length).astype(np.float32) * (max - min))\n\n    def add_receive_list(self, func, kwargs):\n        f = self.add_receive_list_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_receive_list_to_patcher(f)\n\n    def add_receive_list_to_osc_map(self, func, kwargs):\n        \"\"\"\n        TODO: Should this support list[float] only, or list[int] list[str] etc?\n        \"\"\"\n        f = self.map_func_to_dict(func, kwargs)\n        assert (\n            len(f[\"params\"]) == 1\n        ), \"receive_list can only receive one param (list[float])\"\n        hint = f[\"hints\"][list(f[\"params\"].keys())[0]]\n        assert (\n            hint == list[float]\n        ), \"receive_list can only receive list[float], found \" + str(hint)\n        f[\"updater\"] = OSCReceiveListUpdater(\n            self.osc, f[\"address\"], f=func, count=kwargs[\"count\"]\n        )\n        f[\"type\"] = \"list\"\n        f[\"length\"] = kwargs[\"length\"]\n        self.dict[\"receive\"][f[\"name\"]] = f\n        if self.export is not None:\n            self.export_dict()\n        return f\n\n    def add_receive_list_to_patcher(self, func):\n        f = self.dict[\"receive\"][func[\"name\"]]\n        self.patcher.receive_list_func(f)\n\n    def receive_list_with_idx(\n        self, name: str, receiver, idx_len: int, vec_len: int, attr=None\n    ):\n        \"\"\"\n        Create an OSC list handler that assumes that the first `idx_len` values are indices into some struct being modified by a receiver function, and the rest are args as a list, i.e.\n            /name idx0 idx1 ... idxN arg0 arg1 ... argM\n            ...\n            receiver((idx0 idx1 ... idxN), args)\n        Intended as a utility function to be used by external classes where it's not possible to use a decorator like `receive_list`.\n        \"\"\"\n\n        def handler(vector: list[float]):\n            arg_len = len(vector[idx_len:])\n            assert (\n                arg_len == vec_len\n            ), f\"len(args) != len(list) ({arg_len} != {vec_len})\"\n            if idx_len:\n                indices = tuple([int(v) for v in vector[:idx_len]])\n                if attr is None:\n                    receiver(indices, vector[idx_len:])\n                else:\n                    receiver(indices, attr, vector[idx_len:])\n            else:\n                if attr is None:\n                    receiver(vector)\n                else:\n                    receiver(attr, vector)\n\n        kwargs = {\n            \"vector\": (0, 0, 1),\n            \"length\": vec_len + idx_len,\n            \"count\": 1,\n            \"name\": name,\n        }\n        self.receive_list(**kwargs)(handler)\n\n    \"\"\"\n    receive kwargs\n    \"\"\"\n\n    def receive_kwargs(self, **kwargs):\n        \"\"\"\n        Same as receive_args but with named params\n        \"\"\"\n        raise NotImplementedError(\"receive_kwargs not implemented yet\")\n\n    \"\"\"\n    xml / json export\n    \"\"\"\n\n    def export_dict(self):\n        \"\"\"\n        Save the OSCMap dict as XML\n        \"\"\"\n        client_ip, client_port = self.osc.client_names[self.client_name]\n        # TODO: This should be defined in the OSCMap dict / on init\n        metadata = {\n            \"HostIP\": self.osc.host,\n            \"HostPort\": str(self.osc.port),\n            \"ClientName\": self.client_name,\n            \"ClientIP\": client_ip,\n            \"ClientPort\": str(client_port),\n        }\n        root = ET.Element(\"OpenSoundControlSchema\")\n        metadata_element = ET.SubElement(root, \"Metadata\", **metadata)\n        sends = self.dict[\"send\"]\n        receives = self.dict[\"receive\"]\n        for io in [\"Send\", \"Receive\"]:\n            ET.SubElement(root, io)\n        for io in [\"send\", \"receive\"]:\n            for name in self.dict[io]:\n                f = self.dict[io][name]\n                if f[\"type\"] == \"args\":\n                    self.xml_add_args_params(root, name, io, f)\n                elif f[\"type\"] == \"list\":\n                    self.xml_add_list_param(root, name, io, f)\n                elif f[\"type\"] == \"kwargs\":\n                    raise NotImplementedError(\"kwargs not implemented yet\")\n        self.export_update(root)\n\n    def xml_add_args_params(self, root, name, io, f):\n        params = f[\"params\"]\n        hints = f[\"hints\"]\n        kw = {\n            \"Address\": \"/\" + name.replace(\"_\", \"/\"),\n            \"Type\": f[\"type\"],\n            \"Params\": str(len(params)),\n        }\n        route = ET.SubElement(root.find(io.capitalize()), \"Route\", **kw)\n        for i, p in enumerate(params):\n            # TODO: This should already be defined by this point\n            if io == \"receive\":\n                p_type = hints[p].__name__\n            elif io == \"send\":\n                p_type = hints[\"return\"].__args__[i].__name__\n            kw = {\n                \"Name\": p,\n                \"Type\": p_type,\n                \"Default\": str(params[p][0]),\n                \"Min\": str(params[p][1]),\n                \"Max\": str(params[p][2]),\n            }\n            ET.SubElement(route, \"Param\", **kw)\n\n    def xml_add_list_param(self, root, name, io, f):\n        params = f[\"params\"]\n        hints = f[\"hints\"]\n        length = f[\"length\"]\n        kw = {\n            \"Address\": \"/\" + name.replace(\"_\", \"/\"),\n            \"Type\": f[\"type\"],\n            \"Length\": str(length),\n        }\n        route = ET.SubElement(root.find(io.capitalize()), \"Route\", **kw)\n        p = list(params.keys())[0]\n        if io == \"receive\":\n            p_type = hints[p].__name__\n        elif io == \"send\":\n            p_type = hints[\"return\"].__args__[0].__name__\n        kw = {\n            \"Name\": p,\n            \"Type\": p_type,\n            \"Default\": str(params[p][0]),\n            \"Min\": str(params[p][1]),\n            \"Max\": str(params[p][2]),\n        }\n        ET.SubElement(route, \"ParamList\", **kw)\n\n    def export_update(self, root):\n        tree = ET.ElementTree(root)\n        ET.indent(tree, space=\"\\t\", level=0)\n        if self.export == \"XML\":\n            self.save_xml(tree, root)\n        elif self.export == \"JSON\":\n            self.save_json(root)\n        elif self.export == True:\n            self.save_xml(tree, root)\n            self.save_json(root)\n\n    def save_xml(self, tree, root):\n        tree.write(self.patch_filepath + \".xml\")\n        print(f\"Exported OSCMap to {self.patch_filepath}.xml\")\n\n    def save_json(self, xml_root):\n        # TODO: params should be `params: []` and not `param: {}, param: {}, ...`\n        json_dict = self.xml_to_json(\n            ET.tostring(xml_root, encoding=\"utf8\", method=\"xml\")\n        )\n        with open(self.patch_filepath + \".json\", \"w\") as f:\n            f.write(json_dict)\n        print(f\"Exported OSCMap to {self.patch_filepath}.json\")\n\n    def etree_to_dict(self, t):\n        tag = self.pascal_to_camel(t.tag)\n        d = {tag: {} if t.attrib else None}\n        children = list(t)\n        if children:\n            dd = {}\n            for dc in map(self.etree_to_dict, children):\n                for k, v in dc.items():\n                    try:\n                        dd[k].append(v)\n                    except KeyError:\n                        dd[k] = [v]\n            d = {tag: {k: v[0] if len(v) == 1 else v for k, v in dd.items()}}\n        if t.attrib:\n            d[tag].update((self.pascal_to_camel(k), v) for k, v in t.attrib.items())\n        if t.text:\n            text = t.text.strip()\n            if children or t.attrib:\n                if text:\n                    d[tag][\"#text\"] = text\n            else:\n                d[tag] = text\n        return d\n\n    def xml_to_json(self, xml_str):\n        e = ET.ElementTree(ET.fromstring(xml_str))\n        return json.dumps(self.etree_to_dict(e.getroot()), indent=4)\n\n    def update(self):\n        for k, v in self.dict[\"send\"].items():\n            if \"updater\" in v:\n                ret = v[\"updater\"]()\n            # v['updater']()\n        for k, v in self.dict[\"receive\"].items():\n            v[\"updater\"]()\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n        self.update()\n</code></pre>"},{"location":"reference/tolvera/osc/__init__/#tolvera.osc.OSCMap.add_receive_list_to_osc_map","title":"<code>add_receive_list_to_osc_map(func, kwargs)</code>","text":"<p>TODO: Should this support list[float] only, or list[int] list[str] etc?</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def add_receive_list_to_osc_map(self, func, kwargs):\n    \"\"\"\n    TODO: Should this support list[float] only, or list[int] list[str] etc?\n    \"\"\"\n    f = self.map_func_to_dict(func, kwargs)\n    assert (\n        len(f[\"params\"]) == 1\n    ), \"receive_list can only receive one param (list[float])\"\n    hint = f[\"hints\"][list(f[\"params\"].keys())[0]]\n    assert (\n        hint == list[float]\n    ), \"receive_list can only receive list[float], found \" + str(hint)\n    f[\"updater\"] = OSCReceiveListUpdater(\n        self.osc, f[\"address\"], f=func, count=kwargs[\"count\"]\n    )\n    f[\"type\"] = \"list\"\n    f[\"length\"] = kwargs[\"length\"]\n    self.dict[\"receive\"][f[\"name\"]] = f\n    if self.export is not None:\n        self.export_dict()\n    return f\n</code></pre>"},{"location":"reference/tolvera/osc/__init__/#tolvera.osc.OSCMap.export_dict","title":"<code>export_dict()</code>","text":"<p>Save the OSCMap dict as XML</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def export_dict(self):\n    \"\"\"\n    Save the OSCMap dict as XML\n    \"\"\"\n    client_ip, client_port = self.osc.client_names[self.client_name]\n    # TODO: This should be defined in the OSCMap dict / on init\n    metadata = {\n        \"HostIP\": self.osc.host,\n        \"HostPort\": str(self.osc.port),\n        \"ClientName\": self.client_name,\n        \"ClientIP\": client_ip,\n        \"ClientPort\": str(client_port),\n    }\n    root = ET.Element(\"OpenSoundControlSchema\")\n    metadata_element = ET.SubElement(root, \"Metadata\", **metadata)\n    sends = self.dict[\"send\"]\n    receives = self.dict[\"receive\"]\n    for io in [\"Send\", \"Receive\"]:\n        ET.SubElement(root, io)\n    for io in [\"send\", \"receive\"]:\n        for name in self.dict[io]:\n            f = self.dict[io][name]\n            if f[\"type\"] == \"args\":\n                self.xml_add_args_params(root, name, io, f)\n            elif f[\"type\"] == \"list\":\n                self.xml_add_list_param(root, name, io, f)\n            elif f[\"type\"] == \"kwargs\":\n                raise NotImplementedError(\"kwargs not implemented yet\")\n    self.export_update(root)\n</code></pre>"},{"location":"reference/tolvera/osc/__init__/#tolvera.osc.OSCMap.receive_kwargs","title":"<code>receive_kwargs(**kwargs)</code>","text":"<p>Same as receive_args but with named params</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def receive_kwargs(self, **kwargs):\n    \"\"\"\n    Same as receive_args but with named params\n    \"\"\"\n    raise NotImplementedError(\"receive_kwargs not implemented yet\")\n</code></pre>"},{"location":"reference/tolvera/osc/__init__/#tolvera.osc.OSCMap.receive_list_with_idx","title":"<code>receive_list_with_idx(name, receiver, idx_len, vec_len, attr=None)</code>","text":"<p>Create an OSC list handler that assumes that the first <code>idx_len</code> values are indices into some struct being modified by a receiver function, and the rest are args as a list, i.e.     /name idx0 idx1 ... idxN arg0 arg1 ... argM     ...     receiver((idx0 idx1 ... idxN), args) Intended as a utility function to be used by external classes where it's not possible to use a decorator like <code>receive_list</code>.</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def receive_list_with_idx(\n    self, name: str, receiver, idx_len: int, vec_len: int, attr=None\n):\n    \"\"\"\n    Create an OSC list handler that assumes that the first `idx_len` values are indices into some struct being modified by a receiver function, and the rest are args as a list, i.e.\n        /name idx0 idx1 ... idxN arg0 arg1 ... argM\n        ...\n        receiver((idx0 idx1 ... idxN), args)\n    Intended as a utility function to be used by external classes where it's not possible to use a decorator like `receive_list`.\n    \"\"\"\n\n    def handler(vector: list[float]):\n        arg_len = len(vector[idx_len:])\n        assert (\n            arg_len == vec_len\n        ), f\"len(args) != len(list) ({arg_len} != {vec_len})\"\n        if idx_len:\n            indices = tuple([int(v) for v in vector[:idx_len]])\n            if attr is None:\n                receiver(indices, vector[idx_len:])\n            else:\n                receiver(indices, attr, vector[idx_len:])\n        else:\n            if attr is None:\n                receiver(vector)\n            else:\n                receiver(attr, vector)\n\n    kwargs = {\n        \"vector\": (0, 0, 1),\n        \"length\": vec_len + idx_len,\n        \"count\": 1,\n        \"name\": name,\n    }\n    self.receive_list(**kwargs)(handler)\n</code></pre>"},{"location":"reference/tolvera/osc/maxmsp/","title":"Maxmsp","text":""},{"location":"reference/tolvera/osc/maxmsp/#tolvera.osc.maxmsp.MaxPatcher","title":"<code>MaxPatcher</code>","text":"<p>TODO: copy-paste using stdout TODO: add scale objects before send and after receive TODO: add default values via loadbangs TODO: move udpsend/udpreceive to the top left TODO: dict of object ids TODO: add abstraction i/o messages e.g. param names, state save/load/dumps</p> Source code in <code>src/tolvera/osc/maxmsp.py</code> <pre><code>class MaxPatcher:\n    \"\"\"\n    TODO: copy-paste using stdout\n    TODO: add scale objects before send and after receive\n    TODO: add default values via loadbangs\n    TODO: move udpsend/udpreceive to the top left\n    TODO: dict of object ids\n    TODO: add abstraction i/o messages e.g. param names, state save/load/dumps\n    \"\"\"\n\n    def __init__(\n        self,\n        osc,\n        client_name=\"client\",\n        filepath=\"osc_controls\",\n        x=0.0,\n        y=0.0,\n        w=1600.0,\n        h=900.0,\n        v=\"8.5.4\",\n    ) -&gt; None:\n        self.patch = {\n            \"patcher\": {\n                \"fileversion\": 1,\n                \"appversion\": {\n                    \"major\": v[0],\n                    \"minor\": v[2],\n                    \"revision\": v[4],\n                    \"architecture\": \"x64\",\n                    \"modernui\": 1,\n                },\n                \"classnamespace\": \"box\",\n                \"rect\": [x, y, w, h],\n                \"bglocked\": 0,\n                \"openinpresentation\": 0,\n                \"default_fontsize\": 12.0,\n                \"default_fontface\": 0,\n                \"default_fontname\": \"Arial\",\n                \"gridonopen\": 1,\n                \"gridsize\": [15.0, 15.0],\n                \"gridsnaponopen\": 1,\n                \"objectsnaponopen\": 1,\n                \"statusbarvisible\": 2,\n                \"toolbarvisible\": 1,\n                \"lefttoolbarpinned\": 0,\n                \"toptoolbarpinned\": 0,\n                \"righttoolbarpinned\": 0,\n                \"bottomtoolbarpinned\": 0,\n                \"toolbars_unpinned_last_save\": 0,\n                \"tallnewobj\": 0,\n                \"boxanimatetime\": 200,\n                \"enablehscroll\": 1,\n                \"enablevscroll\": 1,\n                \"devicewidth\": 0.0,\n                \"description\": \"\",\n                \"digest\": \"\",\n                \"tags\": \"\",\n                \"style\": \"\",\n                \"subpatcher_template\": \"\",\n                \"assistshowspatchername\": 0,\n                \"boxes\": [],\n                \"lines\": [],\n                \"dependency_cache\": [],\n                \"autosave\": 0,\n            }\n        }\n        self.types = {\n            \"print\": \"print\",\n            \"message\": \"message\",\n            \"object\": \"newobj\",\n            \"comment\": \"comment\",\n            \"slider\": \"slider\",\n            \"float\": \"flonum\",\n            \"int\": \"number\",\n            \"bang\": \"button\",\n        }\n        self.osc = osc\n        self.client_name = client_name\n        self.client_address, self.client_port = self.osc.client_names[self.client_name]\n        self.filepath = filepath\n        self.init()\n\n    def init(self):\n        self.w = 5.5  # default width (scaling factor)\n        self.h = 22.0  # default height (pixels)\n        self.s_x, self.s_y = 30, 125  # insertion point\n        self.r_x, self.r_y = 30, 575  # insertion point\n        self.patcher_ids = {}\n        self.patcher_ids[\"send_id\"] = self.add_osc_send(\n            self.osc.host, self.osc.port, self.s_x, 30, print_label=\"sent\"\n        )\n        self.patcher_ids[\"receive_id\"] = self.add_osc_receive(\n            self.client_port, self.s_x + 150, 30, print_label=\"received\"\n        )\n        self.add_comment(\"Max \u2192 Python\", self.s_x, self.s_y, 24)\n        self.add_comment(\"Python \u2192 Max\", self.r_x, self.r_y, 24)\n        self.s_y += 50\n        self.r_y += 50\n        self.save(self.filepath)\n\n    def add_box(self, box_type, inlets, outlets, x, y, w, h=None):\n        if h is None:\n            h = self.h\n        box_id, box = self.create_box(box_type, inlets, outlets, x, y, w, h)\n        return self._add_box(box)\n\n    def _add_box(self, box):\n        self.patch[\"patcher\"][\"boxes\"].append(box)\n        return self.id_from_str(box[\"box\"][\"id\"])\n\n    def create_box(self, box_type, inlets, outlets, x, y, w, h=None):\n        if h is None:\n            h = self.h\n        box_id = len(self.patch[\"patcher\"][\"boxes\"]) + 1\n        box = {\n            \"box\": {\n                \"id\": \"obj-\" + str(box_id),\n                \"maxclass\": self.types[box_type],\n                \"numinlets\": inlets,\n                \"numoutlets\": outlets,\n                \"patching_rect\": [x, y, w, h],\n            }\n        }\n        if outlets &gt; 0:\n            if outlets == 1:\n                box[\"box\"][\"outlettype\"] = [\"\"]\n            match box_type:\n                case \"int\" | \"float\" | \"bang\":\n                    box[\"box\"][\"outlettype\"] = [\"\", \"bang\"]\n        return box_id, box\n\n    def add_object(self, text, inlets, outlets, x, y):\n        box_id, box = self.create_box(\n            \"object\", inlets, outlets, x, y, len(text) * self.w\n        )\n        box[\"box\"][\"text\"] = text\n        self._add_box(box)\n        return box_id\n\n    def add_message(self, text, x, y):\n        box_id, box = self.create_box(\"message\", 2, 1, x, y, len(text) * self.w)\n        box[\"box\"][\"text\"] = text\n        self._add_box(box)\n        return box_id\n\n    def add_comment(self, text, x, y, fontsize=12):\n        box_id, box = self.create_box(\"comment\", 0, 0, x, y, len(text) * self.w)\n        box[\"box\"][\"text\"] = text\n        box[\"box\"][\"fontsize\"] = fontsize\n        self._add_box(box)\n        return box_id\n\n    def add_bang(self, x, y):\n        box_id, box = self.create_box(\"bang\", 1, 1, x, y, 20.0)\n        self._add_box(box)\n        return box_id\n\n    def add_slider(self, x, y, min_val, size, float=False):\n        box_id, box = self.create_box(\"slider\", 1, 1, x, y, 20.0, 140.0)\n        if float:\n            box[\"box\"][\"floatoutput\"] = 1\n        box[\"box\"][\"min\"] = min_val\n        box[\"box\"][\"size\"] = size\n        self._add_box(box)\n        return box_id\n\n    def connect(self, src, src_outlet, dst, dst_inlet):\n        patchline = {\n            \"patchline\": {\n                \"destination\": [\"obj-\" + str(dst), dst_inlet],\n                \"source\": [\"obj-\" + str(src), src_outlet],\n            }\n        }\n        self.patch[\"patcher\"][\"lines\"].append(patchline)\n        return patchline\n\n    def save(self, name):\n        with open(name + \".maxpat\", \"w\") as f:\n            f.write(json.dumps(self.patch, indent=2))\n\n    def load(self, name):\n        with open(name + \".maxpat\", \"r\") as f:\n            self.patch = json.loads(f.read())\n\n    def get_box_by_id(self, id):\n        for box in self.patch[\"patcher\"][\"boxes\"]:\n            if self.id_from_str(box[\"box\"][\"id\"]) == id:\n                return box\n        return None\n\n    def str_from_id(self, id):\n        return \"obj-\" + str(id)\n\n    def id_from_str(self, obj_str):\n        return int(obj_str[4:])\n\n    def add_osc_send(self, ip, port, x, y, print=True, print_label=None):\n        box_id_0 = self.add_object(\"r send\", 0, 1, x, y)\n        box_id = self.add_object(\"udpsend \" + ip + \" \" + str(port), 1, 0, x, y + 25)\n        if print:\n            text = \"print\" if print_label is None else \"print \" + print_label\n            print_id = self.add_object(text, 1, 0, x + 50, y)\n            self.connect(box_id_0, 0, box_id, 0)\n            self.connect(box_id_0, 0, print_id, 0)\n            return box_id_0\n        return box_id\n\n    def add_osc_receive(self, port, x, y, print=True, print_label=None):\n        box_id_0 = self.add_object(\"s receive\", 0, 1, x, y + 25)\n        box_id = self.add_object(\"udpreceive \" + str(port), 1, 1, x, y)\n        if print:\n            text = \"print\" if print_label is None else \"print \" + print_label\n            print_id = self.add_object(text, 1, 0, x + 60, y + 25)\n            self.connect(box_id, 0, print_id, 0)\n            self.connect(box_id, 0, box_id_0, 0)\n            return box_id_0\n        return box_id\n\n    def add_osc_route(self, port, x, y, print=True, print_label=None):\n        \"\"\"\n        [route path]\n        [s name] [print]\n        [unpack] ?\n        [r name]\n        \"\"\"\n        pass\n\n    def add_sliders(self, x, y, sliders):\n        \"\"\"\n        sliders = [\n          { 'label': 'x', data: 'float', min_val: 0.0, size: 0.0 },\n        ]\n\n        [slider] ...\n        |\n        [number] ...\n        \"\"\"\n        slider_ids = []\n        float_ids = []\n        y_off = 0\n        for i, s in enumerate(sliders):\n            y_off = 0\n            x_i = x + (i * 52.0)\n            y_off += self.h\n            slider_id = self.add_slider(\n                x_i, y + y_off, s[\"min_val\"], s[\"size\"], float=s[\"data\"] == \"float\"\n            )\n            y_off += 150\n            float_id = self.add_box(\"float\", 1, 2, x_i, y + y_off, 50)\n            slider_ids.append(slider_id)\n            float_ids.append(float_id)\n        return slider_ids, float_ids, y_off\n\n    def add_param_comments(self, x, y, params):\n        comment_ids = []\n        y_off = 0\n        for i, p in enumerate(params):\n            y_off = 0\n            x_i = x + (i * 52.0)\n            p_max = (\n                p[\"min_val\"] + p[\"size\"]\n                if p[\"data\"] == \"float\"\n                else p[\"min_val\"] + p[\"size\"] - 1\n            )\n            comment_id1 = self.add_comment(f'{p[\"label\"]}', x_i, y)\n            y_off += 15\n            comment_id2 = self.add_comment(\n                f'{p[\"data\"][0]} {p[\"min_val\"]}-{p_max}', x_i, y + y_off\n            )\n            comment_ids.append(comment_id1)\n            comment_ids.append(comment_id2)\n        return comment_ids, y_off\n\n    def add_osc_send_msg(self, x, y, path):\n        msg_id = self.add_message(path, x, y + 225 + self.h)\n        send_id = self.add_object(\"s send\", 1, 0, x, y + 250 + self.h)\n        self.connect(msg_id, 0, send_id, 0)\n        return msg_id\n\n    def add_osc_receive_msg(self, x, y, path):\n        receive_id = self.add_object(\"r receive\", 0, 1, x, y + 225 + self.h)\n        msg_id = self.add_message(path, x, y + 250 + self.h)\n        self.connect(receive_id, 0, msg_id, 0)\n        return msg_id\n\n    def add_osc_send_with_controls(self, x, y, path, parameters):\n        # TODO: add default param value and a loadbang\n        \"\"\"\n        [comment path]\n        [comment args]\n        [r path_arg_name]\n        sliders\n        |                   |\n        [pak $1 $2 $3 ...]\n        |\n        [msg /path $1 $2 $3 ...]\n        |\n        [s send]\n        \"\"\"\n        y_off = 0\n        # [comment path]\n        path_comment_id = self.add_comment(path, x, y + y_off)\n        y_off += 15\n        param_comment_ids, _y_off = self.add_param_comments(x, y + y_off, parameters)\n\n        # [r path_arg_name]\n        y_off += 35\n        receive_ids = [\n            self.add_object(\n                \"r \" + path.replace(\"/\", \"_\")[1:] + \"_\" + p[\"label\"][0:3],\n                1,\n                0,\n                x + i * 52.0,\n                y + y_off + (0 if i % 2 == 0 else 25),\n            )\n            for i, p in enumerate(parameters)\n        ]\n        y_off += 30\n\n        # sliders\n        slider_ids, slider_float_ids, _y_off = self.add_sliders(\n            x, y + y_off, parameters\n        )\n        y_off += _y_off + 25\n        # [pak $1 $2 $3 ...]\n        pack_id = self.add_object(\n            \"pak \" + self._pack_args(parameters), len(parameters) + 1, 1, x, y + y_off\n        )\n        pack_width = self.get_box_by_id(pack_id)[\"box\"][\"patching_rect\"][2]\n        # [msg /path $1 $2 $3 ...]\n        y_off += 25\n        msg_id = self.add_message(path + \" \" + self._msg_args(parameters), x, y + y_off)\n        # [s send]\n        y_off += 25\n        send_id = self.add_object(\"s send\", 1, 0, x, y + y_off)\n        # connections\n        [\n            self.connect(receive_ids[i], 0, slider_ids[i], 0)\n            for i in range(len(parameters))\n        ]\n        [\n            self.connect(slider_ids[i], 0, slider_float_ids[i], 0)\n            for i in range(len(parameters))\n        ]\n        [\n            self.connect(slider_float_ids[i], 0, pack_id, i)\n            for i in range(len(parameters))\n        ]\n        self.connect(pack_id, 0, msg_id, 0)\n        self.connect(msg_id, 0, send_id, 0)\n        return slider_ids, pack_id, msg_id\n\n    def add_osc_receive_with_controls(self, x, y, path, parameters):\n        # TODO: add default param value and a loadbang\n        \"\"\"\n        [comment path]\n        [r receive]\n        |\n        [route /path]\n        |                  |\n        [unpack f f f ...] [print /path]\n        |\n        [slider] ...\n        |\n        [number] ...\n        |\n        [s arg_name]\n        [comment path_arg_name]\n        [comment type min-max]\n        \"\"\"\n        # [comment path]\n        y_off = 0\n        path_comment_id = self.add_comment(path, x, y + y_off)\n\n        # [r receive]\n        y_off += 25\n        receive_id = self.add_object(\"r receive\", 0, 1, x, y + y_off)\n\n        # [route /path]\n        y_off += 25\n        route_id = self.add_object(\"route \" + path, 1, 1, x, y + y_off)\n\n        # [unpack f f f ...] [print /path]\n        y_off += 25\n        unpack_id = self.add_object(\n            \"unpack \" + self._pack_args(parameters),\n            len(parameters) + 1,\n            1,\n            x,\n            y + y_off,\n        )\n        unpack_width = self.get_box_by_id(unpack_id)[\"box\"][\"patching_rect\"][2]\n        print_id = self.add_object(\n            \"print \" + path, 1, 0, x + unpack_width + 10, y + y_off\n        )\n\n        # sliders\n        y_off += 10\n        slider_ids, float_ids, _y_off = self.add_sliders(x, y + y_off, parameters)\n\n        # [s arg_name]\n        y_off += _y_off + 25\n        send_ids = [\n            self.add_object(\n                \"s \" + path.replace(\"/\", \"_\")[1:] + \"_\" + p[\"label\"][0:3],\n                1,\n                0,\n                x + i * 52.0,\n                y + y_off + (0 if i % 2 == 0 else 25),\n            )\n            for i, p in enumerate(parameters)\n        ]\n\n        # [comment params]\n        y_off += 50\n        param_comment_ids, _y_off = self.add_param_comments(x, y + y_off, parameters)\n\n        # connections\n        self.connect(receive_id, 0, route_id, 0)\n        self.connect(route_id, 0, unpack_id, 0)\n        self.connect(route_id, 0, print_id, 0)\n        [self.connect(unpack_id, i, slider_ids[i], 0) for i in range(len(parameters))]\n        [\n            self.connect(slider_ids[i], 0, float_ids[i], 0)\n            for i in range(len(parameters))\n        ]\n        [self.connect(float_ids[i], 0, send_ids[i], 0) for i in range(len(parameters))]\n\n        return slider_ids, unpack_id\n\n    def add_send_args_func(self, f):\n        hints = typing.get_type_hints(f[\"f\"])[\"return\"].__args__\n        f_p = f[\"params\"]\n        params = []\n        if len(f_p) == 0:\n            self.add_osc_receive_msg(self.r_x, self.r_y, f[\"address\"])\n        else:\n            for i, p in enumerate(f_p):\n                p_def, p_min, p_max = f_p[p][0], f_p[p][1], f_p[p][2]\n                params.append(\n                    {\n                        \"label\": p,\n                        \"data\": hints[i].__name__,\n                        \"min_val\": p_min,\n                        \"size\": p_max - p_min,\n                    }\n                )\n            self.add_osc_receive_with_controls(self.r_x, self.r_y, f[\"address\"], params)\n        self.r_x += max(len(params) * 52.0 + 100.0, len(f[\"address\"]) * 6.0 + 25.0)\n        self.save(self.filepath)\n\n    def add_send_list_func(self, f):\n        raise NotImplementedError(\"add_send_list_func not implemented yet\")\n\n    def add_receive_args_func(self, f):\n        hints = typing.get_type_hints(f[\"f\"])\n        f_p = f[\"params\"]\n        params = []\n        if len(f_p) == 0:\n            self.add_osc_send_msg(self.s_x, self.s_y, f[\"address\"])\n        else:\n            for p in f_p:\n                p_def, p_min, p_max = f_p[p][0], f_p[p][1], f_p[p][2]\n                params.append(\n                    {\n                        \"label\": p,\n                        \"data\": hints[p].__name__,\n                        \"min_val\": p_min,\n                        \"size\": p_max - p_min,\n                    }\n                )\n            self.add_osc_send_with_controls(self.s_x, self.s_y, f[\"address\"], params)\n        self.s_x += max(len(params) * 52.0 + 100.0, len(f[\"address\"]) * 6.0 + 25.0)\n        self.save(self.filepath)\n\n    def add_receive_list_func(self, f):\n        raise NotImplementedError(\"add_receive_list_func not implemented yet\")\n\n    def _msg_args(self, args):\n        return \" \".join([\"$\" + str(i + 1) for i in range(len(args))])\n\n    def _pack_args(self, args):\n        arg_types = []\n        for a in args:\n            match a[\"data\"]:\n                case \"int\":\n                    arg_types.append(\"i\")\n                case \"float\":\n                    arg_types.append(\"f\")\n                case \"string\":\n                    arg_types.append(\"s\")\n        return \" \".join(arg_types)\n</code></pre>"},{"location":"reference/tolvera/osc/maxmsp/#tolvera.osc.maxmsp.MaxPatcher.add_osc_receive_with_controls","title":"<code>add_osc_receive_with_controls(x, y, path, parameters)</code>","text":"<p>[comment path] [r receive] | [route /path] |                  | [unpack f f f ...] [print /path] | [slider] ... | [number] ... | [s arg_name] [comment path_arg_name] [comment type min-max]</p> Source code in <code>src/tolvera/osc/maxmsp.py</code> <pre><code>def add_osc_receive_with_controls(self, x, y, path, parameters):\n    # TODO: add default param value and a loadbang\n    \"\"\"\n    [comment path]\n    [r receive]\n    |\n    [route /path]\n    |                  |\n    [unpack f f f ...] [print /path]\n    |\n    [slider] ...\n    |\n    [number] ...\n    |\n    [s arg_name]\n    [comment path_arg_name]\n    [comment type min-max]\n    \"\"\"\n    # [comment path]\n    y_off = 0\n    path_comment_id = self.add_comment(path, x, y + y_off)\n\n    # [r receive]\n    y_off += 25\n    receive_id = self.add_object(\"r receive\", 0, 1, x, y + y_off)\n\n    # [route /path]\n    y_off += 25\n    route_id = self.add_object(\"route \" + path, 1, 1, x, y + y_off)\n\n    # [unpack f f f ...] [print /path]\n    y_off += 25\n    unpack_id = self.add_object(\n        \"unpack \" + self._pack_args(parameters),\n        len(parameters) + 1,\n        1,\n        x,\n        y + y_off,\n    )\n    unpack_width = self.get_box_by_id(unpack_id)[\"box\"][\"patching_rect\"][2]\n    print_id = self.add_object(\n        \"print \" + path, 1, 0, x + unpack_width + 10, y + y_off\n    )\n\n    # sliders\n    y_off += 10\n    slider_ids, float_ids, _y_off = self.add_sliders(x, y + y_off, parameters)\n\n    # [s arg_name]\n    y_off += _y_off + 25\n    send_ids = [\n        self.add_object(\n            \"s \" + path.replace(\"/\", \"_\")[1:] + \"_\" + p[\"label\"][0:3],\n            1,\n            0,\n            x + i * 52.0,\n            y + y_off + (0 if i % 2 == 0 else 25),\n        )\n        for i, p in enumerate(parameters)\n    ]\n\n    # [comment params]\n    y_off += 50\n    param_comment_ids, _y_off = self.add_param_comments(x, y + y_off, parameters)\n\n    # connections\n    self.connect(receive_id, 0, route_id, 0)\n    self.connect(route_id, 0, unpack_id, 0)\n    self.connect(route_id, 0, print_id, 0)\n    [self.connect(unpack_id, i, slider_ids[i], 0) for i in range(len(parameters))]\n    [\n        self.connect(slider_ids[i], 0, float_ids[i], 0)\n        for i in range(len(parameters))\n    ]\n    [self.connect(float_ids[i], 0, send_ids[i], 0) for i in range(len(parameters))]\n\n    return slider_ids, unpack_id\n</code></pre>"},{"location":"reference/tolvera/osc/maxmsp/#tolvera.osc.maxmsp.MaxPatcher.add_osc_route","title":"<code>add_osc_route(port, x, y, print=True, print_label=None)</code>","text":"<p>[route path] [s name] print ? [r name]</p> Source code in <code>src/tolvera/osc/maxmsp.py</code> <pre><code>def add_osc_route(self, port, x, y, print=True, print_label=None):\n    \"\"\"\n    [route path]\n    [s name] [print]\n    [unpack] ?\n    [r name]\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/tolvera/osc/maxmsp/#tolvera.osc.maxmsp.MaxPatcher.add_osc_send_with_controls","title":"<code>add_osc_send_with_controls(x, y, path, parameters)</code>","text":"<p>[comment path] [comment args] [r path_arg_name] sliders |                   | [pak $1 $2 $3 ...] | [msg /path $1 $2 $3 ...] | [s send]</p> Source code in <code>src/tolvera/osc/maxmsp.py</code> <pre><code>def add_osc_send_with_controls(self, x, y, path, parameters):\n    # TODO: add default param value and a loadbang\n    \"\"\"\n    [comment path]\n    [comment args]\n    [r path_arg_name]\n    sliders\n    |                   |\n    [pak $1 $2 $3 ...]\n    |\n    [msg /path $1 $2 $3 ...]\n    |\n    [s send]\n    \"\"\"\n    y_off = 0\n    # [comment path]\n    path_comment_id = self.add_comment(path, x, y + y_off)\n    y_off += 15\n    param_comment_ids, _y_off = self.add_param_comments(x, y + y_off, parameters)\n\n    # [r path_arg_name]\n    y_off += 35\n    receive_ids = [\n        self.add_object(\n            \"r \" + path.replace(\"/\", \"_\")[1:] + \"_\" + p[\"label\"][0:3],\n            1,\n            0,\n            x + i * 52.0,\n            y + y_off + (0 if i % 2 == 0 else 25),\n        )\n        for i, p in enumerate(parameters)\n    ]\n    y_off += 30\n\n    # sliders\n    slider_ids, slider_float_ids, _y_off = self.add_sliders(\n        x, y + y_off, parameters\n    )\n    y_off += _y_off + 25\n    # [pak $1 $2 $3 ...]\n    pack_id = self.add_object(\n        \"pak \" + self._pack_args(parameters), len(parameters) + 1, 1, x, y + y_off\n    )\n    pack_width = self.get_box_by_id(pack_id)[\"box\"][\"patching_rect\"][2]\n    # [msg /path $1 $2 $3 ...]\n    y_off += 25\n    msg_id = self.add_message(path + \" \" + self._msg_args(parameters), x, y + y_off)\n    # [s send]\n    y_off += 25\n    send_id = self.add_object(\"s send\", 1, 0, x, y + y_off)\n    # connections\n    [\n        self.connect(receive_ids[i], 0, slider_ids[i], 0)\n        for i in range(len(parameters))\n    ]\n    [\n        self.connect(slider_ids[i], 0, slider_float_ids[i], 0)\n        for i in range(len(parameters))\n    ]\n    [\n        self.connect(slider_float_ids[i], 0, pack_id, i)\n        for i in range(len(parameters))\n    ]\n    self.connect(pack_id, 0, msg_id, 0)\n    self.connect(msg_id, 0, send_id, 0)\n    return slider_ids, pack_id, msg_id\n</code></pre>"},{"location":"reference/tolvera/osc/maxmsp/#tolvera.osc.maxmsp.MaxPatcher.add_sliders","title":"<code>add_sliders(x, y, sliders)</code>","text":"<p>sliders = [   { 'label': 'x', data: 'float', min_val: 0.0, size: 0.0 }, ]</p> <p>[slider] ... | [number] ...</p> Source code in <code>src/tolvera/osc/maxmsp.py</code> <pre><code>def add_sliders(self, x, y, sliders):\n    \"\"\"\n    sliders = [\n      { 'label': 'x', data: 'float', min_val: 0.0, size: 0.0 },\n    ]\n\n    [slider] ...\n    |\n    [number] ...\n    \"\"\"\n    slider_ids = []\n    float_ids = []\n    y_off = 0\n    for i, s in enumerate(sliders):\n        y_off = 0\n        x_i = x + (i * 52.0)\n        y_off += self.h\n        slider_id = self.add_slider(\n            x_i, y + y_off, s[\"min_val\"], s[\"size\"], float=s[\"data\"] == \"float\"\n        )\n        y_off += 150\n        float_id = self.add_box(\"float\", 1, 2, x_i, y + y_off, 50)\n        slider_ids.append(slider_id)\n        float_ids.append(float_id)\n    return slider_ids, float_ids, y_off\n</code></pre>"},{"location":"reference/tolvera/osc/osc/","title":"Osc","text":""},{"location":"reference/tolvera/osc/oscmap/","title":"Oscmap","text":""},{"location":"reference/tolvera/osc/oscmap/#tolvera.osc.oscmap.OSCMap","title":"<code>OSCMap</code>","text":"<p>OSCMap maps OSC messages to functions It creates a Max/MSP patcher that can be used to control the OSCMap It uses OSCSendUpdater and OSCReceiveUpdater to decouple incoming messages</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>class OSCMap:\n    \"\"\"\n    OSCMap maps OSC messages to functions\n    It creates a Max/MSP patcher that can be used to control the OSCMap\n    It uses OSCSendUpdater and OSCReceiveUpdater to decouple incoming messages\n    \"\"\"\n\n    def __init__(\n        self,\n        osc: iiOSC,\n        client_name=\"client\",\n        patch_type=\"Max\",  # | \"Pd\"\n        patch_filepath=\"osc_controls\",\n        create_patch=True,\n        pd_net_or_udp=\"udp\",\n        pd_bela=False,\n        export=None,  # 'JSON' | 'XML' | True\n    ) -&gt; None:\n        self.osc = osc\n        self.client_name = client_name\n        self.client_address, self.client_port = self.osc.client_names[self.client_name]\n        self.dict = {\"send\": {}, \"receive\": {}}\n        self.create_patch = create_patch\n        self.patch_filepath = patch_filepath\n        self.patch_type = patch_type\n        if create_patch is True:\n            self.init_patcher(patch_type, patch_filepath, pd_net_or_udp, pd_bela)\n        if export is not None:\n            assert (\n                export == \"JSON\" or export == \"XML\" or export == True\n            ), \"export must be 'JSON', 'XML' or True\"\n        self.export = export\n\n    def init_patcher(self, patch_type, patch_filepath, pd_net_or_udp, pd_bela):\n        # create self.patch_dir if it doesn't exist\n        self.patch_dir = \"pd\" if patch_type == \"Pd\" else \"max\"\n        if not os.path.exists(self.patch_dir):\n            print(f\"Creating {self.patch_dir} directory...\")\n            os.makedirs(self.patch_dir)\n        self.patch_appendix = \"_local\" if self.osc.host == \"127.0.0.1\" else \"_remote\"\n        self.patch_filepath = (\n            self.patch_dir + \"/\" + patch_filepath + self.patch_appendix\n        )\n        if patch_type == \"Max\":\n            self.patcher = MaxPatcher(self.osc, self.client_name, self.patch_filepath)\n        elif patch_type == \"Pd\":\n            if pd_bela is True:\n                self.patcher = PdPatcher(\n                    self.osc,\n                    self.client_name,\n                    self.patch_filepath,\n                    net_or_udp=pd_net_or_udp,\n                    bela=True,\n                )\n            else:\n                self.patcher = PdPatcher(\n                    self.osc,\n                    self.client_name,\n                    self.patch_filepath,\n                    net_or_udp=pd_net_or_udp,\n                )\n        else:\n            assert False, \"`patch_type` must be 'Max' or 'Pd'\"\n\n    def add(self, **kwargs):\n        print(\n            \"DeprecationError: OSCMap.add() has been split into separate functions: use `send_args`, `send_list`, `receive_args` or `receive_list` instead!\"\n        )\n        exit()\n\n    def map_func_to_dict(self, func, kwargs):\n        if \"name\" not in kwargs:\n            n = func.__name__\n            address = \"/\" + n.replace(\"_\", \"/\")\n        else:\n            if isinstance(kwargs[\"name\"], str):\n                n = kwargs[\"name\"]\n                address = \"/\" + kwargs[\"name\"].replace(\"_\", \"/\")\n            else:\n                raise TypeError(\n                    f\"OSC func name must be string, found {str(type(kwargs['name']))}\"\n                )\n        # TODO: Move this into specific send/receive functions\n        params = {\n            k: v\n            for k, v in kwargs.items()\n            if k != \"count\" and k != \"send_mode\" and k != \"length\" and k != \"name\"\n        }\n        # TODO: turn params into dict with type hints (see export_dict)\n        hints = get_type_hints(func)\n        f = {\"f\": func, \"name\": n, \"address\": address, \"params\": params, \"hints\": hints}\n        return f\n\n    \"\"\"\n    send args\n    \"\"\"\n\n    def send_args(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_send_args(func, kwargs)\n                return func()\n\n            default_args = [\n                kwargs[a][0]\n                for a in kwargs\n                if a != \"count\" and a != \"send_mode\" and a != \"name\"\n            ]\n            wrapper(*default_args)\n            return wrapper\n\n        return decorator\n\n    def add_send_args(self, func, kwargs):\n        self.add_send_args_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_send_args_to_patcher(func)\n\n    def add_send_args_to_osc_map(self, func, kwargs):\n        f = self.map_func_to_dict(func, kwargs)\n        if kwargs[\"send_mode\"] == \"broadcast\":\n            f[\"updater\"] = OSCSendUpdater(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        else:\n            f[\"sender\"] = OSCSend(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        f[\"type\"] = \"args\"\n        self.dict[\"send\"][f[\"name\"]] = f\n        if self.export is not None:\n            self.export_dict()\n\n    def add_send_args_to_patcher(self, func):\n        f = self.dict[\"send\"][func.__name__]\n        self.patcher.send_args_func(f)\n\n    \"\"\"\n    send list\n    \"\"\"\n\n    def send_list(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_send_list(func, kwargs)\n                return func()\n\n            default_arg = [\n                kwargs[a][0]\n                for a in kwargs\n                if a != \"count\" and a != \"send_mode\" and a != \"length\" and a != \"name\"\n            ]\n            default_arg = default_arg  # *kwargs['length']\n            wrapper(default_arg)\n            return wrapper\n\n        return decorator\n\n    def add_send_list(self, func, kwargs):\n        self.add_send_list_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_send_list_to_patcher(func)\n\n    def add_send_list_to_osc_map(self, func, kwargs):\n        f = self.map_func_to_dict(func, kwargs)\n        hint = f[\"hints\"][\"return\"]\n        assert hint == list[float], \"send_list can only send list[float], found \" + str(\n            hint\n        )\n        if kwargs[\"send_mode\"] == \"broadcast\":\n            f[\"updater\"] = OSCSendUpdater(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        else:\n            f[\"sender\"] = OSCSend(\n                self.osc,\n                f[\"address\"],\n                f=func,\n                count=kwargs[\"count\"],\n                client=self.client_name,\n            )\n        f[\"type\"] = \"list\"\n        f[\"length\"] = kwargs[\"length\"]\n        self.dict[\"send\"][f[\"name\"]] = f\n        if self.export is not None:\n            self.export_dict()\n\n    def add_send_list_to_patcher(self, func):\n        f = self.dict[\"send\"][func.__name__]\n        self.patcher.send_list_func(f)\n\n    \"\"\"\n    send kwargs\n    \"\"\"\n\n    def send_kwargs(self, **kwargs):\n        raise NotImplementedError(\"send_kwargs not implemented yet\")\n\n    \"\"\"\n    receive args\n    \"\"\"\n\n    def receive_args(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_receive_args(func, kwargs)\n                return func(*args)\n\n            default_args = [\n                kwargs[a][0] for a in kwargs if a != \"count\" and a != \"name\"\n            ]\n            wrapper(*default_args)\n            return wrapper\n\n        return decorator\n\n    def add_receive_args(self, func, kwargs):\n        f = self.add_receive_args_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_receive_args_to_patcher(f)\n\n    def add_receive_args_to_osc_map(self, func, kwargs):\n        f = self.map_func_to_dict(func, kwargs)\n        f[\"updater\"] = OSCReceiveUpdater(\n            self.osc, f[\"address\"], f=func, count=kwargs[\"count\"]\n        )\n        f[\"type\"] = \"args\"\n        self.dict[\"receive\"][f[\"name\"]] = f\n        return f\n\n    def add_receive_args_to_patcher(self, func):\n        f = self.dict[\"receive\"][func[\"name\"]]\n        self.patcher.receive_args_func(f)\n\n    def receive_args_inline(self, name: str, receiver_func, **kwargs):\n        kwargs = {**kwargs, **{\"count\": 1, \"name\": name}}\n        self.receive_args(**kwargs)(receiver_func)\n\n    \"\"\"\n    receive list\n    \"\"\"\n\n    def receive_list(self, **kwargs):\n        def decorator(func):\n            def wrapper(*args):\n                self.add_receive_list(func, kwargs)\n                return func(*args)\n\n            # TODO: This probably shouldn't be here...\n            randomised_list = self.randomise_list(\n                kwargs[\"length\"], kwargs[\"vector\"][1], kwargs[\"vector\"][2]\n            )\n            wrapper(randomised_list)\n            return wrapper\n\n        return decorator\n\n    def randomise_list(self, length, min, max):\n        return min + (np.random.rand(length).astype(np.float32) * (max - min))\n\n    def add_receive_list(self, func, kwargs):\n        f = self.add_receive_list_to_osc_map(func, kwargs)\n        if self.create_patch is True:\n            self.add_receive_list_to_patcher(f)\n\n    def add_receive_list_to_osc_map(self, func, kwargs):\n        \"\"\"\n        TODO: Should this support list[float] only, or list[int] list[str] etc?\n        \"\"\"\n        f = self.map_func_to_dict(func, kwargs)\n        assert (\n            len(f[\"params\"]) == 1\n        ), \"receive_list can only receive one param (list[float])\"\n        hint = f[\"hints\"][list(f[\"params\"].keys())[0]]\n        assert (\n            hint == list[float]\n        ), \"receive_list can only receive list[float], found \" + str(hint)\n        f[\"updater\"] = OSCReceiveListUpdater(\n            self.osc, f[\"address\"], f=func, count=kwargs[\"count\"]\n        )\n        f[\"type\"] = \"list\"\n        f[\"length\"] = kwargs[\"length\"]\n        self.dict[\"receive\"][f[\"name\"]] = f\n        if self.export is not None:\n            self.export_dict()\n        return f\n\n    def add_receive_list_to_patcher(self, func):\n        f = self.dict[\"receive\"][func[\"name\"]]\n        self.patcher.receive_list_func(f)\n\n    def receive_list_with_idx(\n        self, name: str, receiver, idx_len: int, vec_len: int, attr=None\n    ):\n        \"\"\"\n        Create an OSC list handler that assumes that the first `idx_len` values are indices into some struct being modified by a receiver function, and the rest are args as a list, i.e.\n            /name idx0 idx1 ... idxN arg0 arg1 ... argM\n            ...\n            receiver((idx0 idx1 ... idxN), args)\n        Intended as a utility function to be used by external classes where it's not possible to use a decorator like `receive_list`.\n        \"\"\"\n\n        def handler(vector: list[float]):\n            arg_len = len(vector[idx_len:])\n            assert (\n                arg_len == vec_len\n            ), f\"len(args) != len(list) ({arg_len} != {vec_len})\"\n            if idx_len:\n                indices = tuple([int(v) for v in vector[:idx_len]])\n                if attr is None:\n                    receiver(indices, vector[idx_len:])\n                else:\n                    receiver(indices, attr, vector[idx_len:])\n            else:\n                if attr is None:\n                    receiver(vector)\n                else:\n                    receiver(attr, vector)\n\n        kwargs = {\n            \"vector\": (0, 0, 1),\n            \"length\": vec_len + idx_len,\n            \"count\": 1,\n            \"name\": name,\n        }\n        self.receive_list(**kwargs)(handler)\n\n    \"\"\"\n    receive kwargs\n    \"\"\"\n\n    def receive_kwargs(self, **kwargs):\n        \"\"\"\n        Same as receive_args but with named params\n        \"\"\"\n        raise NotImplementedError(\"receive_kwargs not implemented yet\")\n\n    \"\"\"\n    xml / json export\n    \"\"\"\n\n    def export_dict(self):\n        \"\"\"\n        Save the OSCMap dict as XML\n        \"\"\"\n        client_ip, client_port = self.osc.client_names[self.client_name]\n        # TODO: This should be defined in the OSCMap dict / on init\n        metadata = {\n            \"HostIP\": self.osc.host,\n            \"HostPort\": str(self.osc.port),\n            \"ClientName\": self.client_name,\n            \"ClientIP\": client_ip,\n            \"ClientPort\": str(client_port),\n        }\n        root = ET.Element(\"OpenSoundControlSchema\")\n        metadata_element = ET.SubElement(root, \"Metadata\", **metadata)\n        sends = self.dict[\"send\"]\n        receives = self.dict[\"receive\"]\n        for io in [\"Send\", \"Receive\"]:\n            ET.SubElement(root, io)\n        for io in [\"send\", \"receive\"]:\n            for name in self.dict[io]:\n                f = self.dict[io][name]\n                if f[\"type\"] == \"args\":\n                    self.xml_add_args_params(root, name, io, f)\n                elif f[\"type\"] == \"list\":\n                    self.xml_add_list_param(root, name, io, f)\n                elif f[\"type\"] == \"kwargs\":\n                    raise NotImplementedError(\"kwargs not implemented yet\")\n        self.export_update(root)\n\n    def xml_add_args_params(self, root, name, io, f):\n        params = f[\"params\"]\n        hints = f[\"hints\"]\n        kw = {\n            \"Address\": \"/\" + name.replace(\"_\", \"/\"),\n            \"Type\": f[\"type\"],\n            \"Params\": str(len(params)),\n        }\n        route = ET.SubElement(root.find(io.capitalize()), \"Route\", **kw)\n        for i, p in enumerate(params):\n            # TODO: This should already be defined by this point\n            if io == \"receive\":\n                p_type = hints[p].__name__\n            elif io == \"send\":\n                p_type = hints[\"return\"].__args__[i].__name__\n            kw = {\n                \"Name\": p,\n                \"Type\": p_type,\n                \"Default\": str(params[p][0]),\n                \"Min\": str(params[p][1]),\n                \"Max\": str(params[p][2]),\n            }\n            ET.SubElement(route, \"Param\", **kw)\n\n    def xml_add_list_param(self, root, name, io, f):\n        params = f[\"params\"]\n        hints = f[\"hints\"]\n        length = f[\"length\"]\n        kw = {\n            \"Address\": \"/\" + name.replace(\"_\", \"/\"),\n            \"Type\": f[\"type\"],\n            \"Length\": str(length),\n        }\n        route = ET.SubElement(root.find(io.capitalize()), \"Route\", **kw)\n        p = list(params.keys())[0]\n        if io == \"receive\":\n            p_type = hints[p].__name__\n        elif io == \"send\":\n            p_type = hints[\"return\"].__args__[0].__name__\n        kw = {\n            \"Name\": p,\n            \"Type\": p_type,\n            \"Default\": str(params[p][0]),\n            \"Min\": str(params[p][1]),\n            \"Max\": str(params[p][2]),\n        }\n        ET.SubElement(route, \"ParamList\", **kw)\n\n    def export_update(self, root):\n        tree = ET.ElementTree(root)\n        ET.indent(tree, space=\"\\t\", level=0)\n        if self.export == \"XML\":\n            self.save_xml(tree, root)\n        elif self.export == \"JSON\":\n            self.save_json(root)\n        elif self.export == True:\n            self.save_xml(tree, root)\n            self.save_json(root)\n\n    def save_xml(self, tree, root):\n        tree.write(self.patch_filepath + \".xml\")\n        print(f\"Exported OSCMap to {self.patch_filepath}.xml\")\n\n    def save_json(self, xml_root):\n        # TODO: params should be `params: []` and not `param: {}, param: {}, ...`\n        json_dict = self.xml_to_json(\n            ET.tostring(xml_root, encoding=\"utf8\", method=\"xml\")\n        )\n        with open(self.patch_filepath + \".json\", \"w\") as f:\n            f.write(json_dict)\n        print(f\"Exported OSCMap to {self.patch_filepath}.json\")\n\n    def etree_to_dict(self, t):\n        tag = self.pascal_to_camel(t.tag)\n        d = {tag: {} if t.attrib else None}\n        children = list(t)\n        if children:\n            dd = {}\n            for dc in map(self.etree_to_dict, children):\n                for k, v in dc.items():\n                    try:\n                        dd[k].append(v)\n                    except KeyError:\n                        dd[k] = [v]\n            d = {tag: {k: v[0] if len(v) == 1 else v for k, v in dd.items()}}\n        if t.attrib:\n            d[tag].update((self.pascal_to_camel(k), v) for k, v in t.attrib.items())\n        if t.text:\n            text = t.text.strip()\n            if children or t.attrib:\n                if text:\n                    d[tag][\"#text\"] = text\n            else:\n                d[tag] = text\n        return d\n\n    def xml_to_json(self, xml_str):\n        e = ET.ElementTree(ET.fromstring(xml_str))\n        return json.dumps(self.etree_to_dict(e.getroot()), indent=4)\n\n    def update(self):\n        for k, v in self.dict[\"send\"].items():\n            if \"updater\" in v:\n                ret = v[\"updater\"]()\n            # v['updater']()\n        for k, v in self.dict[\"receive\"].items():\n            v[\"updater\"]()\n\n    def __call__(self, *args: Any, **kwds: Any) -&gt; Any:\n        self.update()\n</code></pre>"},{"location":"reference/tolvera/osc/oscmap/#tolvera.osc.oscmap.OSCMap.add_receive_list_to_osc_map","title":"<code>add_receive_list_to_osc_map(func, kwargs)</code>","text":"<p>TODO: Should this support list[float] only, or list[int] list[str] etc?</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def add_receive_list_to_osc_map(self, func, kwargs):\n    \"\"\"\n    TODO: Should this support list[float] only, or list[int] list[str] etc?\n    \"\"\"\n    f = self.map_func_to_dict(func, kwargs)\n    assert (\n        len(f[\"params\"]) == 1\n    ), \"receive_list can only receive one param (list[float])\"\n    hint = f[\"hints\"][list(f[\"params\"].keys())[0]]\n    assert (\n        hint == list[float]\n    ), \"receive_list can only receive list[float], found \" + str(hint)\n    f[\"updater\"] = OSCReceiveListUpdater(\n        self.osc, f[\"address\"], f=func, count=kwargs[\"count\"]\n    )\n    f[\"type\"] = \"list\"\n    f[\"length\"] = kwargs[\"length\"]\n    self.dict[\"receive\"][f[\"name\"]] = f\n    if self.export is not None:\n        self.export_dict()\n    return f\n</code></pre>"},{"location":"reference/tolvera/osc/oscmap/#tolvera.osc.oscmap.OSCMap.export_dict","title":"<code>export_dict()</code>","text":"<p>Save the OSCMap dict as XML</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def export_dict(self):\n    \"\"\"\n    Save the OSCMap dict as XML\n    \"\"\"\n    client_ip, client_port = self.osc.client_names[self.client_name]\n    # TODO: This should be defined in the OSCMap dict / on init\n    metadata = {\n        \"HostIP\": self.osc.host,\n        \"HostPort\": str(self.osc.port),\n        \"ClientName\": self.client_name,\n        \"ClientIP\": client_ip,\n        \"ClientPort\": str(client_port),\n    }\n    root = ET.Element(\"OpenSoundControlSchema\")\n    metadata_element = ET.SubElement(root, \"Metadata\", **metadata)\n    sends = self.dict[\"send\"]\n    receives = self.dict[\"receive\"]\n    for io in [\"Send\", \"Receive\"]:\n        ET.SubElement(root, io)\n    for io in [\"send\", \"receive\"]:\n        for name in self.dict[io]:\n            f = self.dict[io][name]\n            if f[\"type\"] == \"args\":\n                self.xml_add_args_params(root, name, io, f)\n            elif f[\"type\"] == \"list\":\n                self.xml_add_list_param(root, name, io, f)\n            elif f[\"type\"] == \"kwargs\":\n                raise NotImplementedError(\"kwargs not implemented yet\")\n    self.export_update(root)\n</code></pre>"},{"location":"reference/tolvera/osc/oscmap/#tolvera.osc.oscmap.OSCMap.receive_kwargs","title":"<code>receive_kwargs(**kwargs)</code>","text":"<p>Same as receive_args but with named params</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def receive_kwargs(self, **kwargs):\n    \"\"\"\n    Same as receive_args but with named params\n    \"\"\"\n    raise NotImplementedError(\"receive_kwargs not implemented yet\")\n</code></pre>"},{"location":"reference/tolvera/osc/oscmap/#tolvera.osc.oscmap.OSCMap.receive_list_with_idx","title":"<code>receive_list_with_idx(name, receiver, idx_len, vec_len, attr=None)</code>","text":"<p>Create an OSC list handler that assumes that the first <code>idx_len</code> values are indices into some struct being modified by a receiver function, and the rest are args as a list, i.e.     /name idx0 idx1 ... idxN arg0 arg1 ... argM     ...     receiver((idx0 idx1 ... idxN), args) Intended as a utility function to be used by external classes where it's not possible to use a decorator like <code>receive_list</code>.</p> Source code in <code>src/tolvera/osc/oscmap.py</code> <pre><code>def receive_list_with_idx(\n    self, name: str, receiver, idx_len: int, vec_len: int, attr=None\n):\n    \"\"\"\n    Create an OSC list handler that assumes that the first `idx_len` values are indices into some struct being modified by a receiver function, and the rest are args as a list, i.e.\n        /name idx0 idx1 ... idxN arg0 arg1 ... argM\n        ...\n        receiver((idx0 idx1 ... idxN), args)\n    Intended as a utility function to be used by external classes where it's not possible to use a decorator like `receive_list`.\n    \"\"\"\n\n    def handler(vector: list[float]):\n        arg_len = len(vector[idx_len:])\n        assert (\n            arg_len == vec_len\n        ), f\"len(args) != len(list) ({arg_len} != {vec_len})\"\n        if idx_len:\n            indices = tuple([int(v) for v in vector[:idx_len]])\n            if attr is None:\n                receiver(indices, vector[idx_len:])\n            else:\n                receiver(indices, attr, vector[idx_len:])\n        else:\n            if attr is None:\n                receiver(vector)\n            else:\n                receiver(attr, vector)\n\n    kwargs = {\n        \"vector\": (0, 0, 1),\n        \"length\": vec_len + idx_len,\n        \"count\": 1,\n        \"name\": name,\n    }\n    self.receive_list(**kwargs)(handler)\n</code></pre>"},{"location":"reference/tolvera/osc/pd/","title":"Pd","text":""},{"location":"reference/tolvera/osc/pd/#tolvera.osc.pd.PdPatcher","title":"<code>PdPatcher</code>","text":"Source code in <code>src/tolvera/osc/pd.py</code> <pre><code>class PdPatcher:\n    def __init__(\n        self,\n        osc,\n        client_name=\"client\",\n        filepath=\"osc_controls\",\n        x=0.0,\n        y=0.0,\n        w=1600.0,\n        h=900.0,\n        net_or_udp=\"udp\",\n        bela=False,\n    ) -&gt; None:\n        self.x, self.y, self.w, self.h = x, y, w, h\n        self.patch_objects = [f\"#N canvas {x} {y} {w} {h} 12;\\n\"]\n        self.patch_connections = []\n        self.types = {\n            \"object\": \"obj\",\n            \"message\": \"msg\",\n            \"number\": \"floatatom\",\n            \"symbol\": \"symbolatom\",\n            \"toggle\": \"toggle\",\n            \"slider\": \"vslider\",\n            \"bang\": \"bng\",\n            \"comment\": \"text\",\n        }\n        self.patch_ids = {}\n        self.osc = osc\n        self.client_name = client_name\n        self.client_address, self.client_port = self.osc.client_names[self.client_name]\n        self.filepath = filepath\n        self.net_or_udp = net_or_udp\n        self.bela = bela\n        self.init()\n\n    \"\"\"\n    init\n    \"\"\"\n\n    def init(self):\n        self.w = 5.5  # default width (scaling factor)\n        self.h = 27.0  # default height (pixels)\n        self.line = 300  # default [line] (timed ramp generator) time in milliseconds\n        self.param_width = 70\n        self.s_x, self.s_y = 30, 30  # sends insertion point\n        self.r_x, self.r_y = 30, 530  # receives\u00a0insertion point\n        self.comment(\"Pd \u2192 Python\", self.s_x, self.s_y)\n        self.comment(\"===========\", self.s_x, self.s_y + self.h / 2)\n        self.patch_ids[\"send\"] = self.osc_send(\n            self.osc.host, self.osc.port, self.s_x, self.s_y + self.h * 2\n        )\n        self.comment(\"Python \u2192 Pd\", self.r_x, self.r_y)\n        self.comment(\"===========\", self.r_x, self.r_y + self.h / 2)\n        self.patch_ids[\"receive\"] = self.osc_receive(\n            self.client_port, self.r_x, self.r_y + self.h * 2\n        )\n        self.s_x += 300\n        self.r_x += 300\n        if self.bela:\n            self.create_bela_main()\n        self.save(self.filepath)\n\n    def create_bela_main(self):\n        if self.filepath.startswith(\"pd/\"):\n            abstraction = self.filepath[3:]\n        with open(\"pd/_main.pd\", \"w\") as f:\n            f.write(f\"#N canvas {self.x} {self.y} {self.w} {self.h} 12;\\n\")\n            f.write(f\"#X obj {30} {30} {abstraction};\\n\")\n\n    \"\"\"\n    basic objects\n    \"\"\"\n\n    def box(self, box_type, x, y, box_text):\n        self.patch_objects.append(f\"#X {box_type} {x} {y} {box_text};\\n\")\n        return self.get_last_id()\n\n    def object(self, obj, x, y):\n        return self.box(\"obj\", x, y, obj)\n\n    def msg(self, msg, x, y):\n        return self.box(\"msg\", x, y, msg)\n\n    def comment(self, text, x, y):\n        return self.box(\"text\", x, y, text)\n\n    def number(self, x, y):\n        return self.box(\"floatatom\", x, y, f\"5 0 0 0 - - - 0\")\n\n    \"\"\"\n    connections\n    \"\"\"\n\n    def connect(self, a_id, a_outlet, b_id, b_inlet):\n        self.patch_connections.append(\n            f\"#X connect {a_id} {a_outlet} {b_id} {b_inlet};\\n\"\n        )\n\n    \"\"\"\n    osc send/receive\n    \"\"\"\n\n    def osc_send(self, host, port, x, y, send_rate_limit=100):\n        loadbang_id = self.object(\"loadbang\", x, y)\n        y += self.h\n        connect_id = self.msg(f\"connect {host} {port}\", x, y)\n        y += self.h\n        disconnect_id = self.msg(\"disconnect\", x + 10, y)\n        metro_id = self.object(f\"metro {send_rate_limit}\", x + 100, y)\n        y += self.h\n        send_rate_id = self.object(\"s rate\", x + 100, y)\n        y += self.h\n        receive_id = self.object(\"r send.to.iipyper\", x + 10, y)\n        y += self.h\n        packOSC_id = self.object(\"packOSC\", x + 10, y)\n        y += self.h\n        send_type = \"netsend -u\" if self.net_or_udp == \"net\" else \"udpsend\"\n        send_id = self.object(send_type, x, y)\n        y += self.h\n        status_id = self.number(x, y)\n        print_id = self.object(\"print reply.from.netreceive\", x + 40, y)\n        # loadbang-&gt;connect-&gt;send-&gt;print\n        self.connect(loadbang_id, 0, connect_id, 0)\n        self.connect(connect_id, 0, send_id, 0)\n        self.connect(send_id, 0, status_id, 0)\n        self.connect(send_id, 1, print_id, 0)\n        # loadbang-&gt;metro-&gt;send_rate\n        self.connect(loadbang_id, 0, metro_id, 0)\n        self.connect(metro_id, 0, send_rate_id, 0)\n        # disconnect-&gt;send\n        self.connect(disconnect_id, 0, send_id, 0)\n        # receive-&gt;packOSC-&gt;send\n        self.connect(receive_id, 0, packOSC_id, 0)\n        self.connect(packOSC_id, 0, send_id, 0)\n        return send_id\n\n    def osc_receive(self, port, x, y):\n        receive_type = (\n            f\"netreceive -u {port}\"\n            if self.net_or_udp == \"net\"\n            else f\"udpreceive {port}\"\n        )\n        receive_id = self.object(receive_type, x, y)\n        y += self.h\n        unpackOSC_id = self.object(\"unpackOSC\", x, y)\n        y += self.h\n        print_id = self.object(\"print receive.from.iipyper\", x + 20, y)\n        y += self.h\n        s_receive_id = self.object(\"s receive.from.iipyper\", x, y)\n        self.connect(receive_id, 0, unpackOSC_id, 0)\n        self.connect(unpackOSC_id, 0, s_receive_id, 0)\n        self.connect(unpackOSC_id, 0, print_id, 0)\n        return self.get_last_id()\n\n    \"\"\"\n    osc send/receive args/list\n    \"\"\"\n\n    def send_args_func(self, f):\n        hints = typing.get_type_hints(f[\"f\"])[\"return\"].__args__\n        f_p = f[\"params\"]\n        params = []\n        if len(f_p) == 0:\n            self.osc_receive_msg(self.r_x, self.r_y, f[\"address\"])\n        else:\n            for k, p in f_p.items():\n                p_def, p_min, p_max = f_p[k][0], f_p[k][1], f_p[k][2]\n                params.append(\n                    {\n                        \"label\": k,\n                        \"data\": hints[k].__name__,\n                        \"min_val\": p_min,\n                        \"size\": p_max - p_min,\n                    }\n                )\n            self.osc_receive_with_controls(self.r_x, self.r_y, f[\"address\"], params)\n        self.r_x += max(\n            len(params) * self.param_width + 100.0, len(f[\"address\"]) * 15.0 + 25.0\n        )\n        self.save(self.filepath)\n\n    def send_list_func(self, f):\n        self.osc_receive_list(self.r_x, self.r_y, f[\"address\"], f[\"params\"])\n        self.r_x += len(f[\"address\"]) * 15.0 + 25.0\n        self.save(self.filepath)\n\n    def receive_args_func(self, f):\n        hints = typing.get_type_hints(f[\"f\"])\n        f_p = f[\"params\"]\n        params = []\n        if len(f_p) == 0:\n            self.osc_send_msg(self.s_x, self.s_y, f[\"address\"])\n        else:\n            for k, p in f_p.items():\n                # TODO: handle strings\n                if isinstance(p, str):\n                    continue\n                p_def, p_min, p_max = f_p[k][0], f_p[k][1], f_p[k][2]\n                params.append(\n                    {\n                        \"label\": k,\n                        \"data\": hints[k].__name__,\n                        \"min_val\": p_min,\n                        \"size\": p_max - p_min,\n                    }\n                )\n            self.osc_send_with_controls(self.s_x, self.s_y, f[\"address\"], params)\n        self.s_x += max(\n            len(params) * self.param_width + 100.0, len(f[\"address\"]) * 15.0 + 25.0\n        )\n        self.save(self.filepath)\n\n    def receive_list_func(self, f):\n        self.osc_send_list(self.s_x, self.s_y, f[\"address\"], f[\"params\"])\n        self.s_x += len(f[\"address\"]) * 15.0 + 25.0\n        self.save(self.filepath)\n\n    \"\"\"\n    osc send/receive no args/list (msg)\n    \"\"\"\n\n    def osc_receive_msg(self, x, y, path):\n        \"\"\"\n        does this even make sense?\n        \"\"\"\n        receive_id = self.msg(\"r receive.from.iipyper\", x, y)\n        msg_id = self.comment(path, x, y)\n        self.connect(receive_id, 0, msg_id, 0)\n        return msg_id\n\n    def osc_send_msg(self, x, y, path):\n        msg_id = self.msg(path, x, y + 225 + self.h)\n        send_id = self.object(\"s send.to.iipyper\", x, y + 250 + self.h)\n        self.connect(msg_id, 0, send_id, 0)\n        return msg_id\n\n    \"\"\"\n    osc send/receive args with line, slider, rate-limiting, and change detection\n    \"\"\"\n\n    def osc_receive_with_controls(self, x, y, path, parameters):\n        \"\"\"\n        TODO: Does [route] need to be broken down into individual subpaths?\n        \"\"\"\n\n        # [comment path]\n        y_off = 0\n        path_comment_id = self.comment(path, x, y + y_off)\n\n        # [r receive]\n        y_off += self.h\n        receive_id = self.object(\"r receive.from.iipyper\", x, y + y_off)\n\n        # [route /path]\n        y_off += self.h\n        route_id = self.object(\"routeOSC \" + path, x, y + y_off)\n\n        # [unpack f f f ...] [print /path]\n        y_off += self.h\n        unpack_id = self.object(\"unpack \" + self._pack_args(parameters), x, y + y_off)\n        unpack_width = len(parameters) * 7 + 60\n        print_id = self.object(\"print \" + path, x + unpack_width + 10, y + y_off)\n\n        # sliders\n        y_off += 10\n        slider_ids, float_ids, int_ids, tbf_ids, _y_off = self.sliders(\n            x, y + y_off, parameters, \"receive\"\n        )\n        y_off += 160\n\n        # [s arg_name]\n        y_off += _y_off + 75\n        send_ids = [\n            self.object(\n                \"s \" + self.path_to_snakecase(path) + \"_\" + p[\"label\"][0:3],\n                x + i * self.param_width,\n                y + y_off + (0 if i % 2 == 0 else 25),\n            )\n            for i, p in enumerate(parameters)\n        ]\n\n        # [comment params]\n        y_off += 50\n        param_comment_ids, _y_off = self.param_comments(x, y + y_off, parameters)\n\n        # # connections\n        self.connect(receive_id, 0, route_id, 0)\n        self.connect(route_id, 0, unpack_id, 0)\n        self.connect(route_id, 0, print_id, 0)\n        [self.connect(unpack_id, i, slider_ids[i], 0) for i in range(len(parameters))]\n        [self.connect(float_ids[i], 0, send_ids[i], 0) for i in range(len(parameters))]\n\n        return slider_ids, unpack_id\n\n    def osc_send_with_controls(self, x, y, path, parameters):\n        y_off = 0\n        # [comment path]\n        path_comment_id = self.comment(path, x, y + y_off)\n        y_off += 15\n        param_comment_ids, _y_off = self.param_comments(x, y + y_off, parameters)\n\n        # [r path_arg_name]\n        y_off += 35\n        receive_ids = [\n            self.object(\n                \"r \" + self.path_to_snakecase(path) + \"_\" + p[\"label\"][0:3],\n                x + i * self.param_width,\n                y + y_off + (0 if i % 2 == 0 else 25),\n            )\n            for i, p in enumerate(parameters)\n        ]\n        y_off += 30\n\n        # sliders\n        slider_ids, slider_float_ids, int_ids, tbf_ids, _y_off = self.sliders(\n            x, y + y_off, parameters, \"send\"\n        )\n        y_off += self.h * 3  # line\n        y_off += _y_off + 25\n        y_off += 225\n\n        pack_id = -1\n        out_id = -1\n        # [pack $1 $2 $3 ...]\n        if len(parameters) &gt; 1:\n            pack_id = self.object(\"pack \" + self._pack_args(parameters), x, y + y_off)\n            out_id = pack_id\n\n        # [msg /path $1 $2 $3 ...]\n        y_off += 25\n        msg_args = self._msg_args(parameters)\n        msg_id = self.msg(path + \" \" + msg_args, x, y + y_off)\n        out_id = msg_id if len(parameters) == 1 else out_id\n        # [s send]\n        y_off += 25\n        send_id = self.object(\"s send.to.iipyper\", x, y + y_off)\n\n        # connections\n        for i in range(len(parameters)):\n            rcv = receive_ids[i]\n            slider = slider_ids[i]\n            slider_float = slider_float_ids[i]\n            int_id = int_ids[i]\n            tbf_id = tbf_ids[i]\n\n            self.connect(rcv, 0, slider[0], 0)\n            self.connect(rcv, 0, slider[1], 0)\n            if int_id == -1 and tbf_id == -1:  # if no int or tbf\n                self.connect(slider_float, 0, out_id, 0)\n            elif int_id != -1 and tbf_id == -1:  # if int but no tbf\n                self.connect(slider_float, 0, out_id, 0)\n            elif int_id == -1 and tbf_id != -1:  # if tbf but no int\n                self.connect(tbf_id, 0, out_id, 0)\n                self.connect(tbf_id, 1, pack_id, i) if pack_id != -1 else None\n            elif int_id != -1 and tbf_id != -1:  # if both int and tbf\n                self.connect(tbf_id, 0, out_id, 0)\n                self.connect(tbf_id, 1, pack_id, i) if pack_id != -1 else None\n\n        self.connect(pack_id, 0, msg_id, 0) if pack_id != -1 else None\n        self.connect(msg_id, 0, send_id, 0)\n        return slider_ids, pack_id, msg_id\n\n    \"\"\"\n    sliders\n    \"\"\"\n\n    def sliders(self, x, y, sliders, io=None):\n        assert io is not None, 'io must be \"send\" or \"receive\"'\n        \"\"\"\n        sliders = [\n          { 'label': 'x', data: 'float', min_val: 0.0, size: 0.0 },\n        ]\n        \"\"\"\n        slider_ids = []\n        float_ids = []\n        int_ids = []\n        tbf_ids = []\n        y_off = 0\n        send_rate_id = self.object(\"r rate\", x - 50, y + 155 + self.h * 3)\n        for i, s in enumerate(sliders):\n            y_off = 0\n            x_i = x + (i * self.param_width)\n            y_off += self.h\n            slider_id, int_id, float_id, tbf_id = self.slider(\n                send_rate_id,\n                x_i,\n                y + y_off,\n                s[\"min_val\"],\n                s[\"size\"],\n                float=s[\"data\"] == \"float\",\n                io=io if i &gt; 0 else \"skip\",\n            )\n            slider_ids.append(slider_id)\n            float_ids.append(float_id)\n            int_ids.append(int_id)\n            tbf_ids.append(tbf_id)\n        return slider_ids, float_ids, int_ids, tbf_ids, y_off\n\n    def slider(self, send_rate_id, x, y, min_val, size, float=False, io=None):\n        assert io is not None, 'io must be \"send\" or \"receive\"'\n        bang_id = self.object(\"bng\", x, y)\n        y += self.h\n        msg_id = self.msg(f\"{self.line}\", x, y)\n        y += self.h\n        line_id = self.object(f\"line 0 {self.line}\", x, y)\n        y += self.h\n        slider_id = self.box(\n            \"obj\",\n            x,\n            y,\n            f\"vsl 20 120 {min_val} {min_val+size} 0 0 empty empty empty 0 -9 0 12 #fcfcfc #000000 #000000 0 1\",\n        )\n        self.connect(bang_id, 0, msg_id, 0)\n        self.connect(msg_id, 0, line_id, 1)\n        self.connect(line_id, 0, slider_id, 0)\n        y += 120 + 8\n        int_id = -1\n        tbf_id = -1\n        float_id = -1\n        if float == False and io == \"send\":\n            y, change_id, tbf_id = self.send_rate_limit_int(\n                slider_id, send_rate_id, x, y\n            )\n        elif float == False and io != \"send\":\n            y, change_id = self.receive_rate_limit_int(slider_id, send_rate_id, x, y)\n        elif float == True and io == \"send\":\n            y, change_id, tbf_id = self.send_rate_limit_float(\n                slider_id, send_rate_id, x, y\n            )\n        elif float == True and io != \"send\":\n            y, change_id = self.recieve_rate_limit_float(slider_id, send_rate_id, x, y)\n        return (line_id, bang_id), int_id, change_id, tbf_id\n\n    def send_rate_limit_int(self, slider_id, send_rate_id, x, y):\n        # int -&gt; number -&gt; t b f\n        int_id = self.object(\"int\", x, y)\n        y += self.h\n        float_id = self.number(x, y)\n        y += self.h\n        zl_id = self.object(\"zl reg\", x, y)\n        y += self.h\n        change_id = self.object(\"change\", x, y)\n        y += self.h\n        tbf_id = self.object(\"t b f\", x, y)\n        self.connect(slider_id, 0, int_id, 0)\n        self.connect(int_id, 0, float_id, 0)\n        self.connect(float_id, 0, zl_id, 1)\n        self.connect(send_rate_id, 0, zl_id, 0)\n        self.connect(zl_id, 0, change_id, 0)\n        self.connect(change_id, 0, tbf_id, 0)\n        return y, change_id, tbf_id\n\n    def receive_rate_limit_int(self, slider_id, send_rate_id, x, y):\n        # int -&gt; number\n        int_id = self.object(\"int\", x, y)\n        y += self.h\n        float_id = self.number(x, y)\n        y += self.h\n        zl_id = self.object(\"zl reg\", x, y)\n        y += self.h\n        change_id = self.object(\"change\", x, y)\n        self.connect(slider_id, 0, int_id, 0)\n        self.connect(int_id, 0, float_id, 0)\n        self.connect(float_id, 0, zl_id, 1)\n        self.connect(send_rate_id, 0, zl_id, 0)\n        self.connect(zl_id, 0, change_id, 0)\n        return y, change_id\n\n    def send_rate_limit_float(self, slider_id, send_rate_id, x, y):\n        # number -&gt; t b f\n        float_id = self.number(x, y)\n        y += self.h\n        zl_id = self.object(\"zl reg\", x, y)\n        y += self.h\n        change_id = self.object(\"change\", x, y)\n        y += self.h\n        tbf_id = self.object(\"t b f\", x, y)\n        self.connect(slider_id, 0, float_id, 0)\n        self.connect(float_id, 0, zl_id, 1)\n        self.connect(send_rate_id, 0, zl_id, 0)\n        self.connect(zl_id, 0, change_id, 0)\n        self.connect(change_id, 0, tbf_id, 0)\n        return y, change_id, tbf_id\n\n    def recieve_rate_limit_float(self, slider_id, send_rate_id, x, y):\n        # number\n        float_id = self.number(x, y)\n        y += self.h\n        zl_id = self.object(\"zl reg\", x, y)\n        y += self.h\n        change_id = self.object(\"change\", x, y)\n        self.connect(slider_id, 0, float_id, 0)\n        self.connect(float_id, 0, zl_id, 1)\n        self.connect(send_rate_id, 0, zl_id, 0)\n        self.connect(zl_id, 0, change_id, 0)\n        return y, change_id\n\n    \"\"\"\n    comments\n    \"\"\"\n\n    def param_comments(self, x, y, params):\n        comment_ids = []\n        y_off = 0\n        for i, p in enumerate(params):\n            y_off = 0\n            x_i = x + (i * self.param_width)\n            p_max = (\n                p[\"min_val\"] + p[\"size\"]\n                if p[\"data\"] == \"float\"\n                else p[\"min_val\"] + p[\"size\"] - 1\n            )\n            comment_id1 = self.comment(f'{p[\"label\"]}', x_i, y)\n            y_off += 15\n            comment_id2 = self.comment(\n                f'{p[\"data\"][0]} {p[\"min_val\"]} {p_max}', x_i, y + y_off\n            )\n            comment_ids.append(comment_id1)\n            comment_ids.append(comment_id2)\n        return comment_ids, y_off\n\n    \"\"\"\n    lists\n    \"\"\"\n\n    def osc_send_list(self, x, y, path, params):\n        \"\"\"\n        [comment] path, list name, params\n        [r] path\n        [list prepend path]\n        [list trim]\n        [s send.to.iipyper]\n        \"\"\"\n        y_off = 0\n        self.comment(path, x, y)\n        y_off += 15\n        l = list(params.items())[0]\n        self.comment(f\"{l[0]}\", x, y + y_off)\n        y_off += 15\n        self.comment(f\"l {l[1][1]} {l[1][2]}\", x, y + y_off)\n        y_off += self.h\n        receive_id = self.object(f\"r {self.path_to_snakecase(path)}\", x, y + y_off)\n        y_off += self.h\n        prepend_id = self.object(f\"list prepend {path}\", x, y + y_off)\n        y_off += self.h\n        trim_id = self.object(f\"list trim\", x, y + y_off)\n        y_off += self.h\n        send_id = self.object(f\"s send.to.iipyper\", x, y + y_off)\n        self.connect(receive_id, 0, prepend_id, 0)\n        self.connect(prepend_id, 0, trim_id, 0)\n        self.connect(trim_id, 0, send_id, 0)\n\n    def osc_receive_list(self, x, y, path, params):\n        \"\"\"\n        [comment] path\n        [r receive.from.iipyper]\n        [routeOSC path]\n        [s path]\n        [comment] params\n        \"\"\"\n        y_off = 0\n        self.comment(path, x, y)\n        y_off += self.h\n        receive_id = self.object(f\"r receive.from.iipyper\", x, y + y_off)\n        y_off += self.h\n        route_id = self.object(f\"routeOSC {path}\", x, y + y_off)\n        y_off += self.h\n        send_id = self.object(f\"s {self.path_to_snakecase(path)}\", x, y + y_off)\n        y_off += self.h\n        l = list(params.items())[0]\n        self.comment(f\"{l[0]}\", x, y + y_off)\n        y_off += 15\n        self.comment(f\"l {l[1][1]} {l[1][2]}\", x, y + y_off)\n        self.connect(receive_id, 0, route_id, 0)\n        self.connect(route_id, 0, send_id, 0)\n\n    \"\"\"\n    utils\n    \"\"\"\n\n    def get_last_id(self):\n        return len(self.patch_objects) - 2\n\n    def _pack_args(self, args):\n        arg_types = []\n        for a in args:\n            match a[\"data\"]:\n                case \"int\":\n                    arg_types.append(\"f\")\n                case \"float\":\n                    arg_types.append(\"f\")\n                case \"string\":\n                    arg_types.append(\"s\")\n        return \" \".join(arg_types)\n\n    def _msg_args(self, args):\n        return \" \".join([\"\\$\" + str(i + 1) for i in range(len(args))])\n\n    def path_to_snakecase(self, path):\n        return path.replace(\"/\", \"_\")[1:]  # +'_'+label[0:3]\n\n    \"\"\"\n    save/load\n    \"\"\"\n\n    def save(self, name):\n        with open(name + \".pd\", \"w\") as f:\n            [f.write(o) for o in self.patch_objects]\n            [f.write(c) for c in self.patch_connections]\n\n    def load(self, name):\n        with open(name + \".pd\", \"r\") as f:\n            for line in f:\n                if f.startswith(\"#X connect\"):\n                    self.patch_connections.append(f)\n                else:\n                    self.patch_objects.append(f)\n</code></pre>"},{"location":"reference/tolvera/osc/pd/#tolvera.osc.pd.PdPatcher.osc_receive_list","title":"<code>osc_receive_list(x, y, path, params)</code>","text":"<p>[comment] path [r receive.from.iipyper] [routeOSC path] s path params</p> Source code in <code>src/tolvera/osc/pd.py</code> <pre><code>def osc_receive_list(self, x, y, path, params):\n    \"\"\"\n    [comment] path\n    [r receive.from.iipyper]\n    [routeOSC path]\n    [s path]\n    [comment] params\n    \"\"\"\n    y_off = 0\n    self.comment(path, x, y)\n    y_off += self.h\n    receive_id = self.object(f\"r receive.from.iipyper\", x, y + y_off)\n    y_off += self.h\n    route_id = self.object(f\"routeOSC {path}\", x, y + y_off)\n    y_off += self.h\n    send_id = self.object(f\"s {self.path_to_snakecase(path)}\", x, y + y_off)\n    y_off += self.h\n    l = list(params.items())[0]\n    self.comment(f\"{l[0]}\", x, y + y_off)\n    y_off += 15\n    self.comment(f\"l {l[1][1]} {l[1][2]}\", x, y + y_off)\n    self.connect(receive_id, 0, route_id, 0)\n    self.connect(route_id, 0, send_id, 0)\n</code></pre>"},{"location":"reference/tolvera/osc/pd/#tolvera.osc.pd.PdPatcher.osc_receive_msg","title":"<code>osc_receive_msg(x, y, path)</code>","text":"<p>does this even make sense?</p> Source code in <code>src/tolvera/osc/pd.py</code> <pre><code>def osc_receive_msg(self, x, y, path):\n    \"\"\"\n    does this even make sense?\n    \"\"\"\n    receive_id = self.msg(\"r receive.from.iipyper\", x, y)\n    msg_id = self.comment(path, x, y)\n    self.connect(receive_id, 0, msg_id, 0)\n    return msg_id\n</code></pre>"},{"location":"reference/tolvera/osc/pd/#tolvera.osc.pd.PdPatcher.osc_receive_with_controls","title":"<code>osc_receive_with_controls(x, y, path, parameters)</code>","text":"<p>TODO: Does [route] need to be broken down into individual subpaths?</p> Source code in <code>src/tolvera/osc/pd.py</code> <pre><code>def osc_receive_with_controls(self, x, y, path, parameters):\n    \"\"\"\n    TODO: Does [route] need to be broken down into individual subpaths?\n    \"\"\"\n\n    # [comment path]\n    y_off = 0\n    path_comment_id = self.comment(path, x, y + y_off)\n\n    # [r receive]\n    y_off += self.h\n    receive_id = self.object(\"r receive.from.iipyper\", x, y + y_off)\n\n    # [route /path]\n    y_off += self.h\n    route_id = self.object(\"routeOSC \" + path, x, y + y_off)\n\n    # [unpack f f f ...] [print /path]\n    y_off += self.h\n    unpack_id = self.object(\"unpack \" + self._pack_args(parameters), x, y + y_off)\n    unpack_width = len(parameters) * 7 + 60\n    print_id = self.object(\"print \" + path, x + unpack_width + 10, y + y_off)\n\n    # sliders\n    y_off += 10\n    slider_ids, float_ids, int_ids, tbf_ids, _y_off = self.sliders(\n        x, y + y_off, parameters, \"receive\"\n    )\n    y_off += 160\n\n    # [s arg_name]\n    y_off += _y_off + 75\n    send_ids = [\n        self.object(\n            \"s \" + self.path_to_snakecase(path) + \"_\" + p[\"label\"][0:3],\n            x + i * self.param_width,\n            y + y_off + (0 if i % 2 == 0 else 25),\n        )\n        for i, p in enumerate(parameters)\n    ]\n\n    # [comment params]\n    y_off += 50\n    param_comment_ids, _y_off = self.param_comments(x, y + y_off, parameters)\n\n    # # connections\n    self.connect(receive_id, 0, route_id, 0)\n    self.connect(route_id, 0, unpack_id, 0)\n    self.connect(route_id, 0, print_id, 0)\n    [self.connect(unpack_id, i, slider_ids[i], 0) for i in range(len(parameters))]\n    [self.connect(float_ids[i], 0, send_ids[i], 0) for i in range(len(parameters))]\n\n    return slider_ids, unpack_id\n</code></pre>"},{"location":"reference/tolvera/osc/pd/#tolvera.osc.pd.PdPatcher.osc_send_list","title":"<code>osc_send_list(x, y, path, params)</code>","text":"<p>[comment] path, list name, params [r] path [list prepend path] [list trim] [s send.to.iipyper]</p> Source code in <code>src/tolvera/osc/pd.py</code> <pre><code>def osc_send_list(self, x, y, path, params):\n    \"\"\"\n    [comment] path, list name, params\n    [r] path\n    [list prepend path]\n    [list trim]\n    [s send.to.iipyper]\n    \"\"\"\n    y_off = 0\n    self.comment(path, x, y)\n    y_off += 15\n    l = list(params.items())[0]\n    self.comment(f\"{l[0]}\", x, y + y_off)\n    y_off += 15\n    self.comment(f\"l {l[1][1]} {l[1][2]}\", x, y + y_off)\n    y_off += self.h\n    receive_id = self.object(f\"r {self.path_to_snakecase(path)}\", x, y + y_off)\n    y_off += self.h\n    prepend_id = self.object(f\"list prepend {path}\", x, y + y_off)\n    y_off += self.h\n    trim_id = self.object(f\"list trim\", x, y + y_off)\n    y_off += self.h\n    send_id = self.object(f\"s send.to.iipyper\", x, y + y_off)\n    self.connect(receive_id, 0, prepend_id, 0)\n    self.connect(prepend_id, 0, trim_id, 0)\n    self.connect(trim_id, 0, send_id, 0)\n</code></pre>"},{"location":"reference/tolvera/osc/update/","title":"Update","text":""},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCReceiveListUpdater","title":"<code>OSCReceiveListUpdater</code>","text":"<p>             Bases: <code>ReceiveListUpdater</code></p> <p>ReceiveListUpdater with an OSC handler</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCReceiveListUpdater(ReceiveListUpdater):\n    \"\"\"\n    ReceiveListUpdater with an OSC handler\n    \"\"\"\n\n    def __init__(self, osc, address: str, f, state=None, count=10, update=False):\n        super().__init__(f, state, count, update)\n        self.osc = osc\n        self.address = address\n        osc.add_handler(self.address, self.receive)\n\n    def receive(self, address, *args):\n        self.set(list(args[1:]))\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCReceiveUpdater","title":"<code>OSCReceiveUpdater</code>","text":"<p>             Bases: <code>ReceiveUpdater</code></p> <p>ReceiveUpdater with an OSC handler</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCReceiveUpdater(ReceiveUpdater):\n    \"\"\"\n    ReceiveUpdater with an OSC handler\n    \"\"\"\n\n    def __init__(self, osc, address: str, f, state=None, count=10, update=False):\n        super().__init__(f, state, count, update)\n        self.osc = osc\n        self.address = address\n        osc.add_handler(self.address, self.receive)\n\n    def receive(self, address, *args):\n        # FIXME: ip:port/args\n        \"\"\"\n        v: first argument to the handler is the IP:port of the sender\n        v: or you can use dispatcher.map directly\n           and not set needs_reply_address=True\n        j: can I get ip:port from osc itself?\n        v: if you know the sender ahead of time yeah,\n           but that lets you respond to different senders dynamically\n        \"\"\"\n        self.set(args[1:])\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCReceiveUpdater.receive","title":"<code>receive(address, *args)</code>","text":"<p>v: first argument to the handler is the IP:port of the sender v: or you can use dispatcher.map directly    and not set needs_reply_address=True j: can I get ip:port from osc itself? v: if you know the sender ahead of time yeah,    but that lets you respond to different senders dynamically</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>def receive(self, address, *args):\n    # FIXME: ip:port/args\n    \"\"\"\n    v: first argument to the handler is the IP:port of the sender\n    v: or you can use dispatcher.map directly\n       and not set needs_reply_address=True\n    j: can I get ip:port from osc itself?\n    v: if you know the sender ahead of time yeah,\n       but that lets you respond to different senders dynamically\n    \"\"\"\n    self.set(args[1:])\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCReceiveUpdaters","title":"<code>OSCReceiveUpdaters</code>","text":"<p>o = OSCReceiveUpdaters(osc,     {\"/tolvera/particles/pos\": s.osc_set_pos,      \"/tolvera/particles/vel\": s.osc_set_vel})</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCReceiveUpdaters:\n    \"\"\"\n    o = OSCReceiveUpdaters(osc,\n        {\"/tolvera/particles/pos\": s.osc_set_pos,\n         \"/tolvera/particles/vel\": s.osc_set_vel})\n    \"\"\"\n\n    def __init__(self, osc, receives=None, count=10):\n        self.osc = osc\n        self.receives = []\n        self.count = count\n        if receives is not None:\n            self.add_dict(receives, count=self.count)\n\n    def add_dict(self, receives, count=None):\n        if count is None:\n            count = self.count\n        {a: self.add(a, f, count=count) for a, f in receives.items()}\n\n    def add(self, address, function, state=None, count=None, update=False):\n        if count is None:\n            count = self.count\n        self.receives.append(\n            OSCReceiveUpdater(self.osc, address, function, state, count, update)\n        )\n\n    def __call__(self):\n        [r() for r in self.receives]\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCSend","title":"<code>OSCSend</code>","text":"<p>Non rate-limited OSC send</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCSend:\n    \"\"\"\n    Non rate-limited OSC send\n    \"\"\"\n\n    def __init__(self, osc, address: str, f, count=30, client=None):\n        self.osc = osc\n        self.address = address\n        self.f = f\n        self.client = client\n\n    def __call__(self, *args):\n        self.osc.send(self.address, *self.f(*args), client=self.client)\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCSendUpdater","title":"<code>OSCSendUpdater</code>","text":"<p>Rate-limited OSC send</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCSendUpdater:\n    \"\"\"\n    Rate-limited OSC send\n    \"\"\"\n\n    def __init__(self, osc, address: str, f, count=30, client=None):\n        self.osc = osc\n        self.address = address\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.client = client\n\n    def __call__(self):\n        self.counter += 1\n        if self.counter &gt;= self.count:\n            self.osc.send(self.address, *self.f(), client=self.client)\n            self.counter = 0\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCSendUpdaters","title":"<code>OSCSendUpdaters</code>","text":"<p>o = OSCSendUpdaters(osc, client=\"particles\", count=10,     sends={         \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all     })</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCSendUpdaters:\n    \"\"\"\n    o = OSCSendUpdaters(osc, client=\"particles\", count=10,\n        sends={\n            \"/tolvera/particles/get/pos/all\": s.osc_get_pos_all\n        })\n    \"\"\"\n\n    def __init__(self, osc, sends=None, count=10, client=None):\n        self.osc = osc\n        self.sends = []\n        self.count = count\n        self.client = client\n        if sends is not None:\n            self.add_dict(sends, self.count, self.client)\n\n    def add_dict(self, sends, count=None, client=None):\n        if count is None:\n            count = self.count\n        if client is None:\n            client = self.client\n        {a: self.add(a, f, count=count, client=client) for a, f in sends.items()}\n\n    def add(self, address, function, state=None, count=None, update=False, client=None):\n        if count is None:\n            count = self.count\n        if client is None:\n            client = self.client\n        self.sends.append(OSCSendUpdater(self.osc, address, function, count, client))\n\n    def __call__(self):\n        [s() for s in self.sends]\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.OSCUpdaters","title":"<code>OSCUpdaters</code>","text":"<p>o = OSCUpdaters(osc, client=\"boids\", count=10,     receives={         \"/tolvera/boids/pos\": b.osc_set_pos,         \"/tolvera/boids/vel\": b.osc_set_vel     },     sends={         \"/tolvera/boids/pos/all\": b.osc_get_all_pos     } )</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class OSCUpdaters:\n    \"\"\"\n    o = OSCUpdaters(osc, client=\"boids\", count=10,\n        receives={\n            \"/tolvera/boids/pos\": b.osc_set_pos,\n            \"/tolvera/boids/vel\": b.osc_set_vel\n        },\n        sends={\n            \"/tolvera/boids/pos/all\": b.osc_get_all_pos\n        }\n    )\n    \"\"\"\n\n    def __init__(\n        self,\n        osc,\n        sends=None,\n        receives=None,\n        send_count=60,\n        receive_count=10,\n        client=None,\n    ):\n        self.osc = osc\n        self.client = client\n        self.send_count = send_count\n        self.receive_count = receive_count\n        self.sends = OSCSendUpdaters(\n            self.osc, count=self.send_count, client=self.client\n        )\n        self.receives = OSCReceiveUpdaters(self.osc, count=self.receive_count)\n        if sends is not None:\n            self.add_sends(sends)\n        if receives is not None:\n            self.add_receives(receives)\n\n    def add_sends(self, sends, count=None, client=None):\n        if count is None:\n            count = self.send_count\n        if client is None:\n            client = self.client\n        self.sends.add_dict(sends, count, client)\n\n    def add_send(self, send, count=None, client=None):\n        if count is None:\n            count = self.send_count\n        if client is None:\n            client = self.client\n        self.sends.add(send, client=client, count=count)\n\n    def add_receives(self, receives, count=None):\n        if count is None:\n            count = self.receive_count\n        self.receives.add_dict(receives, count=count)\n\n    def add_receive(self, receive, count=None):\n        if count is None:\n            count = self.receive_count\n        self.receives.add(receive, count=count)\n\n    def __call__(self):\n        self.sends()\n        self.receives()\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.ReceiveListUpdater","title":"<code>ReceiveListUpdater</code>","text":"<p>Decouples event handling from updating Updating is rate-limited by a counter Assumes a list[float] instead of *args</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class ReceiveListUpdater:\n    \"\"\"\n    Decouples event handling from updating\n    Updating is rate-limited by a counter\n    Assumes a list[float] instead of *args\n    \"\"\"\n\n    def __init__(self, f, state=None, count=5, update=False):\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.update = update\n        self.state = state\n\n    def set(self, state):\n        \"\"\"\n        Set the Updater's state\n        \"\"\"\n        self.state = state\n        self.update = True\n\n    def __call__(self):\n        \"\"\"\n        Update the target function with internal state\n        \"\"\"\n        self.counter += 1\n        if not (self.update and self.counter &gt; self.count and self.state is not None):\n            return\n        self.f(self.state)\n        self.counter = 0\n        self.update = False\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.ReceiveListUpdater.__call__","title":"<code>__call__()</code>","text":"<p>Update the target function with internal state</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>def __call__(self):\n    \"\"\"\n    Update the target function with internal state\n    \"\"\"\n    self.counter += 1\n    if not (self.update and self.counter &gt; self.count and self.state is not None):\n        return\n    self.f(self.state)\n    self.counter = 0\n    self.update = False\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.ReceiveListUpdater.set","title":"<code>set(state)</code>","text":"<p>Set the Updater's state</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>def set(self, state):\n    \"\"\"\n    Set the Updater's state\n    \"\"\"\n    self.state = state\n    self.update = True\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.ReceiveUpdater","title":"<code>ReceiveUpdater</code>","text":"<p>Decouples event handling from updating Updating is rate-limited by a counter TODO: Rename to ReceiveArgsUpdater?</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class ReceiveUpdater:\n    \"\"\"\n    Decouples event handling from updating\n    Updating is rate-limited by a counter\n    TODO: Rename to ReceiveArgsUpdater?\n    \"\"\"\n\n    def __init__(self, f, state=None, count=5, update=False):\n        self.f = f\n        self.count = count\n        self.counter = 0\n        self.update = update\n        self.state = state\n\n    def set(self, state):\n        \"\"\"\n        Set the Updater's state\n        \"\"\"\n        self.state = state\n        self.update = True\n\n    def __call__(self):\n        \"\"\"\n        Update the target function with internal state\n        \"\"\"\n        self.counter += 1\n        if not (self.update and self.counter &gt; self.count and self.state is not None):\n            return\n        self.ret = self.f(*self.state)\n        \"\"\"\n        if ret is not None:\n            route = self.pascal_to_path(kwargs['name'])\n            print('wrapper', route, ret, self.client_name)\n            self.osc.return_to_sender_by_name((route, ret), self.client_name)\n        \"\"\"\n        self.counter = 0\n        self.update = False\n        return self.ret\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.ReceiveUpdater.__call__","title":"<code>__call__()</code>","text":"<p>Update the target function with internal state</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>def __call__(self):\n    \"\"\"\n    Update the target function with internal state\n    \"\"\"\n    self.counter += 1\n    if not (self.update and self.counter &gt; self.count and self.state is not None):\n        return\n    self.ret = self.f(*self.state)\n    \"\"\"\n    if ret is not None:\n        route = self.pascal_to_path(kwargs['name'])\n        print('wrapper', route, ret, self.client_name)\n        self.osc.return_to_sender_by_name((route, ret), self.client_name)\n    \"\"\"\n    self.counter = 0\n    self.update = False\n    return self.ret\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.ReceiveUpdater.set","title":"<code>set(state)</code>","text":"<p>Set the Updater's state</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>def set(self, state):\n    \"\"\"\n    Set the Updater's state\n    \"\"\"\n    self.state = state\n    self.update = True\n</code></pre>"},{"location":"reference/tolvera/osc/update/#tolvera.osc.update.Updater","title":"<code>Updater</code>","text":"<p>Rate-limited function call</p> Source code in <code>src/tolvera/osc/update.py</code> <pre><code>class Updater:\n    \"\"\"\n    Rate-limited function call\n    \"\"\"\n\n    def __init__(self, f, count: int = 1):\n        self.f = f\n        self.count = int(count)\n        self.counter = 0\n\n    def __call__(self, *args, **kwargs):\n        self.counter += 1\n        if self.counter &gt;= self.count:\n            self.counter = 0\n            return self.f(*args, **kwargs)\n        return None\n</code></pre>"},{"location":"reference/tolvera/vera/__init__/","title":"init","text":""},{"location":"reference/tolvera/vera/flock/","title":"Flock","text":"<p>Inspired by https://forum.taichi-lang.cn/t/homework0-boids/563</p>"},{"location":"reference/tolvera/vera/forces/","title":"Forces","text":""},{"location":"reference/tolvera/vera/reaction_diffusion/","title":"Reaction diffusion","text":"<p>Inspired by https://github.com/taichi-dev/faster-python-with-taichi/blob/main/reaction_diffusion_taichi.py</p>"},{"location":"reference/tolvera/vera/slime/","title":"Slime","text":"<p>Inspired by https://github.com/taichi-dev/taichi/blob/master/python/taichi/examples/simulation/physarum.py</p>"}]}